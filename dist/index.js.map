{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChMA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxvqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;AEDA;AACA;AACA;AACA","sources":["../webpack://action-scw-secret/./dist/index.js","../webpack://action-scw-secret/./dist/utils.js","../webpack://action-scw-secret/./node_modules/@actions/core/lib/command.js","../webpack://action-scw-secret/./node_modules/@actions/core/lib/core.js","../webpack://action-scw-secret/./node_modules/@actions/core/lib/file-command.js","../webpack://action-scw-secret/./node_modules/@actions/core/lib/oidc-utils.js","../webpack://action-scw-secret/./node_modules/@actions/core/lib/path-utils.js","../webpack://action-scw-secret/./node_modules/@actions/core/lib/summary.js","../webpack://action-scw-secret/./node_modules/@actions/core/lib/utils.js","../webpack://action-scw-secret/./node_modules/@actions/http-client/lib/auth.js","../webpack://action-scw-secret/./node_modules/@actions/http-client/lib/index.js","../webpack://action-scw-secret/./node_modules/@actions/http-client/lib/proxy.js","../webpack://action-scw-secret/./node_modules/cross-fetch/dist/node-polyfill.js","../webpack://action-scw-secret/./node_modules/cross-fetch/dist/node-ponyfill.js","../webpack://action-scw-secret/./node_modules/node-fetch/lib/index.js","../webpack://action-scw-secret/./node_modules/tr46/index.js","../webpack://action-scw-secret/./node_modules/tunnel/index.js","../webpack://action-scw-secret/./node_modules/tunnel/lib/tunnel.js","../webpack://action-scw-secret/./node_modules/uuid/dist/index.js","../webpack://action-scw-secret/./node_modules/uuid/dist/md5.js","../webpack://action-scw-secret/./node_modules/uuid/dist/nil.js","../webpack://action-scw-secret/./node_modules/uuid/dist/parse.js","../webpack://action-scw-secret/./node_modules/uuid/dist/regex.js","../webpack://action-scw-secret/./node_modules/uuid/dist/rng.js","../webpack://action-scw-secret/./node_modules/uuid/dist/sha1.js","../webpack://action-scw-secret/./node_modules/uuid/dist/stringify.js","../webpack://action-scw-secret/./node_modules/uuid/dist/v1.js","../webpack://action-scw-secret/./node_modules/uuid/dist/v3.js","../webpack://action-scw-secret/./node_modules/uuid/dist/v35.js","../webpack://action-scw-secret/./node_modules/uuid/dist/v4.js","../webpack://action-scw-secret/./node_modules/uuid/dist/v5.js","../webpack://action-scw-secret/./node_modules/uuid/dist/validate.js","../webpack://action-scw-secret/./node_modules/uuid/dist/version.js","../webpack://action-scw-secret/./node_modules/webidl-conversions/lib/index.js","../webpack://action-scw-secret/./node_modules/whatwg-url/lib/URL-impl.js","../webpack://action-scw-secret/./node_modules/whatwg-url/lib/URL.js","../webpack://action-scw-secret/./node_modules/whatwg-url/lib/public-api.js","../webpack://action-scw-secret/./node_modules/whatwg-url/lib/url-state-machine.js","../webpack://action-scw-secret/./node_modules/whatwg-url/lib/utils.js","../webpack://action-scw-secret/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://action-scw-secret/external node-commonjs \"assert\"","../webpack://action-scw-secret/external node-commonjs \"crypto\"","../webpack://action-scw-secret/external node-commonjs \"events\"","../webpack://action-scw-secret/external node-commonjs \"fs\"","../webpack://action-scw-secret/external node-commonjs \"http\"","../webpack://action-scw-secret/external node-commonjs \"https\"","../webpack://action-scw-secret/external node-commonjs \"net\"","../webpack://action-scw-secret/external node-commonjs \"os\"","../webpack://action-scw-secret/external node-commonjs \"path\"","../webpack://action-scw-secret/external node-commonjs \"punycode\"","../webpack://action-scw-secret/external node-commonjs \"stream\"","../webpack://action-scw-secret/external node-commonjs \"tls\"","../webpack://action-scw-secret/external node-commonjs \"url\"","../webpack://action-scw-secret/external node-commonjs \"util\"","../webpack://action-scw-secret/external node-commonjs \"zlib\"","../webpack://action-scw-secret/./node_modules/@scaleway/sdk/dist/index.cjs","../webpack://action-scw-secret/webpack/bootstrap","../webpack://action-scw-secret/webpack/runtime/compat","../webpack://action-scw-secret/webpack/before-startup","../webpack://action-scw-secret/webpack/startup","../webpack://action-scw-secret/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.run = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nrequire(\"cross-fetch/polyfill\");\nconst sdk_1 = require(\"@scaleway/sdk\");\nconst utils_1 = require(\"./utils\");\nfunction run() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const client = (0, sdk_1.createClient)({\n                accessKey: core.getInput(\"access-key\"),\n                secretKey: core.getInput(\"secret-key\"),\n                defaultProjectId: core.getInput(\"default-project-id\"),\n                defaultOrganizationId: core.getInput(\"default-organization-id\"),\n                defaultRegion: core.getInput(\"default-region\"),\n                defaultZone: core.getInput(\"default-zone\"),\n            });\n            const api = new sdk_1.Secret.v1alpha1.API(client);\n            const secretConfigInputs = [\n                ...new Set(core.getMultilineInput(\"secret-names\")),\n            ];\n            for (let secretConf of secretConfigInputs) {\n                const [envName, secretName] = (0, utils_1.extractAlias)(secretConf);\n                try {\n                    const secretValue = yield (0, utils_1.getSecretValue)(api, secretName);\n                    core.setSecret(secretValue);\n                    core.debug(`Injecting secret ${secretName} as environment variable '${envName}'.`);\n                    core.exportVariable(envName, secretValue);\n                }\n                catch (error) {\n                    core.setFailed(`Failed to fetch secret: '${secretName}'. Error: ${error}.`);\n                }\n            }\n        }\n        catch (error) {\n            if (error instanceof Error)\n                core.setFailed(error.message);\n        }\n    });\n}\nexports.run = run;\nrun();\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSecretValue = exports.extractAlias = exports.transformToValidEnvName = void 0;\nfunction transformToValidEnvName(secretName) {\n    // Leading digits are invalid\n    if (secretName.match(/^[0-9]/)) {\n        secretName = \"_\".concat(secretName);\n    }\n    // Remove invalid characters\n    return secretName.replace(/[^a-zA-Z0-9_]/g, \"_\").toUpperCase();\n}\nexports.transformToValidEnvName = transformToValidEnvName;\nfunction extractAlias(input) {\n    const parsedInput = input.split(\",\");\n    if (parsedInput.length > 1) {\n        const alias = parsedInput[0].trim();\n        const secretName = parsedInput[1].trim();\n        const validateEnvName = transformToValidEnvName(alias);\n        if (alias !== validateEnvName) {\n            throw new Error(`The alias '${alias}' is not a valid environment name. Please verify that it has uppercase letters, numbers, and underscore only.`);\n        }\n        return [alias, secretName];\n    }\n    return [transformToValidEnvName(input.trim()), input.trim()];\n}\nexports.extractAlias = extractAlias;\nfunction getSecretValue(api, secretName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const secretResponse = yield api.accessSecretVersionByName({\n            secretName: secretName,\n            revision: \"latest\",\n        });\n        return Buffer.from(secretResponse.data, \"base64\").toString(\"binary\");\n    });\n}\nexports.getSecretValue = getSecretValue;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));\n    }\n    command_1.issueCommand('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueFileCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n/**\n * Path exports\n */\nvar path_utils_1 = require(\"./path-utils\");\nObject.defineProperty(exports, \"toPosixPath\", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });\nObject.defineProperty(exports, \"toWin32Path\", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });\nObject.defineProperty(exports, \"toPlatformPath\", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst uuid_1 = require(\"uuid\");\nconst utils_1 = require(\"./utils\");\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${uuid_1.v4()}`;\n    const convertedValue = utils_1.toCommandValue(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let's not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, '/');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, '\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const reqHost = reqUrl.hostname;\n    if (isLoopbackAddress(reqHost)) {\n        return true;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperNoProxyItem === '*' ||\n            upperReqHosts.some(x => x === upperNoProxyItem ||\n                x.endsWith(`.${upperNoProxyItem}`) ||\n                (upperNoProxyItem.startsWith('.') &&\n                    x.endsWith(`${upperNoProxyItem}`)))) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\nfunction isLoopbackAddress(host) {\n    const hostLower = host.toLowerCase();\n    return (hostLower === 'localhost' ||\n        hostLower.startsWith('127.') ||\n        hostLower.startsWith('[::1]') ||\n        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));\n}\n//# sourceMappingURL=proxy.js.map","const fetchNode = require('./node-ponyfill')\nconst fetch = fetchNode.fetch.bind({})\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Response = fetchNode.Response\n  global.Headers = fetchNode.Headers\n  global.Request = fetchNode.Request\n}\n","const nodeFetch = require('node-fetch')\nconst realFetch = nodeFetch.default || nodeFetch\n\nconst fetch = function (url, options) {\n  // Support schemaless URIs on the server for parity with the browser.\n  // Ex: //github.com/ -> https://github.com/\n  if (/^\\/\\//.test(url)) {\n    url = 'https:' + url\n  }\n  return realFetch.call(this, url, options)\n}\n\nfetch.ponyfill = true\n\nmodule.exports = exports = fetch\nexports.fetch = fetch\nexports.Headers = nodeFetch.Headers\nexports.Request = nodeFetch.Request\nexports.Response = nodeFetch.Response\n\n// Needed for TypeScript consumers without esModuleInterop.\nexports.default = fetch\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Stream = _interopDefault(require('stream'));\nvar http = _interopDefault(require('http'));\nvar Url = _interopDefault(require('url'));\nvar whatwgUrl = _interopDefault(require('whatwg-url'));\nvar https = _interopDefault(require('https'));\nvar zlib = _interopDefault(require('zlib'));\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n\tconst orig = new URL$1(original).protocol;\n\tconst dest = new URL$1(destination).protocol;\n\n\treturn orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\tdestroyStream(request.body, error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(req, function (err) {\n\t\t\tif (signal && signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (parseInt(process.version.substring(1)) < 14) {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\treq.on('socket', function (s) {\n\t\t\t\ts.addListener('close', function (hadError) {\n\t\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\t\tconst hasDataListener = s.listenerCount('data') > 0;\n\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n\t\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.on('end', function () {\n\t\t\t\t\t// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tlet socket;\n\n\trequest.on('socket', function (s) {\n\t\tsocket = s;\n\t});\n\n\trequest.on('response', function (response) {\n\t\tconst headers = response.headers;\n\n\t\tif (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n\t\t\tresponse.once('close', function (hadError) {\n\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\tconst hasDataListener = socket.listenerCount('data') > 0;\n\n\t\t\t\tif (hasDataListener && !hadError) {\n\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\terrorCallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction destroyStream(stream, err) {\n\tif (stream.destroy) {\n\t\tstream.destroy(err);\n\t} else {\n\t\t// node < 8\n\t\tstream.emit('error', err);\n\t\tstream.end();\n\t}\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nmodule.exports = exports = fetch;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;\n","\"use strict\";\n\nvar punycode = require(\"punycode\");\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar PROCESSING_OPTIONS = {\n  TRANSITIONAL: 0,\n  NONTRANSITIONAL: 1\n};\n\nfunction normalize(str) { // fix bug in v8\n  return str.split('\\u0000').map(function (s) { return s.normalize('NFC'); }).join('\\u0000');\n}\n\nfunction findStatus(val) {\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n\n    var target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      return target;\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction countSymbols(string) {\n  return string\n    // replace every surrogate pair with a BMP symbol\n    .replace(regexAstralSymbols, '_')\n    // then get the length\n    .length;\n}\n\nfunction mapChars(domain_name, useSTD3, processing_option) {\n  var hasError = false;\n  var processed = \"\";\n\n  var len = countSymbols(domain_name);\n  for (var i = 0; i < len; ++i) {\n    var codePoint = domain_name.codePointAt(i);\n    var status = findStatus(codePoint);\n\n    switch (status[1]) {\n      case \"disallowed\":\n        hasError = true;\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += String.fromCodePoint.apply(String, status[2]);\n        break;\n      case \"deviation\":\n        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        } else {\n          processed += String.fromCodePoint(codePoint);\n        }\n        break;\n      case \"valid\":\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"disallowed_STD3_mapped\":\n        if (useSTD3) {\n          hasError = true;\n          processed += String.fromCodePoint(codePoint);\n        } else {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        }\n        break;\n      case \"disallowed_STD3_valid\":\n        if (useSTD3) {\n          hasError = true;\n        }\n\n        processed += String.fromCodePoint(codePoint);\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nvar combiningMarksRegex = /[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2D]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDE2C-\\uDE37\\uDEDF-\\uDEEA\\uDF01-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD83A[\\uDCD0-\\uDCD6]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nfunction validateLabel(label, processing_option) {\n  if (label.substr(0, 4) === \"xn--\") {\n    label = punycode.toUnicode(label);\n    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;\n  }\n\n  var error = false;\n\n  if (normalize(label) !== label ||\n      (label[3] === \"-\" && label[4] === \"-\") ||\n      label[0] === \"-\" || label[label.length - 1] === \"-\" ||\n      label.indexOf(\".\") !== -1 ||\n      label.search(combiningMarksRegex) === 0) {\n    error = true;\n  }\n\n  var len = countSymbols(label);\n  for (var i = 0; i < len; ++i) {\n    var status = findStatus(label.codePointAt(i));\n    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== \"valid\") ||\n        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&\n         status[1] !== \"valid\" && status[1] !== \"deviation\")) {\n      error = true;\n      break;\n    }\n  }\n\n  return {\n    label: label,\n    error: error\n  };\n}\n\nfunction processing(domain_name, useSTD3, processing_option) {\n  var result = mapChars(domain_name, useSTD3, processing_option);\n  result.string = normalize(result.string);\n\n  var labels = result.string.split(\".\");\n  for (var i = 0; i < labels.length; ++i) {\n    try {\n      var validation = validateLabel(labels[i]);\n      labels[i] = validation.label;\n      result.error = result.error || validation.error;\n    } catch(e) {\n      result.error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: result.error\n  };\n}\n\nmodule.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {\n  var result = processing(domain_name, useSTD3, processing_option);\n  var labels = result.string.split(\".\");\n  labels = labels.map(function(l) {\n    try {\n      return punycode.toASCII(l);\n    } catch(e) {\n      result.error = true;\n      return l;\n    }\n  });\n\n  if (verifyDnsLength) {\n    var total = labels.slice(0, labels.length - 1).join(\".\").length;\n    if (total.length > 253 || total.length === 0) {\n      result.error = true;\n    }\n\n    for (var i=0; i < labels.length; ++i) {\n      if (labels.length > 63 || labels.length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) return null;\n  return labels.join(\".\");\n};\n\nmodule.exports.toUnicode = function(domain_name, useSTD3) {\n  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n};\n\nmodule.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('md5').update(bytes).digest();\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\n\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    _crypto.default.randomFillSync(rnds8Pool);\n\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('sha1').update(bytes).digest();\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;","\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\n\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n\n    return function(V, opts) {\n        if (!opts) opts = {};\n\n        let x = +V;\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n\n            return x;\n        }\n\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n              x += moduloVal;\n            } else if (x === -0) { // don't return negative zero\n              return 0;\n            }\n        }\n\n        return x;\n    }\n}\n\nconversions[\"void\"] = function () {\n    return undefined;\n};\n\nconversions[\"boolean\"] = function (val) {\n    return !!val;\n};\n\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\n\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\n\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\n\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\n\nconversions[\"double\"] = function (V) {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n\n    return x;\n};\n\nconversions[\"unrestricted double\"] = function (V) {\n    const x = +V;\n\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n\n    return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\n\nconversions[\"DOMString\"] = function (V, opts) {\n    if (!opts) opts = {};\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    return String(V);\n};\n\nconversions[\"ByteString\"] = function (V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n\n    return x;\n};\n\nconversions[\"USVString\"] = function (V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n\n    return U.join('');\n};\n\nconversions[\"Date\"] = function (V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n\n    return V;\n};\n\nconversions[\"RegExp\"] = function (V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n\n    return V;\n};\n","\"use strict\";\nconst usm = require(\"./url-state-machine\");\n\nexports.implementation = class URLImpl {\n  constructor(constructorArgs) {\n    const url = constructorArgs[0];\n    const base = constructorArgs[1];\n\n    let parsedBase = null;\n    if (base !== undefined) {\n      parsedBase = usm.basicURLParse(base);\n      if (parsedBase === \"failure\") {\n        throw new TypeError(\"Invalid base URL\");\n      }\n    }\n\n    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n\n    // TODO: query stuff\n  }\n\n  get href() {\n    return usm.serializeURL(this._url);\n  }\n\n  set href(v) {\n    const parsedURL = usm.basicURLParse(v);\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n  }\n\n  get origin() {\n    return usm.serializeURLOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    usm.basicURLParse(v + \":\", { url: this._url, stateOverride: \"scheme start\" });\n  }\n\n  get username() {\n    return this._url.username;\n  }\n\n  set username(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setTheUsername(this._url, v);\n  }\n\n  get password() {\n    return this._url.password;\n  }\n\n  set password(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setThePassword(this._url, v);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return usm.serializeHost(url.host);\n    }\n\n    return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"host\" });\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return usm.serializeHost(this._url.host);\n  }\n\n  set hostname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"hostname\" });\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return usm.serializeInteger(this._url.port);\n  }\n\n  set port(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    if (v === \"\") {\n      this._url.port = null;\n    } else {\n      usm.basicURLParse(v, { url: this._url, stateOverride: \"port\" });\n    }\n  }\n\n  get pathname() {\n    if (this._url.cannotBeABaseURL) {\n      return this._url.path[0];\n    }\n\n    if (this._url.path.length === 0) {\n      return \"\";\n    }\n\n    return \"/\" + this._url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    this._url.path = [];\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n\n  set search(v) {\n    // TODO: query stuff\n\n    const url = this._url;\n\n    if (v === \"\") {\n      url.query = null;\n      return;\n    }\n\n    const input = v[0] === \"?\" ? v.substring(1) : v;\n    url.query = \"\";\n    usm.basicURLParse(input, { url, stateOverride: \"query\" });\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n\n  set hash(v) {\n    if (v === \"\") {\n      this._url.fragment = null;\n      return;\n    }\n\n    const input = v[0] === \"#\" ? v.substring(1) : v;\n    this._url.fragment = \"\";\n    usm.basicURLParse(input, { url: this._url, stateOverride: \"fragment\" });\n  }\n\n  toJSON() {\n    return this.href;\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Impl = require(\".//URL-impl.js\");\n\nconst impl = utils.implSymbol;\n\nfunction URL(url) {\n  if (!this || this[impl] || !(this instanceof URL)) {\n    throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"USVString\"](args[1]);\n  }\n\n  module.exports.setup(this, args);\n}\n\nURL.prototype.toJSON = function toJSON() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = arguments[i];\n  }\n  return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nURL.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this.href;\n};\n\nObject.defineProperty(URL.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nmodule.exports = {\n  is(obj) {\n    return !!obj && obj[impl] instanceof Impl.implementation;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URL.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: URL,\n  expose: {\n    Window: { URL: URL },\n    Worker: { URL: URL }\n  }\n};\n\n","\"use strict\";\n\nexports.URL = require(\"./URL\").interface;\nexports.serializeURL = require(\"./url-state-machine\").serializeURL;\nexports.serializeURLOrigin = require(\"./url-state-machine\").serializeURLOrigin;\nexports.basicURLParse = require(\"./url-state-machine\").basicURLParse;\nexports.setTheUsername = require(\"./url-state-machine\").setTheUsername;\nexports.setThePassword = require(\"./url-state-machine\").setThePassword;\nexports.serializeHost = require(\"./url-state-machine\").serializeHost;\nexports.serializeInteger = require(\"./url-state-machine\").serializeInteger;\nexports.parseURL = require(\"./url-state-machine\").parseURL;\n","\"use strict\";\r\nconst punycode = require(\"punycode\");\r\nconst tr46 = require(\"tr46\");\r\n\r\nconst specialSchemes = {\r\n  ftp: 21,\r\n  file: null,\r\n  gopher: 70,\r\n  http: 80,\r\n  https: 443,\r\n  ws: 80,\r\n  wss: 443\r\n};\r\n\r\nconst failure = Symbol(\"failure\");\r\n\r\nfunction countSymbols(str) {\r\n  return punycode.ucs2.decode(str).length;\r\n}\r\n\r\nfunction at(input, idx) {\r\n  const c = input[idx];\r\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\r\n}\r\n\r\nfunction isASCIIDigit(c) {\r\n  return c >= 0x30 && c <= 0x39;\r\n}\r\n\r\nfunction isASCIIAlpha(c) {\r\n  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);\r\n}\r\n\r\nfunction isASCIIAlphanumeric(c) {\r\n  return isASCIIAlpha(c) || isASCIIDigit(c);\r\n}\r\n\r\nfunction isASCIIHex(c) {\r\n  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);\r\n}\r\n\r\nfunction isSingleDot(buffer) {\r\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\r\n}\r\n\r\nfunction isDoubleDot(buffer) {\r\n  buffer = buffer.toLowerCase();\r\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\r\n}\r\n\r\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\r\n  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\r\n}\r\n\r\nfunction isWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\r\n}\r\n\r\nfunction containsForbiddenHostCodePoint(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction isSpecialScheme(scheme) {\r\n  return specialSchemes[scheme] !== undefined;\r\n}\r\n\r\nfunction isSpecial(url) {\r\n  return isSpecialScheme(url.scheme);\r\n}\r\n\r\nfunction defaultPort(scheme) {\r\n  return specialSchemes[scheme];\r\n}\r\n\r\nfunction percentEncode(c) {\r\n  let hex = c.toString(16).toUpperCase();\r\n  if (hex.length === 1) {\r\n    hex = \"0\" + hex;\r\n  }\r\n\r\n  return \"%\" + hex;\r\n}\r\n\r\nfunction utf8PercentEncode(c) {\r\n  const buf = new Buffer(c);\r\n\r\n  let str = \"\";\r\n\r\n  for (let i = 0; i < buf.length; ++i) {\r\n    str += percentEncode(buf[i]);\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction utf8PercentDecode(str) {\r\n  const input = new Buffer(str);\r\n  const output = [];\r\n  for (let i = 0; i < input.length; ++i) {\r\n    if (input[i] !== 37) {\r\n      output.push(input[i]);\r\n    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\r\n      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\r\n      i += 2;\r\n    } else {\r\n      output.push(input[i]);\r\n    }\r\n  }\r\n  return new Buffer(output).toString();\r\n}\r\n\r\nfunction isC0ControlPercentEncode(c) {\r\n  return c <= 0x1F || c > 0x7E;\r\n}\r\n\r\nconst extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);\r\nfunction isPathPercentEncode(c) {\r\n  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\r\n}\r\n\r\nconst extraUserinfoPercentEncodeSet =\r\n  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\r\nfunction isUserinfoPercentEncode(c) {\r\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\r\n}\r\n\r\nfunction percentEncodeChar(c, encodeSetPredicate) {\r\n  const cStr = String.fromCodePoint(c);\r\n\r\n  if (encodeSetPredicate(c)) {\r\n    return utf8PercentEncode(cStr);\r\n  }\r\n\r\n  return cStr;\r\n}\r\n\r\nfunction parseIPv4Number(input) {\r\n  let R = 10;\r\n\r\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\r\n    input = input.substring(2);\r\n    R = 16;\r\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\r\n    input = input.substring(1);\r\n    R = 8;\r\n  }\r\n\r\n  if (input === \"\") {\r\n    return 0;\r\n  }\r\n\r\n  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);\r\n  if (regex.test(input)) {\r\n    return failure;\r\n  }\r\n\r\n  return parseInt(input, R);\r\n}\r\n\r\nfunction parseIPv4(input) {\r\n  const parts = input.split(\".\");\r\n  if (parts[parts.length - 1] === \"\") {\r\n    if (parts.length > 1) {\r\n      parts.pop();\r\n    }\r\n  }\r\n\r\n  if (parts.length > 4) {\r\n    return input;\r\n  }\r\n\r\n  const numbers = [];\r\n  for (const part of parts) {\r\n    if (part === \"\") {\r\n      return input;\r\n    }\r\n    const n = parseIPv4Number(part);\r\n    if (n === failure) {\r\n      return input;\r\n    }\r\n\r\n    numbers.push(n);\r\n  }\r\n\r\n  for (let i = 0; i < numbers.length - 1; ++i) {\r\n    if (numbers[i] > 255) {\r\n      return failure;\r\n    }\r\n  }\r\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\r\n    return failure;\r\n  }\r\n\r\n  let ipv4 = numbers.pop();\r\n  let counter = 0;\r\n\r\n  for (const n of numbers) {\r\n    ipv4 += n * Math.pow(256, 3 - counter);\r\n    ++counter;\r\n  }\r\n\r\n  return ipv4;\r\n}\r\n\r\nfunction serializeIPv4(address) {\r\n  let output = \"\";\r\n  let n = address;\r\n\r\n  for (let i = 1; i <= 4; ++i) {\r\n    output = String(n % 256) + output;\r\n    if (i !== 4) {\r\n      output = \".\" + output;\r\n    }\r\n    n = Math.floor(n / 256);\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseIPv6(input) {\r\n  const address = [0, 0, 0, 0, 0, 0, 0, 0];\r\n  let pieceIndex = 0;\r\n  let compress = null;\r\n  let pointer = 0;\r\n\r\n  input = punycode.ucs2.decode(input);\r\n\r\n  if (input[pointer] === 58) {\r\n    if (input[pointer + 1] !== 58) {\r\n      return failure;\r\n    }\r\n\r\n    pointer += 2;\r\n    ++pieceIndex;\r\n    compress = pieceIndex;\r\n  }\r\n\r\n  while (pointer < input.length) {\r\n    if (pieceIndex === 8) {\r\n      return failure;\r\n    }\r\n\r\n    if (input[pointer] === 58) {\r\n      if (compress !== null) {\r\n        return failure;\r\n      }\r\n      ++pointer;\r\n      ++pieceIndex;\r\n      compress = pieceIndex;\r\n      continue;\r\n    }\r\n\r\n    let value = 0;\r\n    let length = 0;\r\n\r\n    while (length < 4 && isASCIIHex(input[pointer])) {\r\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\r\n      ++pointer;\r\n      ++length;\r\n    }\r\n\r\n    if (input[pointer] === 46) {\r\n      if (length === 0) {\r\n        return failure;\r\n      }\r\n\r\n      pointer -= length;\r\n\r\n      if (pieceIndex > 6) {\r\n        return failure;\r\n      }\r\n\r\n      let numbersSeen = 0;\r\n\r\n      while (input[pointer] !== undefined) {\r\n        let ipv4Piece = null;\r\n\r\n        if (numbersSeen > 0) {\r\n          if (input[pointer] === 46 && numbersSeen < 4) {\r\n            ++pointer;\r\n          } else {\r\n            return failure;\r\n          }\r\n        }\r\n\r\n        if (!isASCIIDigit(input[pointer])) {\r\n          return failure;\r\n        }\r\n\r\n        while (isASCIIDigit(input[pointer])) {\r\n          const number = parseInt(at(input, pointer));\r\n          if (ipv4Piece === null) {\r\n            ipv4Piece = number;\r\n          } else if (ipv4Piece === 0) {\r\n            return failure;\r\n          } else {\r\n            ipv4Piece = ipv4Piece * 10 + number;\r\n          }\r\n          if (ipv4Piece > 255) {\r\n            return failure;\r\n          }\r\n          ++pointer;\r\n        }\r\n\r\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\r\n\r\n        ++numbersSeen;\r\n\r\n        if (numbersSeen === 2 || numbersSeen === 4) {\r\n          ++pieceIndex;\r\n        }\r\n      }\r\n\r\n      if (numbersSeen !== 4) {\r\n        return failure;\r\n      }\r\n\r\n      break;\r\n    } else if (input[pointer] === 58) {\r\n      ++pointer;\r\n      if (input[pointer] === undefined) {\r\n        return failure;\r\n      }\r\n    } else if (input[pointer] !== undefined) {\r\n      return failure;\r\n    }\r\n\r\n    address[pieceIndex] = value;\r\n    ++pieceIndex;\r\n  }\r\n\r\n  if (compress !== null) {\r\n    let swaps = pieceIndex - compress;\r\n    pieceIndex = 7;\r\n    while (pieceIndex !== 0 && swaps > 0) {\r\n      const temp = address[compress + swaps - 1];\r\n      address[compress + swaps - 1] = address[pieceIndex];\r\n      address[pieceIndex] = temp;\r\n      --pieceIndex;\r\n      --swaps;\r\n    }\r\n  } else if (compress === null && pieceIndex !== 8) {\r\n    return failure;\r\n  }\r\n\r\n  return address;\r\n}\r\n\r\nfunction serializeIPv6(address) {\r\n  let output = \"\";\r\n  const seqResult = findLongestZeroSequence(address);\r\n  const compress = seqResult.idx;\r\n  let ignore0 = false;\r\n\r\n  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\r\n    if (ignore0 && address[pieceIndex] === 0) {\r\n      continue;\r\n    } else if (ignore0) {\r\n      ignore0 = false;\r\n    }\r\n\r\n    if (compress === pieceIndex) {\r\n      const separator = pieceIndex === 0 ? \"::\" : \":\";\r\n      output += separator;\r\n      ignore0 = true;\r\n      continue;\r\n    }\r\n\r\n    output += address[pieceIndex].toString(16);\r\n\r\n    if (pieceIndex !== 7) {\r\n      output += \":\";\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseHost(input, isSpecialArg) {\r\n  if (input[0] === \"[\") {\r\n    if (input[input.length - 1] !== \"]\") {\r\n      return failure;\r\n    }\r\n\r\n    return parseIPv6(input.substring(1, input.length - 1));\r\n  }\r\n\r\n  if (!isSpecialArg) {\r\n    return parseOpaqueHost(input);\r\n  }\r\n\r\n  const domain = utf8PercentDecode(input);\r\n  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\r\n  if (asciiDomain === null) {\r\n    return failure;\r\n  }\r\n\r\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\r\n    return failure;\r\n  }\r\n\r\n  const ipv4Host = parseIPv4(asciiDomain);\r\n  if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\r\n    return ipv4Host;\r\n  }\r\n\r\n  return asciiDomain;\r\n}\r\n\r\nfunction parseOpaqueHost(input) {\r\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\r\n    return failure;\r\n  }\r\n\r\n  let output = \"\";\r\n  const decoded = punycode.ucs2.decode(input);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction findLongestZeroSequence(arr) {\r\n  let maxIdx = null;\r\n  let maxLen = 1; // only find elements > 1\r\n  let currStart = null;\r\n  let currLen = 0;\r\n\r\n  for (let i = 0; i < arr.length; ++i) {\r\n    if (arr[i] !== 0) {\r\n      if (currLen > maxLen) {\r\n        maxIdx = currStart;\r\n        maxLen = currLen;\r\n      }\r\n\r\n      currStart = null;\r\n      currLen = 0;\r\n    } else {\r\n      if (currStart === null) {\r\n        currStart = i;\r\n      }\r\n      ++currLen;\r\n    }\r\n  }\r\n\r\n  // if trailing zeros\r\n  if (currLen > maxLen) {\r\n    maxIdx = currStart;\r\n    maxLen = currLen;\r\n  }\r\n\r\n  return {\r\n    idx: maxIdx,\r\n    len: maxLen\r\n  };\r\n}\r\n\r\nfunction serializeHost(host) {\r\n  if (typeof host === \"number\") {\r\n    return serializeIPv4(host);\r\n  }\r\n\r\n  // IPv6 serializer\r\n  if (host instanceof Array) {\r\n    return \"[\" + serializeIPv6(host) + \"]\";\r\n  }\r\n\r\n  return host;\r\n}\r\n\r\nfunction trimControlChars(url) {\r\n  return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\r\n}\r\n\r\nfunction trimTabAndNewline(url) {\r\n  return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\r\n}\r\n\r\nfunction shortenPath(url) {\r\n  const path = url.path;\r\n  if (path.length === 0) {\r\n    return;\r\n  }\r\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\r\n    return;\r\n  }\r\n\r\n  path.pop();\r\n}\r\n\r\nfunction includesCredentials(url) {\r\n  return url.username !== \"\" || url.password !== \"\";\r\n}\r\n\r\nfunction cannotHaveAUsernamePasswordPort(url) {\r\n  return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetter(string) {\r\n  return /^[A-Za-z]:$/.test(string);\r\n}\r\n\r\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\r\n  this.pointer = 0;\r\n  this.input = input;\r\n  this.base = base || null;\r\n  this.encodingOverride = encodingOverride || \"utf-8\";\r\n  this.stateOverride = stateOverride;\r\n  this.url = url;\r\n  this.failure = false;\r\n  this.parseError = false;\r\n\r\n  if (!this.url) {\r\n    this.url = {\r\n      scheme: \"\",\r\n      username: \"\",\r\n      password: \"\",\r\n      host: null,\r\n      port: null,\r\n      path: [],\r\n      query: null,\r\n      fragment: null,\r\n\r\n      cannotBeABaseURL: false\r\n    };\r\n\r\n    const res = trimControlChars(this.input);\r\n    if (res !== this.input) {\r\n      this.parseError = true;\r\n    }\r\n    this.input = res;\r\n  }\r\n\r\n  const res = trimTabAndNewline(this.input);\r\n  if (res !== this.input) {\r\n    this.parseError = true;\r\n  }\r\n  this.input = res;\r\n\r\n  this.state = stateOverride || \"scheme start\";\r\n\r\n  this.buffer = \"\";\r\n  this.atFlag = false;\r\n  this.arrFlag = false;\r\n  this.passwordTokenSeenFlag = false;\r\n\r\n  this.input = punycode.ucs2.decode(this.input);\r\n\r\n  for (; this.pointer <= this.input.length; ++this.pointer) {\r\n    const c = this.input[this.pointer];\r\n    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\r\n\r\n    // exec state machine\r\n    const ret = this[\"parse \" + this.state](c, cStr);\r\n    if (!ret) {\r\n      break; // terminate algorithm\r\n    } else if (ret === failure) {\r\n      this.failure = true;\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\r\n  if (isASCIIAlpha(c)) {\r\n    this.buffer += cStr.toLowerCase();\r\n    this.state = \"scheme\";\r\n  } else if (!this.stateOverride) {\r\n    this.state = \"no scheme\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\r\n  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\r\n    this.buffer += cStr.toLowerCase();\r\n  } else if (c === 58) {\r\n    if (this.stateOverride) {\r\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\r\n        return false;\r\n      }\r\n\r\n      if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.url.scheme = this.buffer;\r\n    this.buffer = \"\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    if (this.url.scheme === \"file\") {\r\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\r\n        this.parseError = true;\r\n      }\r\n      this.state = \"file\";\r\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\r\n      this.state = \"special relative or authority\";\r\n    } else if (isSpecial(this.url)) {\r\n      this.state = \"special authority slashes\";\r\n    } else if (this.input[this.pointer + 1] === 47) {\r\n      this.state = \"path or authority\";\r\n      ++this.pointer;\r\n    } else {\r\n      this.url.cannotBeABaseURL = true;\r\n      this.url.path.push(\"\");\r\n      this.state = \"cannot-be-a-base-URL path\";\r\n    }\r\n  } else if (!this.stateOverride) {\r\n    this.buffer = \"\";\r\n    this.state = \"no scheme\";\r\n    this.pointer = -1;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\r\n  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {\r\n    return failure;\r\n  } else if (this.base.cannotBeABaseURL && c === 35) {\r\n    this.url.scheme = this.base.scheme;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.url.cannotBeABaseURL = true;\r\n    this.state = \"fragment\";\r\n  } else if (this.base.scheme === \"file\") {\r\n    this.state = \"file\";\r\n    --this.pointer;\r\n  } else {\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\r\n  if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\r\n  this.url.scheme = this.base.scheme;\r\n  if (isNaN(c)) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n  } else if (c === 47) {\r\n    this.state = \"relative slash\";\r\n  } else if (c === 63) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (isSpecial(this.url) && c === 92) {\r\n    this.parseError = true;\r\n    this.state = \"relative slash\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\r\n\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\r\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"special authority ignore slashes\";\r\n  } else if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"special authority ignore slashes\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\r\n  if (c !== 47 && c !== 92) {\r\n    this.state = \"authority\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\r\n  if (c === 64) {\r\n    this.parseError = true;\r\n    if (this.atFlag) {\r\n      this.buffer = \"%40\" + this.buffer;\r\n    }\r\n    this.atFlag = true;\r\n\r\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\r\n    const len = countSymbols(this.buffer);\r\n    for (let pointer = 0; pointer < len; ++pointer) {\r\n      const codePoint = this.buffer.codePointAt(pointer);\r\n\r\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\r\n        this.passwordTokenSeenFlag = true;\r\n        continue;\r\n      }\r\n      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\r\n      if (this.passwordTokenSeenFlag) {\r\n        this.url.password += encodedCodePoints;\r\n      } else {\r\n        this.url.username += encodedCodePoints;\r\n      }\r\n    }\r\n    this.buffer = \"\";\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    if (this.atFlag && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n    this.pointer -= countSymbols(this.buffer) + 1;\r\n    this.buffer = \"\";\r\n    this.state = \"host\";\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse hostname\"] =\r\nURLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\r\n  if (this.stateOverride && this.url.scheme === \"file\") {\r\n    --this.pointer;\r\n    this.state = \"file host\";\r\n  } else if (c === 58 && !this.arrFlag) {\r\n    if (this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"port\";\r\n    if (this.stateOverride === \"hostname\") {\r\n      return false;\r\n    }\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    --this.pointer;\r\n    if (isSpecial(this.url) && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    } else if (this.stateOverride && this.buffer === \"\" &&\r\n               (includesCredentials(this.url) || this.url.port !== null)) {\r\n      this.parseError = true;\r\n      return false;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"path start\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (c === 91) {\r\n      this.arrFlag = true;\r\n    } else if (c === 93) {\r\n      this.arrFlag = false;\r\n    }\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\r\n  if (isASCIIDigit(c)) {\r\n    this.buffer += cStr;\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92) ||\r\n             this.stateOverride) {\r\n    if (this.buffer !== \"\") {\r\n      const port = parseInt(this.buffer);\r\n      if (port > Math.pow(2, 16) - 1) {\r\n        this.parseError = true;\r\n        return failure;\r\n      }\r\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\r\n      this.buffer = \"\";\r\n    }\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    this.state = \"path start\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\r\n\r\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\r\n  this.url.scheme = \"file\";\r\n\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file slash\";\r\n  } else if (this.base !== null && this.base.scheme === \"file\") {\r\n    if (isNaN(c)) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n    } else if (c === 63) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    } else if (c === 35) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    } else {\r\n      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\r\n          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||\r\n          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\r\n           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {\r\n        this.url.host = this.base.host;\r\n        this.url.path = this.base.path.slice();\r\n        shortenPath(this.url);\r\n      } else {\r\n        this.parseError = true;\r\n      }\r\n\r\n      this.state = \"path\";\r\n      --this.pointer;\r\n    }\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file host\";\r\n  } else {\r\n    if (this.base !== null && this.base.scheme === \"file\") {\r\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\r\n        this.url.path.push(this.base.path[0]);\r\n      } else {\r\n        this.url.host = this.base.host;\r\n      }\r\n    }\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\r\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\r\n    --this.pointer;\r\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\r\n      this.parseError = true;\r\n      this.state = \"path\";\r\n    } else if (this.buffer === \"\") {\r\n      this.url.host = \"\";\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n      this.state = \"path start\";\r\n    } else {\r\n      let host = parseHost(this.buffer, isSpecial(this.url));\r\n      if (host === failure) {\r\n        return failure;\r\n      }\r\n      if (host === \"localhost\") {\r\n        host = \"\";\r\n      }\r\n      this.url.host = host;\r\n\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n\r\n      this.buffer = \"\";\r\n      this.state = \"path start\";\r\n    }\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\r\n  if (isSpecial(this.url)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"path\";\r\n\r\n    if (c !== 47 && c !== 92) {\r\n      --this.pointer;\r\n    }\r\n  } else if (!this.stateOverride && c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (!this.stateOverride && c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (c !== undefined) {\r\n    this.state = \"path\";\r\n    if (c !== 47) {\r\n      --this.pointer;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\r\n  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||\r\n      (!this.stateOverride && (c === 63 || c === 35))) {\r\n    if (isSpecial(this.url) && c === 92) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (isDoubleDot(this.buffer)) {\r\n      shortenPath(this.url);\r\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\r\n        this.url.path.push(\"\");\r\n      }\r\n    } else if (isSingleDot(this.buffer) && c !== 47 &&\r\n               !(isSpecial(this.url) && c === 92)) {\r\n      this.url.path.push(\"\");\r\n    } else if (!isSingleDot(this.buffer)) {\r\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\r\n        if (this.url.host !== \"\" && this.url.host !== null) {\r\n          this.parseError = true;\r\n          this.url.host = \"\";\r\n        }\r\n        this.buffer = this.buffer[0] + \":\";\r\n      }\r\n      this.url.path.push(this.buffer);\r\n    }\r\n    this.buffer = \"\";\r\n    if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\r\n      while (this.url.path.length > 1 && this.url.path[0] === \"\") {\r\n        this.parseError = true;\r\n        this.url.path.shift();\r\n      }\r\n    }\r\n    if (c === 63) {\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    }\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\r\n  if (c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else {\r\n    // TODO: Add: not a URL code point\r\n    if (!isNaN(c) && c !== 37) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (c === 37 &&\r\n        (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n         !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (!isNaN(c)) {\r\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\r\n  if (isNaN(c) || (!this.stateOverride && c === 35)) {\r\n    if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\r\n      this.encodingOverride = \"utf-8\";\r\n    }\r\n\r\n    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||\r\n          buffer[i] === 0x3C || buffer[i] === 0x3E) {\r\n        this.url.query += percentEncode(buffer[i]);\r\n      } else {\r\n        this.url.query += String.fromCodePoint(buffer[i]);\r\n      }\r\n    }\r\n\r\n    this.buffer = \"\";\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\r\n  if (isNaN(c)) { // do nothing\r\n  } else if (c === 0x0) {\r\n    this.parseError = true;\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction serializeURL(url, excludeFragment) {\r\n  let output = url.scheme + \":\";\r\n  if (url.host !== null) {\r\n    output += \"//\";\r\n\r\n    if (url.username !== \"\" || url.password !== \"\") {\r\n      output += url.username;\r\n      if (url.password !== \"\") {\r\n        output += \":\" + url.password;\r\n      }\r\n      output += \"@\";\r\n    }\r\n\r\n    output += serializeHost(url.host);\r\n\r\n    if (url.port !== null) {\r\n      output += \":\" + url.port;\r\n    }\r\n  } else if (url.host === null && url.scheme === \"file\") {\r\n    output += \"//\";\r\n  }\r\n\r\n  if (url.cannotBeABaseURL) {\r\n    output += url.path[0];\r\n  } else {\r\n    for (const string of url.path) {\r\n      output += \"/\" + string;\r\n    }\r\n  }\r\n\r\n  if (url.query !== null) {\r\n    output += \"?\" + url.query;\r\n  }\r\n\r\n  if (!excludeFragment && url.fragment !== null) {\r\n    output += \"#\" + url.fragment;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction serializeOrigin(tuple) {\r\n  let result = tuple.scheme + \"://\";\r\n  result += serializeHost(tuple.host);\r\n\r\n  if (tuple.port !== null) {\r\n    result += \":\" + tuple.port;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.serializeURL = serializeURL;\r\n\r\nmodule.exports.serializeURLOrigin = function (url) {\r\n  // https://url.spec.whatwg.org/#concept-url-origin\r\n  switch (url.scheme) {\r\n    case \"blob\":\r\n      try {\r\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\r\n      } catch (e) {\r\n        // serializing an opaque origin returns \"null\"\r\n        return \"null\";\r\n      }\r\n    case \"ftp\":\r\n    case \"gopher\":\r\n    case \"http\":\r\n    case \"https\":\r\n    case \"ws\":\r\n    case \"wss\":\r\n      return serializeOrigin({\r\n        scheme: url.scheme,\r\n        host: url.host,\r\n        port: url.port\r\n      });\r\n    case \"file\":\r\n      // spec says \"exercise to the reader\", chrome says \"file://\"\r\n      return \"file://\";\r\n    default:\r\n      // serializing an opaque origin returns \"null\"\r\n      return \"null\";\r\n  }\r\n};\r\n\r\nmodule.exports.basicURLParse = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\r\n  if (usm.failure) {\r\n    return \"failure\";\r\n  }\r\n\r\n  return usm.url;\r\n};\r\n\r\nmodule.exports.setTheUsername = function (url, username) {\r\n  url.username = \"\";\r\n  const decoded = punycode.ucs2.decode(username);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.setThePassword = function (url, password) {\r\n  url.password = \"\";\r\n  const decoded = punycode.ucs2.decode(password);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.serializeHost = serializeHost;\r\n\r\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\r\n\r\nmodule.exports.serializeInteger = function (integer) {\r\n  return String(integer);\r\n};\r\n\r\nmodule.exports.parseURL = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  // We don't handle blobs, so this just delegates:\r\n  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });\r\n};\r\n","\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\n\nmodule.exports.wrapperForImpl = function (impl) {\n  return impl[module.exports.wrapperSymbol];\n};\n\nmodule.exports.implForWrapper = function (wrapper) {\n  return wrapper[module.exports.implSymbol];\n};\n\n",null,"module.exports = require(\"assert\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"punycode\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","'use strict';\n\n// eslint-disable-next-line eslint-comments/disable-enable-pair\n/* eslint-disable @typescript-eslint/naming-convention */\nlet LevelResolver = /*#__PURE__*/function (LevelResolver) {\n  LevelResolver[LevelResolver[\"silent\"] = 0] = \"silent\";\n  LevelResolver[LevelResolver[\"error\"] = 1] = \"error\";\n  LevelResolver[LevelResolver[\"warn\"] = 2] = \"warn\";\n  LevelResolver[LevelResolver[\"info\"] = 3] = \"info\";\n  LevelResolver[LevelResolver[\"debug\"] = 4] = \"debug\";\n  return LevelResolver;\n}({});\nconst shouldLog = (currentLevel, level) => LevelResolver[level] <= currentLevel;\n\n/**\n * A Logger using console output.\n *\n * @param logLevel - The logger level name\n * @param prefix - An optional logger message prefix\n * @param output - The output to print logs, using by default the global console object\n *\n * @internal\n */\nclass ConsoleLogger {\n  constructor(logLevel, prefix = '', output = console) {\n    this.logLevel = logLevel;\n    this.prefix = prefix;\n    this.output = output;\n    this.level = LevelResolver[this.logLevel];\n  }\n  makeMethod(method) {\n    return message => {\n      if (shouldLog(this.level, method)) {\n        this.output[method](this.prefix ? `${this.prefix} ${message}` : message);\n      }\n    };\n  }\n  debug = this.makeMethod('debug');\n  error = this.makeMethod('error');\n  info = this.makeMethod('info');\n  warn = this.makeMethod('warn');\n}\n\nlet sdkLogger = /*#__PURE__*/new ConsoleLogger('silent');\n\n/**\n * Sets a logger to be used within the SDK.\n *\n * @param logger - The Logger instance\n *\n * @public\n */\nconst setLogger = logger => {\n  sdkLogger = logger;\n};\n\n/**\n * Sets the logger to console logger with given logLevel (log is disabled by default).\n *\n * @param logLevel - The Log level (default to 'warn')\n * @param prefix - A Log message prefix (default to 'scaleway-sdk-js:')\n *\n * @public\n */\nconst enableConsoleLogger = (logLevel = 'warn', prefix = 'scaleway-sdk-js:') => setLogger(new ConsoleLogger(logLevel, prefix));\n\n/**\n * Returns the active SDK logger.\n *\n * @internal\n */\nconst getLogger = () => sdkLogger;\n\n/**\n * Adds an header to a request through an interceptor.\n *\n * @param key - The header key\n * @param value - The header value\n * @returns The Request interceptor\n *\n * @internal\n */\nconst addHeaderInterceptor = (key, value) => ({\n  request\n}) => {\n  const clone = request.clone();\n  if (value !== undefined) {\n    clone.headers.append(key, value);\n  }\n  return clone;\n};\n\n/**\n * Adds asynchronously an header to a request through an interceptor.\n *\n * @param key - The header key\n * @param value - The header value as a Promise\n * @returns The Request interceptor\n *\n * @internal\n */\nconst addAsyncHeaderInterceptor = (key, getter) => async request => addHeaderInterceptor(key, await getter())(request);\n\nconst isAccessKeyRegex = /^SCW[A-Z0-9]{17}$/i;\nconst isRegionRegex = /^[a-z]{2}-[a-z]{3}$/i;\nconst isUUIDRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\nconst isZoneRegex = /^[a-z]{2}-[a-z]{3}-[1-9]$/i;\n\n/** Returns true if the given string has a valid UUID format. */\nconst isUUID = str => isUUIDRegex.test(str);\n\n/** Returns true if the given string has a valid Scaleway access key format. */\nconst isAccessKey = str => isAccessKeyRegex.test(str);\n\n/** Returns true if the given string has a valid Scaleway secret key format. */\nconst isSecretKey = str => isUUID(str);\n\n/** Returns true if the given string has a valid Scaleway organization ID format. */\nconst isOrganizationId = str => isUUID(str);\n\n/** Returns true if the given string has a valid Scaleway project ID format. */\nconst isProjectId = str => isUUID(str);\n\n/** Returns true if the given string has a valid region format. */\nconst isRegion = str => isRegionRegex.test(str);\n\n/** Returns true if the given string has a valid zone format. */\nconst isZone = str => isZoneRegex.test(str);\n\n/** Returns true if the given string has a valid URL format and starts by `http(s):`. */\nconst isURL = str => {\n  let url;\n  try {\n    url = new URL(str);\n  } catch {\n    return false;\n  }\n  return url.protocol === 'http:' || url.protocol === 'https:';\n};\n\n/**\n * Holds access key and secret key.\n *\n * @public\n */\n\n/**\n * Holds default values of a Scaleway profile.\n *\n * @public\n */\n\n/**\n * Holds values of a Scaleway profile.\n *\n * @public\n */\n\n/**\n * Verifies that the payload contains both the accessKey and the secretKey.\n *\n * @param obj - The secrets\n * @returns Whether the secrets are not empty.\n *\n * @internal\n */\nconst hasAuthenticationSecrets = obj => typeof obj.accessKey === 'string' && obj.accessKey !== '' && typeof obj.secretKey === 'string' && obj.secretKey !== '';\n\n/**\n * Asserts the format of secrets.\n *\n * @param obj - The secrets\n * @returns Whether the secrets use a valid format\n *\n * @throws Error\n * Thrown if either the accessKey or the secretKey has en invalid format.\n *\n * @internal\n */\nfunction assertValidAuthenticationSecrets(obj) {\n  if (!(obj.accessKey && obj.secretKey)) {\n    throw new Error(`Invalid secrets, accessKey & secretKey must be defined. See https://www.scaleway.com/en/docs/console/my-project/how-to/generate-api-key/`);\n  }\n  if (!isAccessKey(obj.accessKey)) {\n    throw new Error(`Invalid access key format '${obj.accessKey}', expected SCWXXXXXXXXXXXXXXXXX format. See https://www.scaleway.com/en/docs/console/my-project/how-to/generate-api-key/`);\n  }\n  if (!isSecretKey(obj.secretKey)) {\n    throw new Error(`Invalid secret key format '${obj.secretKey}', expected a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx. See https://www.scaleway.com/en/docs/console/my-project/how-to/generate-api-key/`);\n  }\n}\n\nconst SESSION_HEADER_KEY = 'x-session-token';\nconst AUTH_HEADER_KEY = 'x-auth-token';\n/**\n * Authenticates with a session token.\n *\n * @param getToken - The token accessor\n * @returns The request interceptor\n *\n * @deprecated Please use addAsyncHeaderInterceptor instead.\n *\n * @internal\n */\nconst authenticateWithSessionToken = getToken => addAsyncHeaderInterceptor(SESSION_HEADER_KEY, getToken);\n\n/**\n * Authenticates with a secrets.\n *\n * @param getToken - The secrets\n * @returns The request interceptor\n *\n * @throws Error\n * Thrown if the secrets are invalid.\n *\n * @internal\n */\nconst authenticateWithSecrets = secrets => {\n  assertValidAuthenticationSecrets(secrets);\n  return addHeaderInterceptor(AUTH_HEADER_KEY, secrets.secretKey);\n};\n\n/**\n * Obfuscates a token.\n *\n * @param key - The token\n * @returns The obfuscated token\n *\n * @internal\n */\nconst obfuscateToken = key => `${key.substring(0, 5)}xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx`;\n\n/**\n * Obfuscates an UUID.\n *\n * @param key - The UUID\n * @returns The obfuscated UUID\n *\n * @internal\n */\nconst obfuscateUUID = key => `${key.substring(0, 8)}-xxxx-xxxx-xxxx-xxxxxxxxxxxx`;\n/**\n * Obfuscates headers entry.\n *\n * @param array - The header entry\n * @returns The obfuscated entry\n *\n * @internal\n */\nconst obfuscateAuthHeadersEntry = ([name, value]) => {\n  if (name === SESSION_HEADER_KEY) return [name, obfuscateToken(value)];\n  if (name === AUTH_HEADER_KEY) return [name, obfuscateUUID(value)];\n  return [name, value];\n};\n\n/**\n * A factory to build {@link Settings}.\n *\n * @public\n */\n\n/**\n * Instantiates the SDK from a configuration {@link Profile}.\n *\n * @param profile - The profile\n * @returns A factory {@link ClientConfig}\n *\n * @remarks This method should be used in conjunction with the initializer `createAdvancedClient`.\n *\n * @public\n */\nconst withProfile = profile => settings => {\n  const newSettings = {\n    ...settings\n  };\n  if (profile.apiURL) {\n    newSettings.apiURL = profile.apiURL;\n  }\n  if (profile.defaultOrganizationId) {\n    newSettings.defaultOrganizationId = profile.defaultOrganizationId;\n  }\n  if (profile.defaultProjectId) {\n    newSettings.defaultProjectId = profile.defaultProjectId;\n  }\n  if (profile.defaultRegion) {\n    newSettings.defaultRegion = profile.defaultRegion;\n  }\n  if (profile.defaultZone) {\n    newSettings.defaultZone = profile.defaultZone;\n  }\n  if (hasAuthenticationSecrets(profile)) {\n    newSettings.interceptors = [{\n      request: authenticateWithSecrets(profile)\n    }, ...newSettings.interceptors];\n  }\n  return newSettings;\n};\n\n/**\n * Instantiates the SDK with a different HTTP client.\n *\n * @param httpClient - A fetch compatible HTTP client\n * @returns A factory {@link ClientConfig}\n *\n * @remarks This method should be used in conjunction with the initializer `createAdvancedClient`.\n *\n * @public\n */\nconst withHTTPClient = httpClient => settings => ({\n  ...settings,\n  httpClient\n});\n\n/**\n * Instantiates the SDK with a default page size.\n *\n * @param defaultPageSize - The default page size\n * @returns A factory {@link ClientConfig}\n *\n * @remarks This method should be used in conjunction with the initializer `createAdvancedClient`.\n *\n * @public\n */\nconst withDefaultPageSize = defaultPageSize => settings => ({\n  ...settings,\n  defaultPageSize\n});\n\n/**\n * Instantiates the SDK with a different default user agent.\n *\n * @param userAgent - The default user agent\n * @returns A factory {@link ClientConfig}\n *\n * @remarks This method should be used in conjunction with the initializer `createAdvancedClient`.\n *\n * @public\n */\nconst withUserAgent = userAgent => settings => ({\n  ...settings,\n  userAgent\n});\n\n/**\n * Instantiates the SDK with an additional user agent.\n *\n * @param userAgent - The suffix to append to default user agent\n * @returns A factory {@link ClientConfig}\n *\n * @remarks This method should be used in conjunction with the initializer `createAdvancedClient`.\n *\n * @public\n */\nconst withUserAgentSuffix = userAgent => settings => ({\n  ...settings,\n  userAgent: settings.userAgent ? `${settings.userAgent} ${userAgent}` : userAgent\n});\n\n/**\n * Instantiates the SDK with additional interceptors.\n *\n * @param interceptors - The additional {@link NetworkInterceptors} interceptors\n * @returns A factory {@link ClientConfig}\n *\n * @remarks\n * It doesn't override the existing interceptors, but instead push more to the list.\n * This method should be used in conjunction with the initializer `createAdvancedClient`.\n *\n * @example\n * ```\n * withAdditionalInterceptors([\n *   {\n *     request: ({ request }) => {\n *       console.log(`Do something with ${JSON.stringify(request)}`)\n *       return request\n *     },\n *     response: ({ response }) => {\n *       console.log(`Do something with ${JSON.stringify(response)}`)\n *       return response\n *     },\n *     responseError: async ({\n *       request,\n *       error,\n *     }: {\n *       request: Request\n *       error: unknown\n *     }) => {\n *       console.log(\n *         `Do something with ${JSON.stringify(request)} and ${JSON.stringify(\n *           error,\n *         )}`,\n *       )\n *       throw error // or return Promise.resolve(someData)\n *     },\n *   },\n * ])\n * ```\n *\n * @public\n */\nconst withAdditionalInterceptors = interceptors => settings => ({\n  ...settings,\n  interceptors: settings.interceptors.concat(interceptors)\n});\n\n/**\n * Instantiates the SDK with legacy interceptors.\n */\n/* eslint-disable deprecation/deprecation */\nconst withLegacyInterceptors = () => settings => {\n  if (!settings.requestInterceptors && !settings.responseInterceptors) {\n    return settings;\n  }\n  const allInterceptors = settings.interceptors.concat((settings.requestInterceptors ?? []).map(obj => ({\n    request: obj\n  })), (settings.responseInterceptors ?? []).map(obj => ({\n    response: obj\n  })));\n  return {\n    ...settings,\n    interceptors: allInterceptors\n  };\n};\n/* eslint-enable deprecation/deprecation */\n\n/**\n * Holds default values of settings.\n *\n * @public\n */\n\n/**\n * Settings hold the values of all client options.\n *\n * @public\n */\n\n/**\n * Validates the content of a {@link Settings} object.\n *\n * @throws Error\n * Thrown if {@link Settings} aren't valid.\n *\n * @internal\n */\nconst assertValidSettings = obj => {\n  // Default Organization ID.\n  if (obj.defaultOrganizationId !== undefined) {\n    if (typeof obj.defaultOrganizationId !== 'string' || obj.defaultOrganizationId.length === 0) {\n      throw new Error('Default organization ID cannot be empty');\n    }\n    if (!isOrganizationId(obj.defaultOrganizationId)) {\n      throw new Error(`Invalid organization ID format '${obj.defaultOrganizationId}', expected a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`);\n    }\n  }\n\n  // Default Project ID.\n  if (obj.defaultProjectId !== undefined) {\n    if (typeof obj.defaultProjectId !== 'string' || obj.defaultProjectId.length === 0) {\n      throw new Error('Default project ID cannot be empty');\n    }\n    if (!isProjectId(obj.defaultProjectId)) {\n      throw new Error(`Invalid project ID format '${obj.defaultProjectId}', expected a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`);\n    }\n  }\n\n  // Default Region.\n  if (obj.defaultRegion && !isRegion(obj.defaultRegion)) {\n    throw new Error(`Invalid default region format '${obj.defaultRegion}'`);\n  }\n\n  // Default Zone.\n  if (obj.defaultZone && !isZone(obj.defaultZone)) {\n    throw new Error(`Invalid default zone format '${obj.defaultZone}'`);\n  }\n\n  // API URL.\n  if (!isURL(obj.apiURL)) {\n    throw new Error(`Invalid URL ${obj.apiURL}`);\n  }\n  if (obj.apiURL.endsWith('/')) {\n    throw new Error(`Invalid URL ${obj.apiURL}: it should not have a trailing slash`);\n  }\n\n  // HTTP Client.\n  if (typeof obj.httpClient !== typeof fetch) {\n    throw new Error(`Invalid HTTP Client`);\n  }\n\n  // Default Page Size.\n  if (obj.defaultPageSize !== undefined && (typeof obj.defaultPageSize !== 'number' || Number.isNaN(obj.defaultPageSize) || obj.defaultPageSize <= 0)) {\n    throw new Error(`Invalid defaultPageSize ${obj.defaultPageSize}: it should be a number above 0`);\n  }\n\n  // User Agent.\n  if (typeof obj.userAgent !== 'string') {\n    throw new Error(`Invalid User-Agent`);\n  }\n};\n\nconst version = 'v1.10.1';\nconst userAgent = `scaleway-sdk-js/${version}`;\n\nconst isBrowser = () => typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n/**\n * Composes request interceptors.\n *\n * @param interceptors - A list of request interceptors\n * @returns An async composed interceptor\n *\n * @internal\n */\nconst composeRequestInterceptors = interceptors => async request => interceptors.reduce(async (asyncResult, interceptor) => interceptor({\n  request: await asyncResult\n}), Promise.resolve(request));\n\n/**\n * Composes response interceptors.\n *\n * @param interceptors - A list of response interceptors\n * @returns An async composed interceptor\n *\n * @internal\n */\nconst composeResponseInterceptors = interceptors => async response => interceptors.reduce(async (asyncResult, interceptor) => interceptor({\n  response: await asyncResult\n}), Promise.resolve(response));\n\n/**\n * Compose response error interceptors.\n *\n * @internal\n */\nconst composeResponseErrorInterceptors = interceptors => async (request, error) => {\n  let prevError = error;\n  for (const interceptor of interceptors) {\n    try {\n      const res = await interceptor({\n        request,\n        error: prevError\n      });\n      return res;\n    } catch (err) {\n      prevError = err;\n    }\n  }\n  throw prevError;\n};\n\n/**\n * Converts a string to PascalCase.\n *\n * @param str - The input string\n * @returns The string in PascalCase\n *\n * @internal\n */\nconst toPascalCase = str => str.replace(/\\w+/g, word => `${word[0].toUpperCase()}${word.slice(1).toLowerCase()}`);\n\n/**\n * Converts a Headers entry to string.\n *\n * @param entry - The header entry as a string tuple\n * @returns A serialized string\n *\n * @internal\n */\nconst serializeHeadersEntry = ([name, value]) => `${toPascalCase(name)}: ${value}`;\n\n/**\n * Converts Headers to safe to log strings (with obfuscated auth secrets).\n *\n * @param headers - The Headers\n * @returns Serialized headers strings\n *\n * @internal\n */\nconst serializeHeaders = headers => Array.from(headers.entries(), serializeHeadersEntry);\n\n/**\n * Dumps a Request into a readable string.\n *\n * @param request - The request\n * @returns The readable string\n *\n * @internal\n */\nconst dumpRequest = async request => [`${request.method.toUpperCase()}: ${request.url}`, ...serializeHeaders(request.headers), await request.clone().text()].join('\\r\\n');\n\n/**\n * Dumps a Response into a readable string.\n *\n * @param response - The response\n * @returns The readable string\n *\n * @internal\n */\nconst dumpResponse = async response => [`HTTP ${response.status} ${response.ok ? 'OK' : 'NOK'}`, ...serializeHeaders(response.headers), await response.clone().text()].join('\\r\\n');\n\n/**\n * Mapper of an header entry.\n *\n * @internal\n */\n\n/**\n * HTTP Request with obfuscated secrets.\n *\n * @internal\n */\nclass ObfuscatedRequest extends Request {\n  constructor(request, obfuscate) {\n    super(request);\n    this.request = request;\n    this.obfuscate = obfuscate;\n  }\n  get headers() {\n    return new Headers(Array.from(this.request.headers, this.obfuscate));\n  }\n  clone() {\n    return new ObfuscatedRequest(this.request, this.obfuscate);\n  }\n}\n\n/**\n * Creates an interceptor to obfuscate the requests.\n *\n * @param obfuscate - The Header entries obfuscator mapper\n * @returns The obfuscated Request\n *\n * @internal\n */\nconst obfuscateInterceptor = obfuscate => ({\n  request\n}) => new ObfuscatedRequest(request, obfuscate);\nconst identity = ({\n  request\n}) => request;\n\n/**\n * Creates an interceptor to log the requests.\n *\n * @param identifier - The request identifier\n * @param obfuscate - The obfuscation interceptor\n * @returns The interceptor\n *\n * @internal\n */\nconst logRequest = (identifier, obfuscate = identity) => async ({\n  request\n}) => {\n  if (shouldLog(LevelResolver[getLogger().logLevel], 'debug')) {\n    getLogger().debug(`--------------- Scaleway SDK REQUEST ${identifier} ---------------\n${await dumpRequest(await obfuscate({\n      request\n    }))}\n---------------------------------------------------------`);\n  }\n  return request;\n};\n\n/**\n * Creates an interceptor to log the responses.\n *\n * @param identifier - The request identifier\n * @returns The interceptor\n *\n * @internal\n */\nconst logResponse = identifier => async ({\n  response\n}) => {\n  if (shouldLog(LevelResolver[getLogger().logLevel], 'debug')) {\n    getLogger().debug(`--------------- Scaleway SDK RESPONSE ${identifier} ---------------\n${await dumpResponse(response)}\n---------------------------------------------------------`);\n  }\n  return response;\n};\n\n/**\n * Validates an object is of type Response without using `instanceof`.\n *\n * @remarks Check issue #509 for more context.\n *\n * @internal\n */\nconst isResponse = obj => obj !== null && obj !== undefined && typeof obj === 'object' && 'status' in obj && typeof obj.status === 'number' && 'statusText' in obj && typeof obj.statusText === 'string' && 'headers' in obj && typeof obj.headers === 'object' && 'body' in obj && typeof obj.body !== 'undefined';\n\n/**\n * Validates an unknown object is a JSON Object.\n *\n * @internal\n */\nconst isJSONObject = obj => {\n  const objT = typeof obj;\n  return obj !== undefined && obj !== null && objT !== 'string' && objT !== 'number' && objT !== 'boolean' && !Array.isArray(obj) && objT === 'object';\n};\n\n/**\n * Verifies the object is a record of string to string[].\n *\n * @param obj - The object\n * @returns Whether the object is of the expected type\n *\n * @internal\n */\nconst isRecordOfStringArray = obj => {\n  if (!isJSONObject(obj)) {\n    return false;\n  }\n  for (const elt of Object.values(obj)) {\n    if (!Array.isArray(elt) || Object.values(elt).find(x => typeof x !== 'string') !== undefined) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Builds the default message for {@link ScalewayError}.\n *\n * @param status - The response code\n * @param body - The response body\n * @returns The error message\n *\n * @internal\n */\nconst buildDefaultMessage = (status, body) => {\n  const message = [`http error ${status}`];\n  if (typeof body === 'string') {\n    message.push(body);\n  } else if (isJSONObject(body)) {\n    if (typeof body.resource === 'string') {\n      message.push(`resource ${body.resource}`);\n    }\n    if (typeof body.message === 'string') {\n      message.push(body.message);\n    }\n    if (body.fields && isRecordOfStringArray(body.fields)) {\n      message.push(Object.entries(body.fields).map(([name, list]) => `${name} (${list.join(', ')})`).join(', '));\n    }\n  }\n  return message.join(': ');\n};\n\n/**\n * Scaleway error.\n *\n * @public\n */\nclass ScalewayError extends Error {\n  /** The message originating from the payload. */\n\n  constructor( /** The response status. */\n  status, /** The response payload. */\n  body, /** The augmented message. */\n  message = buildDefaultMessage(status, body)) {\n    super(message); // 'Error' breaks prototype chain here\n    this.status = status;\n    this.body = body;\n    this.message = message;\n    this.name = 'ScalewayError';\n    this.rawMessage = typeof body === 'object' && typeof body.message === 'string' ? body.message : undefined;\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n  }\n\n  static fromJSON(status, obj) {\n    return new ScalewayError(status, obj);\n  }\n  toString() {\n    return `${this.name}: ${this.message}`;\n  }\n}\n\n/**\n * Details of an {@link InvalidArgumentsError} error.\n *\n * @public\n */\n\n/**\n * Build the default message for {@link InvalidArgumentsError}.\n *\n * @param list - The list of {@link InvalidArgumentsErrorDetails}\n * @returns The error message\n *\n * @internal\n */\nconst buildMessage$5 = list => {\n  const invalidArgs = list.reduce((acc, details) => {\n    let readableReason = '';\n    switch (details.reason) {\n      case 'required':\n        readableReason = `is required`;\n        break;\n      case 'format':\n        readableReason = `is wrongly formatted`;\n        break;\n      case 'constraint':\n        readableReason = `does not respect constraint`;\n        break;\n      default:\n        readableReason = `is invalid for unexpected reason`;\n        break;\n    }\n    if (details.helpMessage && details.helpMessage.length > 0) {\n      readableReason = readableReason.concat(`, `, details.helpMessage);\n    }\n    acc.push(`${details.argumentName} ${readableReason}`);\n    return acc;\n  }, []);\n  return `invalid argument(s): ${invalidArgs.join('; ')}`;\n};\n\n/**\n * InvalidArguments error happens when one or many fields are invalid in the request message.\n *\n * @public\n */\nclass InvalidArgumentsError extends ScalewayError {\n  constructor(status, body, details) {\n    super(status, body, buildMessage$5(details));\n    this.status = status;\n    this.body = body;\n    this.details = details;\n    this.name = 'InvalidArgumentsError';\n  }\n  static fromJSON(status, obj) {\n    if (!Array.isArray(obj.details)) return null;\n    return new InvalidArgumentsError(status, obj, obj.details.reduce((list, detail) => isJSONObject(detail) && typeof detail.argument_name === 'string' && typeof detail.reason === 'string' ? list.concat({\n      argumentName: detail.argument_name,\n      helpMessage: typeof detail.help_message === 'string' ? detail.help_message : undefined,\n      reason: detail.reason\n    }) : list, []));\n  }\n}\n\n/**\n * Scope of an {@link QuotasExceededErrorDetails} error.\n *\n * @public\n */\n\n/**\n * Details of an {@link QuotasExceededError} error.\n *\n * @public\n */\n\n/**\n * Build the default message for {@link QuotasExceededError}.\n *\n * @param list - The list of {@link QuotasExceededErrorDetails}\n * @returns The error message\n *\n * @internal\n */\nconst buildMessage$4 = list => `quota(s) exceeded: ${list.map(details => {\n  const message = `${details.resource} has reached its quota (${details.current}/${details.quota})`;\n  return details.scope ? `${message} for ${details.scope.kind} '${details.scope.id}'` : message;\n}).join('; ')}`;\nconst buildScope = detail => {\n  if (typeof detail.organization_id === 'string' && detail.organization_id.length) {\n    return {\n      id: detail.organization_id,\n      kind: 'organization'\n    };\n  }\n  if (typeof detail.project_id === 'string' && detail.project_id.length) {\n    return {\n      id: detail.project_id,\n      kind: 'project'\n    };\n  }\n  return undefined;\n};\n\n/**\n * QuotasExceeded error happens when one or many resource exceed quotas during the creation of a resource.\n *\n * @public\n */\nclass QuotasExceededError extends ScalewayError {\n  constructor(status, body, list) {\n    super(status, body, buildMessage$4(list));\n    this.status = status;\n    this.body = body;\n    this.list = list;\n    this.name = 'QuotasExceededError';\n  }\n  static fromJSON(status, obj) {\n    if (!Array.isArray(obj.details)) return null;\n    return new QuotasExceededError(status, obj, obj.details.reduce((list, detail) => isJSONObject(detail) && typeof detail.resource === 'string' && typeof detail.quota === 'number' && typeof detail.current === 'number' ? list.concat({\n      current: detail.current,\n      quota: detail.quota,\n      resource: detail.resource,\n      scope: buildScope(detail)\n    }) : list, []));\n  }\n}\n\n/**\n * InvalidRequest error is only returned by the instance API.\n *\n * @public\n */\nclass InvalidRequestMapper {\n  static fromJSON(status, obj) {\n    if (typeof obj.message === 'string' && obj.message.toLowerCase().includes('quota exceeded for this resource')) {\n      return new QuotasExceededError(status, obj, [{\n        current: 0,\n        quota: 0,\n        resource: typeof obj.resource === 'string' ? obj.resource : ''\n      }]);\n    }\n    const fields = obj.fields && isRecordOfStringArray(obj.fields) ? obj.fields : {};\n    const fieldsMessages = Object.entries(fields);\n    if (fieldsMessages.length) {\n      return new InvalidArgumentsError(status, obj, fieldsMessages.map(([argumentName, messages]) => messages.map(helpMessage => ({\n        argumentName,\n        helpMessage,\n        reason: 'constraint'\n      }))).flat());\n    }\n    return new ScalewayError(status, obj);\n  }\n}\n\n/**\n * ResourceNotFound error happens when getting a resource that does not exist anymore.\n *\n * @public\n */\nclass ResourceNotFoundError extends ScalewayError {\n  constructor(status, body, resource, resourceId) {\n    super(status, body, `resource ${resource} with ID ${resourceId} is not found`);\n    this.status = status;\n    this.body = body;\n    this.resource = resource;\n    this.resourceId = resourceId;\n    this.name = 'ResourceNotFoundError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.resource !== 'string' || typeof obj.resource_id !== 'string') {\n      return null;\n    }\n    return new ResourceNotFoundError(status, obj, obj.resource, obj.resource_id);\n  }\n}\n\n/**\n * UnknownResource error is only returned by the instance API.\n *\n * @public\n */\nclass UnknownResourceMapper {\n  static fromJSON(status, obj) {\n    // Split the message\n    // Note: some errors uses ' and not \"\n    // Examples: `\"111...\" not found` or `Security Group '111...' not found`\n    const messageParts = typeof obj.message === 'string' ? obj.message.split(/\"|'/) : [];\n    if (messageParts.length === 3 && isUUID(messageParts[1])) {\n      return new ResourceNotFoundError(status, obj,\n      // transform `Security group ` to `security_group`\n      // `.replaceAll()` may be too recent to use yet.\n      // that's why we're using `.split(' ').join('_')` for now.\n      messageParts[0].trim().toLowerCase().split(' ').join('_'), messageParts[1]);\n    }\n    return new ScalewayError(status, obj);\n  }\n}\n\n/**\n * AlreadyExists error is used when a resource already exists.\n *\n * @public\n */\nclass AlreadyExistsError extends ScalewayError {\n  constructor(status, body, resource, resourceId, helpMessage) {\n    super(status, body, `resource ${resource} with ID ${resourceId} already exists: ${helpMessage}`);\n    this.status = status;\n    this.body = body;\n    this.resource = resource;\n    this.resourceId = resourceId;\n    this.helpMessage = helpMessage;\n    this.name = 'AlreadyExistsError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.resource !== 'string' || typeof obj.resource_id !== 'string' || typeof obj.help_message !== 'string') {\n      return null;\n    }\n    return new AlreadyExistsError(status, obj, obj.resource, obj.resource_id, obj.help_message);\n  }\n}\n\n/**\n * Build the default message for {@link DeniedAuthenticationError}.\n *\n * @param method - The authentication method\n * @param reason - The deny reason\n * @returns The error message\n *\n * @internal\n */\nconst buildMessage$3 = (method, reason) => {\n  let reasonDesc;\n  switch (reason) {\n    case 'invalid_argument':\n      reasonDesc = `invalid ${method} format or empty value`;\n      break;\n    case 'not_found':\n      reasonDesc = `${method} does not exist`;\n      break;\n    case 'expired':\n      reasonDesc = `${method} is expired`;\n      break;\n    default:\n      reasonDesc = `unknown reason for ${method}`;\n  }\n  return `denied authentication: ${reasonDesc}`;\n};\n\n/**\n * DeniedAuthentication error is used by the API Gateway auth service to deny a request.\n *\n * @public\n */\nclass DeniedAuthenticationError extends ScalewayError {\n  constructor(status, body, method, reason) {\n    super(status, body, buildMessage$3(method, reason));\n    this.status = status;\n    this.body = body;\n    this.method = method;\n    this.reason = reason;\n    this.name = 'DeniedAuthenticationError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.method !== 'string' || typeof obj.reason !== 'string') {\n      return null;\n    }\n    return new DeniedAuthenticationError(status, obj, obj.method, obj.reason);\n  }\n}\n\n/**\n * OutOfStock error happens when stocks are empty for the resource.\n *\n * @public\n */\nclass OutOfStockError extends ScalewayError {\n  constructor(status, body, resource) {\n    super(status, body, `resource ${resource} is out of stock`);\n    this.status = status;\n    this.body = body;\n    this.resource = resource;\n    this.name = 'OutOfStockError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.resource !== 'string') return null;\n    return new OutOfStockError(status, obj, obj.resource);\n  }\n}\n\n/**\n * Details of an {@link PermissionsDeniedError} error.\n *\n * @public\n */\n\n/**\n * Build the default message for {@link PermissionsDeniedError}.\n *\n * @param list - The list of {@link PermissionsDeniedErrorDetails}\n * @returns The error message\n *\n * @internal\n */\nconst buildMessage$2 = list => `insufficient permissions: ${list.map(({\n  action,\n  resource\n}) => `${action} ${resource}`).join('; ')}`;\n\n/**\n * PermissionsDenied error happens when one or many permissions are not accorded to the user making the request.\n *\n * @public\n */\nclass PermissionsDeniedError extends ScalewayError {\n  constructor(status, body, list) {\n    super(status, body, buildMessage$2(list));\n    this.status = status;\n    this.body = body;\n    this.list = list;\n    this.name = 'PermissionsDeniedError';\n  }\n  static fromJSON(status, obj) {\n    if (!Array.isArray(obj.details)) return null;\n    return new PermissionsDeniedError(status, obj, obj.details.reduce((list, detail) => isJSONObject(detail) && typeof detail.resource === 'string' && typeof detail.action === 'string' ? list.concat({\n      action: detail.action,\n      resource: detail.resource\n    }) : list, []));\n  }\n}\n\n/**\n * Build the default message for {@link PreconditionFailedError}.\n *\n * @param precondition - The precondition\n * @param helpMessage - The message which should help the user to fix the root cause\n * @returns The error message\n *\n * @internal\n */\nconst buildMessage$1 = (precondition, helpMessage) => {\n  let message = `precondition failed: ${precondition}`;\n  if (typeof helpMessage === 'string' && helpMessage.length > 0) {\n    message = message.concat(', ', helpMessage);\n  }\n  return message;\n};\n\n/**\n * PreconditionFailed error is used when a precondition is not respected.\n *\n * @public\n */\nclass PreconditionFailedError extends ScalewayError {\n  constructor(status, body, precondition, helpMessage) {\n    super(status, body, buildMessage$1(precondition, helpMessage));\n    this.status = status;\n    this.body = body;\n    this.precondition = precondition;\n    this.helpMessage = helpMessage;\n    this.name = 'PreconditionFailedError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.precondition !== 'string' || typeof obj.help_message !== 'string') {\n      return null;\n    }\n    return new PreconditionFailedError(status, obj, obj.precondition, obj.help_message);\n  }\n}\n\n/**\n * ResourceExpired error happens when trying to access a resource that has expired.\n *\n * @public\n */\nclass ResourceExpiredError extends ScalewayError {\n  constructor(status, body, resource, resourceId, expiredSince) {\n    super(status, body, `resource ${resource} with ID ${resourceId} expired since ${expiredSince.toISOString()}`);\n    this.status = status;\n    this.body = body;\n    this.resource = resource;\n    this.resourceId = resourceId;\n    this.expiredSince = expiredSince;\n    this.name = 'ResourceExpiredError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.resource !== 'string' || typeof obj.resource_id !== 'string' || typeof obj.expired_since !== 'string') {\n      return null;\n    }\n    return new ResourceExpiredError(status, obj, obj.resource, obj.resource_id, new Date(obj.expired_since));\n  }\n}\n\n/**\n * ResourceLocked error happens when a resource is locked by trust and safety.\n *\n * @public\n */\nclass ResourceLockedError extends ScalewayError {\n  constructor(status, body, resource, resourceId) {\n    super(status, body, `resource ${resource} with ID ${resourceId} is locked`);\n    this.status = status;\n    this.body = body;\n    this.resource = resource;\n    this.resourceId = resourceId;\n    this.name = 'ResourceLockedError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.resource !== 'string' || typeof obj.resource_id !== 'string') {\n      return null;\n    }\n    return new ResourceLockedError(status, obj, obj.resource, obj.resource_id);\n  }\n}\n\n/**\n * Quota policy of {@link TooManyRequestsError}.\n *\n * @public\n */\n\n/**\n * Build the default message for {@link TooManyRequestsError}.\n *\n * @internal\n */\nconst buildMessage = (helpMessage, limit, resetSeconds, resetAt) => {\n  const details = [];\n  if (limit) {\n    if (limit.windowSeconds) {\n      details.push(`quota is ${limit.quota} for ${limit.windowSeconds}s`);\n    } else {\n      details.push(`quota is ${limit.quota}`);\n    }\n  }\n  if (resetSeconds) {\n    details.push(`resets in ${resetSeconds}s`);\n  } else if (resetAt) {\n    details.push(`resets at ${resetAt.toISOString()}`);\n  }\n  let output = `too many requests`;\n  if (details.length > 0) {\n    output += ` (${details.join(', ')})`;\n  }\n  if (helpMessage.length > 0) {\n    output += `: ${helpMessage}`;\n  }\n  return output;\n};\n\n/**\n * TooManyRequestsError error happens when fetching too many times a resource.\n *\n * @public\n */\nclass TooManyRequestsError extends ScalewayError {\n  constructor(status, body, helpMessage, limit, /** The number of seconds until the quota resets */\n  resetSeconds, /** The timestamp when the quota resets */\n  resetAt) {\n    super(status, body, buildMessage(helpMessage, limit, resetSeconds, resetAt));\n    this.status = status;\n    this.body = body;\n    this.helpMessage = helpMessage;\n    this.limit = limit;\n    this.resetSeconds = resetSeconds;\n    this.resetAt = resetAt;\n    this.name = 'TooManyRequestsError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.help_message !== 'string') return null;\n    let limit;\n    if (isJSONObject(obj.limit) && typeof obj.limit.quota === 'number') {\n      limit = {\n        quota: obj.limit.quota,\n        windowSeconds: typeof obj.limit.window_seconds === 'number' ? obj.limit.window_seconds : undefined\n      };\n    }\n    return new TooManyRequestsError(status, obj, obj.help_message, limit, typeof obj.reset_seconds === 'number' ? obj.reset_seconds : undefined, typeof obj.reset_at === 'string' ? new Date(obj.reset_at) : undefined);\n  }\n}\n\n/**\n * TransientState error happens when trying to perform an action on a resource in a transient state.\n *\n * @public\n */\nclass TransientStateError extends ScalewayError {\n  constructor(status, body, resource, resourceId, currentState) {\n    super(status, body, `resource ${resource} with ID ${resourceId} is in a transient state: ${currentState}`);\n    this.status = status;\n    this.body = body;\n    this.resource = resource;\n    this.resourceId = resourceId;\n    this.currentState = currentState;\n    this.name = 'TransientStateError';\n  }\n  static fromJSON(status, obj) {\n    if (typeof obj.resource !== 'string' || typeof obj.resource_id !== 'string' || typeof obj.current_state !== 'string') {\n      return null;\n    }\n    return new TransientStateError(status, obj, obj.resource, obj.resource_id, obj.current_state);\n  }\n}\n\n/**\n * Unmarshals a standard error from raw body.\n *\n * @param type - The error type\n * @param status - The status code\n * @param body - The error response\n * @returns The standard error if found\n *\n * @internal\n */\nconst unmarshalStandardError = (type, status, body) => {\n  let error;\n  switch (type) {\n    case 'denied_authentication':\n      error = DeniedAuthenticationError;\n      break;\n    case 'invalid_arguments':\n      error = InvalidArgumentsError;\n      break;\n    case 'out_of_stock':\n      error = OutOfStockError;\n      break;\n    case 'permissions_denied':\n      error = PermissionsDeniedError;\n      break;\n    case 'precondition_failed':\n      error = PreconditionFailedError;\n      break;\n    case 'quotas_exceeded':\n      error = QuotasExceededError;\n      break;\n    case 'expired':\n      error = ResourceExpiredError;\n      break;\n    case 'not_found':\n      error = ResourceNotFoundError;\n      break;\n    case 'locked':\n      error = ResourceLockedError;\n      break;\n    case 'transient_state':\n      error = TransientStateError;\n      break;\n    case 'already_exists':\n      error = AlreadyExistsError;\n      break;\n    case 'too_many_requests':\n      error = TooManyRequestsError;\n      break;\n    default:\n      return null;\n  }\n  return error.fromJSON(status, body);\n};\n\n/**\n * Unmarshals a non-standard error from raw body.\n *\n * @param type - The error type\n * @param status - The status code\n * @param body - The error response\n * @returns The non-standard error if found\n *\n * @internal\n */\nconst unmarshalNonStandardError = (type, status, body) => {\n  switch (type) {\n    case 'unknown_resource':\n      return UnknownResourceMapper.fromJSON(status, body);\n    case 'invalid_request_error':\n      return InvalidRequestMapper.fromJSON(status, body);\n    default:\n      return null;\n  }\n};\n\n/**\n * Parses Scaleway error from raw body.\n *\n * @param status - The status code\n * @param body - The error response\n * @returns The resolved error\n *\n * @internal\n */\nconst parseScalewayError = (status, body) => {\n  const parsableError = typeof body.type === 'string' && (unmarshalStandardError(body.type, status, body) ?? unmarshalNonStandardError(body.type, status, body));\n  return parsableError || new ScalewayError(status, body);\n};\n\nconst X_TOTAL_COUNT_HEADER_KEY = 'x-total-count';\nconst TOTAL_COUNT_RES_KEY = 'total_count';\n\n/**\n * Fixes the totalCount property for old APIs.\n *\n * @internal\n */\nconst fixLegacyTotalCount = (obj, headers) => {\n  const headerVal = headers.get(X_TOTAL_COUNT_HEADER_KEY);\n  if (!headerVal) {\n    return obj;\n  }\n  const totalCount = parseInt(headerVal, 10);\n  if (Number.isNaN(totalCount)) {\n    return obj;\n  }\n  if (isJSONObject(obj) && !(TOTAL_COUNT_RES_KEY in obj)) {\n    return Object.assign(obj, {\n      [TOTAL_COUNT_RES_KEY]: totalCount\n    });\n  }\n  return obj;\n};\n\n/**\n * Makes response parser.\n *\n * @param unmarshaller - The response payload unmarshaller\n * @returns An async converter of HTTP Response to desired result\n *\n * @throws {@link ScalewayError}\n * Thrown by the API if the request couldn't be completed.\n *\n * @throws TypeError\n * Thrown if the response parameter isn't of the expected type.\n *\n * @throws Error\n * JSON parsing could trigger an error.\n *\n * @internal\n */\nconst responseParser = (unmarshaller, responseType) => async response => {\n  if (!isResponse(response)) {\n    throw new TypeError('Invalid response object');\n  }\n  if (response.ok) {\n    if (response.status === 204) return unmarshaller(undefined);\n    const contentType = response.headers.get('Content-Type');\n    try {\n      if (responseType === 'json' && contentType === 'application/json') {\n        return unmarshaller(fixLegacyTotalCount(await response.json(), response.headers));\n      }\n      if (responseType === 'blob') {\n        return unmarshaller(await response.blob());\n      }\n      return unmarshaller(await response.text());\n    } catch (err) {\n      throw new ScalewayError(response.status, `could not parse '${contentType ?? ''}' response${err instanceof Error ? `: ${err.message}` : ''}`);\n    }\n  }\n  const error = await response.clone().json().catch(() => response.text());\n  if (isJSONObject(error)) throw parseScalewayError(response.status, error);\n  throw new ScalewayError(response.status, typeof error === 'string' ? error : 'cannot read error response body');\n};\n\n/**\n * Builds Request from {@link ScwRequest} & {@link Settings}.\n *\n * @param request - A scaleway request\n * @param settings - The settings\n * @returns A fetch Request\n *\n * @internal\n */\nconst buildRequest = (request, settings) => {\n  let {\n    path\n  } = request;\n  if (request.urlParams instanceof URLSearchParams) {\n    path = path.concat(`?${request.urlParams.toString()}`);\n  }\n  return new Request(`${settings.apiURL}${path}`, {\n    body: request.body,\n    headers: {\n      Accept: 'application/json',\n      ...( /* istanbul ignore next */!isBrowser() ? {\n        'User-Agent': settings.userAgent\n      } : {}),\n      ...request.headers\n    },\n    method: request.method\n  });\n};\nconst asIs = response => response;\n/**\n * Builds a resource fetcher.\n *\n * @param settings - The {@link Settings} object\n * @param httpClient - The HTTP client that should be used to call the API\n * @returns The fetcher\n *\n * @internal\n */\nconst buildFetcher = (settings, httpClient) => {\n  let requestNumber = 0;\n  const prepareRequest = requestId => composeRequestInterceptors([...settings.interceptors.map(obj => obj.request).filter(obj => obj), logRequest(requestId, obfuscateInterceptor(obfuscateAuthHeadersEntry))]);\n  const prepareResponse = requestId => composeResponseInterceptors([...settings.interceptors.map(obj => obj.response).filter(obj => obj), logResponse(requestId)]);\n  const prepareResponseErrors = () => composeResponseErrorInterceptors(settings.interceptors.map(obj => obj.responseError).filter(obj => obj));\n  return async (request, unwrapper = asIs) => {\n    const requestId = `${requestNumber += 1}`;\n    const reqInterceptors = prepareRequest(requestId);\n    const finalRequest = await reqInterceptors(buildRequest(request, settings));\n    try {\n      const response = await httpClient(finalRequest);\n      const resInterceptors = prepareResponse(requestId);\n      const finalResponse = await resInterceptors(response);\n      const resUnmarshaller = responseParser(unwrapper, request.responseType ?? 'json');\n      const unmarshaledResponse = await resUnmarshaller(finalResponse);\n      return unmarshaledResponse;\n    } catch (err) {\n      const resErrorInterceptors = prepareResponseErrors();\n      const handledError = await resErrorInterceptors(finalRequest, err);\n      return unwrapper(handledError);\n    }\n  };\n};\n\n/** Default {@link Settings} values. */\nconst DEFAULT_SETTINGS = {\n  apiURL: 'https://api.scaleway.com',\n  httpClient: fetch,\n  interceptors: [],\n  userAgent\n};\n\n/**\n * Scaleway client.\n */\n\n/**\n * Creates a Scaleway client with advanced options.\n * You can either use existing factories\n * (like `withProfile`, `withUserAgentSuffix`, etc)\n * or write your own using the interface `ClientConfig`.\n *\n * @example\n * Creates a client with factories:\n * ```\n * createAdvancedClient(\n *   (obj: Settings) => ({\n *     ...obj,\n *     defaultPageSize: 100 ,\n *     httpClient: myFetchWrapper,\n *   }),\n *   withUserAgentSuffix('bot-name/1.0'),\n * )\n * ```\n *\n * @throws Error\n * Thrown if the setup fails.\n *\n * @public\n */\nconst createAdvancedClient = (...configs) => {\n  const settings = configs.concat([withLegacyInterceptors()]).reduce((currentSettings, config) => config(currentSettings), DEFAULT_SETTINGS);\n  assertValidSettings(settings);\n  getLogger().info(`init Scaleway SDK version ${version}`);\n  return {\n    fetch: buildFetcher(settings, settings.httpClient),\n    settings\n  };\n};\n\n/**\n * Creates a Scaleway client with a profile.\n *\n * @example\n * Creates a client with credentials & default values (see https://www.scaleway.com/en/docs/console/my-project/how-to/generate-api-key/):\n * ```\n * import { createClient } from '@scaleway/sdk'\n *\n * createClient({\n *   accessKey: 'SCWXXXXXXXXXXXXXXXXX',\n *   secretKey: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',\n *   defaultProjectId: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',\n *   defaultRegion: 'fr-par',\n *   defaultZone: 'fr-par-1',\n * })\n * ```\n *\n * @example\n * Creates a client by loading values from the environment (see https://www.scaleway.com/en/docs/console/my-project/how-to/generate-api-key/#how-to-use-your-api-key)\n * or the config file created by CLI `scw init` (see https://www.scaleway.com/en/cli/):\n * ```\n * import { loadProfileFromConfigurationFile } from '@scaleway/configuration-loader'\n * import { createClient } from '@scaleway/sdk'\n *\n * createClient({\n *   ...await loadProfileFromConfigurationFile(),\n *   defaultZone: 'fr-par-3',\n * })\n * ```\n *\n * @throws Error\n * Thrown if the setup fails.\n *\n * @public\n */\nconst createClient = (profile = {}) => createAdvancedClient(withProfile(profile));\n\nvar index$t = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AlreadyExistsError: AlreadyExistsError,\n  DeniedAuthenticationError: DeniedAuthenticationError,\n  InvalidArgumentsError: InvalidArgumentsError,\n  OutOfStockError: OutOfStockError,\n  PermissionsDeniedError: PermissionsDeniedError,\n  PreconditionFailedError: PreconditionFailedError,\n  QuotasExceededError: QuotasExceededError,\n  ResourceExpiredError: ResourceExpiredError,\n  ResourceLockedError: ResourceLockedError,\n  ResourceNotFoundError: ResourceNotFoundError,\n  ScalewayError: ScalewayError,\n  TooManyRequestsError: TooManyRequestsError,\n  TransientStateError: TransientStateError\n});\n\n/**\n * Sleep for a specified number of time.\n *\n * @param ms - The number of milliseconds\n * @returns The sleep promise\n *\n * @internal\n */\nconst sleep = ms => new Promise(resolve => {\n  setTimeout(resolve, ms);\n});\n\nconst DEFAULT_TIMEOUT_SECONDS = 300;\nconst DEFAULT_MIN_DELAY_SECONDS = 1;\nconst DEFAULT_MAX_DELAY_SECONDS = 30;\n\n/**\n * Creates an exponential backoff interval strategy.\n *\n * @param minDelay - The minimum delay before the next try in seconds\n * @param maxDelay - The maximum delay before the next try in seconds\n * @returns An exponential backoff generator\n *\n * @internal\n */\nfunction* createExponentialBackoffStrategy(minDelay, maxDelay) {\n  if (minDelay < 1 || maxDelay < 1 || minDelay > maxDelay) {\n    throw new Error('Waiter: minDelay must be >= 1 and maxDelay must be >= minDelay');\n  }\n  let attempt = 1;\n  const ceiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n  const randomInRange = (min, max) => min + Math.random() * (max - min);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while (true) {\n    if (attempt > ceiling) {\n      yield maxDelay;\n    } else {\n      yield randomInRange(minDelay, minDelay * 2 ** (attempt - 1));\n    }\n    attempt += 1;\n  }\n}\n\n/**\n * Tries a specific logic several times until it succeeds, timeouts, or throws an exception.\n *\n * @param retry - The function to retry logic between each interval\n * @param strategy - A generated interval strategy iterator\n * @param timeout - The maximum time elapsed before timeout error\n *\n * @throws An timeout exception or error thrown by the logic being run\n *\n * @internal\n */\nconst tryAtIntervals = async (retry, strategy, timeout = DEFAULT_TIMEOUT_SECONDS) => {\n  const timeoutTimestamp = Date.now() + timeout * 1000;\n  let retryCount = 0;\n  while (Date.now() <= timeoutTimestamp) {\n    const delay = strategy.next(retryCount += 1).value * 1000;\n    // Break if timeout has been reached\n    if (timeoutTimestamp <= Date.now() + delay) break;\n    // Wait before the next retry\n    await sleep(delay);\n    // Retry\n    const {\n      value,\n      done\n    } = await retry();\n    if (done) return value;\n  }\n  throw new Error(`Timeout after ${timeout}s`);\n};\n\n/**\n * Represents the condition to stop waiting for a resource.\n *\n * @public\n */\n\n/**\n * The options to wait until a resource is ready.\n *\n * @public\n */\n\n/**\n * Fetches resource several times until an expected condition is reached, timeouts, or throws an exception.\n *\n * @param stop - The condition to stop waiting\n * @param fetcher - The method to retrieve resource\n * @param request - The resource request options\n * @param options - The retry strategy options\n * @param strategy - An optional custom strategy\n *\n * @returns A promise of resource\n *\n * @public\n */\nconst waitForResource = (stop, fetcher, request, options, strategy = createExponentialBackoffStrategy(options?.minDelay ?? DEFAULT_MIN_DELAY_SECONDS, options?.maxDelay ?? DEFAULT_MAX_DELAY_SECONDS)) => tryAtIntervals(async () => {\n  const value = await fetcher(request);\n  return {\n    done: await stop(value),\n    value\n  };\n}, strategy, options?.timeout);\n\n/**\n * Abstract class to instantiate API from a {@link Client}.\n *\n * @internal\n */\nlet API$q = class API {\n  constructor(client) {\n    this.client = client;\n  }\n};\n\n/**\n * Returns the parameter if it's valid as path parameter\n * (string and not empty, or number), else throws an exception.\n *\n * @param name - The parameter name\n * @param param - The parameter value\n * @returns The parameter value\n *\n * @throws TypeError\n * Thrown if the parameter is invalid.\n *\n * @internal\n */\nfunction validatePathParam(name, param) {\n  if (typeof param === 'string' && param.length > 0) return param;\n  if (typeof param === 'number') return param.toString();\n  throw new TypeError(`param ${name} cannot be empty in request`);\n}\n\n/**\n * Resolves the ideal parameter and value amongst an optional list.\n *\n * @param list - The list to be looking into\n * @param isRequired - If at least one \"one-of\" should be found, false by default\n * @returns The parameter and value\n *\n * @throws TypeError\n * Thrown if isRequired is true, and no value or default value is specified.\n *\n * @internal\n */\nconst resolveOneOf = (list, isRequired = false) => {\n  const elt = list.find(obj => obj.value) || list.find(obj => obj.default);\n  const value = elt?.value || elt?.default;\n  if (value) return {\n    [elt.param]: value\n  };\n  if (isRequired) {\n    const keyList = list.map(obj => obj.param).join(' or ');\n    throw new TypeError(`one of ${keyList} must be indicated in the request`);\n  }\n  return {};\n};\n/**\n * Filters defined parameters tuples and converts them to URLSearchParams.\n *\n * @param paramTuples - The key/value pairs\n * @returns URLSearchParams\n *\n * @internal\n */\nconst urlParams = (...paramTuples) => {\n  const params = new URLSearchParams();\n  for (const [key, value] of paramTuples) {\n    if (typeof key === 'string' && value != null) {\n      if (Array.isArray(value)) {\n        for (const innerValue of value) {\n          if (innerValue !== null) {\n            params.append(key, innerValue instanceof Date ? innerValue.toISOString() : innerValue.toString());\n          }\n        }\n      } else {\n        params.append(key, value instanceof Date ? value.toISOString() : value.toString());\n      }\n    }\n  }\n  return params;\n};\n\n/**\n * Unmarshals data to Date object.\n *\n * @internal\n */\nconst unmarshalDate = data => {\n  if (typeof data !== 'string') {\n    return undefined;\n  }\n  const date = new Date(data);\n  if (Number.isNaN(date.getTime())) {\n    return undefined;\n  }\n  return date;\n};\n\n/**\n * Unmarshals array of object.\n *\n * @internal\n */\nconst unmarshalArrayOfObject = (data, unmarshaller, emptyFallback = true) => {\n  if (!Array.isArray(data)) {\n    return emptyFallback ? [] : undefined;\n  }\n  return data.map(elt => unmarshaller(elt));\n};\n\n/**\n * Unmarshals map of object.\n *\n * @internal\n */\nconst unmarshalMapOfObject = (data, unmarshaller, emptyFallback = true) => {\n  if (!data || typeof data !== 'object' || !(data instanceof Object) || Array.isArray(data)) {\n    return emptyFallback ? {} : undefined;\n  }\n  return Object.entries(data).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: unmarshaller(value)\n  }), {});\n};\n\n/**\n * Unmarshals {@link Money}\n *\n * @internal\n */\nconst unmarshalMoney = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Money' failed as data isn't a dictionary.`);\n  }\n  return {\n    currencyCode: data.currency_code,\n    nanos: data.nanos,\n    units: data.units\n  };\n};\n\n/**\n * Unmarshals {@link ServiceInfo}.\n *\n * @internal\n */\nconst unmarshalServiceInfo = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServiceInfo' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    documentationUrl: data.documentation_url,\n    name: data.name,\n    version: data.version\n  };\n};\n\n/**\n * Unmarshals {@link ScwFile}.\n *\n * @internal\n */\nconst unmarshalScwFile = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ScwFile' failed as data isn't a dictionary.`);\n  }\n  return {\n    content: data.content,\n    contentType: data.content_type,\n    name: data.name\n  };\n};\n\n/**\n * Unmarshals {@link TimeSeriesPoint}\n *\n * @remarks To optimize the size of this message,\n * the JSON is compressed in an array instead of a dictionary.\n * Example: `[\"2019-08-08T15:00:00Z\", 0.2]`.\n *\n * @internal\n */\nconst unmarshalTimeSeriesPoint = data => {\n  if (!Array.isArray(data)) {\n    throw new TypeError(`Unmarshalling the type 'TimeSeriesPoint' failed as data isn't an array.`);\n  }\n  return {\n    timestamp: unmarshalDate(data[0]),\n    value: data[1]\n  };\n};\n\n/**\n * Unmarshals {@link TimeSeries}\n *\n * @internal\n */\nconst unmarshalTimeSeries = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'TimeSeries' failed as data isn't a dictionary.`);\n  }\n  return {\n    metadata: data.metadata,\n    name: data.name,\n    points: unmarshalArrayOfObject(data.points, unmarshalTimeSeriesPoint)\n  };\n};\n\n/**\n * Marshals {@link ScwFile}.\n *\n * @internal\n */\nconst marshalScwFile = obj => ({\n  content: obj.content,\n  content_type: obj.contentType,\n  name: obj.name\n});\n\n/**\n * Marshals {@link Money}\n *\n * @internal\n */\nconst marshalMoney = obj => ({\n  currency_code: obj.currencyCode,\n  nanos: obj.nanos,\n  units: obj.units\n});\n\n/**\n * Marshals {@link TimeSeriesPoint}\n *\n * @internal\n */\nconst marshalTimeSeriesPoint = obj => ({\n  timestamp: obj.timestamp?.toISOString(),\n  value: obj.value\n});\n\n/**\n * Marshals {@link TimeSeries}\n *\n * @internal\n */\nconst marshalTimeSeries = obj => ({\n  metadata: obj.metadata,\n  name: obj.name,\n  points: obj.points.map(elt => marshalTimeSeriesPoint(elt))\n});\n\nconst extract = key => result => result[key];\nfunction* pages(key, fetcher, request, firstPage) {\n  if (!Array.isArray(firstPage[key])) {\n    throw new Error(`Property ${key} is not a list in paginated result`);\n  }\n  const getList = extract(key);\n  let page = request.page || 1;\n  if (page === 1) {\n    yield Promise.resolve(getList(firstPage));\n    page += 1;\n  }\n  const {\n    length\n  } = firstPage[key];\n  if (!length) return;\n  const {\n    totalCount\n  } = firstPage;\n  while (page <= Math.floor((totalCount + length - 1) / length)) {\n    yield fetcher({\n      ...request,\n      page\n    }).then(getList);\n    page += 1;\n  }\n}\n\n/**\n * Fetches a paginated resource.\n *\n * @param key - The resource key of values list\n * @param fetcher - The method to retrieve paginated resources\n * @param request - A request with pagination options\n * @param initial - The first page\n * @returns An async generator of resources arrays\n */\nasync function* fetchPaginated(key, fetcher, request, initial = fetcher(request)) {\n  yield* pages(key, fetcher, request, await initial);\n}\n\n/**\n * Fetches all paginated resource.\n *\n * @param key - The resource key of values list\n * @param fetcher - The method to retrieve paginated resources\n * @param request - A request with pagination options\n * @param initial - The first page\n * @returns A resources array Promise\n */\nconst fetchAll = async (key, fetcher, request, initial = fetcher(request)) => (await Promise.all(Array.from(pages(key, fetcher, request, await initial)))).flat();\n\n/**\n * Enriches a listing method with helpers.\n *\n * @param key - The resource key of values list\n * @param fetcher - The method to retrieve paginated resources\n * @param request - A request with pagination options\n * @returns A resource Promise with the pagination helpers\n *\n * @internal\n */\nconst enrichForPagination = (key, fetcher, request) => {\n  const firstPage = fetcher(request);\n  return Object.assign(firstPage, {\n    all: () => fetchAll(key, fetcher, request, firstPage),\n    [Symbol.asyncIterator]: () => fetchPaginated(key, fetcher, request, firstPage)\n  });\n};\n\nconst ADJECTIVES = ['admiring', 'adoring', 'affectionate', 'agitated', 'amazing', 'angry', 'awesome', 'beautiful', 'blissful', 'bold', 'boring', 'brave', 'busy', 'charming', 'clever', 'cool', 'compassionate', 'competent', 'condescending', 'confident', 'cranky', 'crazy', 'dazzling', 'determined', 'distracted', 'dreamy', 'eager', 'ecstatic', 'elastic', 'elated', 'elegant', 'eloquent', 'epic', 'exciting', 'fervent', 'festive', 'flamboyant', 'focused', 'friendly', 'frosty', 'funny', 'gallant', 'gifted', 'goofy', 'gracious', 'great', 'happy', 'hardcore', 'heuristic', 'hopeful', 'hungry', 'infallible', 'inspiring', 'interesting', 'intelligent', 'jolly', 'jovial', 'keen', 'kind', 'laughing', 'loving', 'lucid', 'magical', 'mystifying', 'modest', 'musing', 'naughty', 'nervous', 'nice', 'nifty', 'nostalgic', 'objective', 'optimistic', 'peaceful', 'pedantic', 'pensive', 'practical', 'priceless', 'quirky', 'quizzical', 'recursing', 'relaxed', 'reverent', 'romantic', 'sad', 'serene', 'sharp', 'silly', 'sleepy', 'stoic', 'strange', 'stupefied', 'suspicious', 'sweet', 'tender', 'thirsty', 'trusting', 'unruffled', 'upbeat', 'vibrant', 'vigilant', 'vigorous', 'wizardly', 'wonderful', 'xenodochial', 'youthful', 'zealous', 'zen'];\nconst NAMES = ['albattani', 'allen', 'almeida', 'antonelli', 'agnesi', 'archimedes', 'ardinghelli', 'aryabhata', 'austin', 'babbage', 'banach', 'banzai', 'bardeen', 'bartik', 'bassi', 'beaver', 'bell', 'benz', 'bhabha', 'bhaskara', 'black', 'blackburn', 'blackwell', 'bohr', 'booth', 'borg', 'bose', 'bouman', 'boyd', 'brahmagupta', 'brattain', 'brown', 'buck', 'burnell', 'cannon', 'carson', 'cartwright', 'carver', 'cerf', 'chandrasekhar', 'chaplygin', 'chatelet', 'chatterjee', 'chebyshev', 'cohen', 'chaum', 'clarke', 'colden', 'cori', 'cray', 'curran', 'curie', 'darwin', 'davinci', 'dewdney', 'dhawan', 'diffie', 'dijkstra', 'dirac', 'driscoll', 'dubinsky', 'easley', 'edison', 'einstein', 'elbakyan', 'elgamal', 'elion', 'ellis', 'engelbart', 'euclid', 'euler', 'faraday', 'feistel', 'fermat', 'fermi', 'feynman', 'franklin', 'gagarin', 'galileo', 'galois', 'ganguly', 'gates', 'gauss', 'germain', 'goldberg', 'goldstine', 'goldwasser', 'golick', 'goodall', 'gould', 'greider', 'grothendieck', 'haibt', 'hamilton', 'haslett', 'hawking', 'hellman', 'heisenberg', 'hermann', 'herschel', 'hertz', 'heyrovsky', 'hodgkin', 'hofstadter', 'hoover', 'hopper', 'hugle', 'hypatia', 'ishizaka', 'jackson', 'jang', 'jemison', 'jennings', 'jepsen', 'johnson', 'joliot', 'jones', 'kalam', 'kapitsa', 'kare', 'keldysh', 'keller', 'kepler', 'khayyam', 'khorana', 'kilby', 'kirch', 'knuth', 'kowalevski', 'lalande', 'lamarr', 'lamport', 'leakey', 'leavitt', 'lederberg', 'lehmann', 'lewin', 'lichterman', 'liskov', 'lovelace', 'lumiere', 'mahavira', 'margulis', 'matsumoto', 'maxwell', 'mayer', 'mccarthy', 'mcclintock', 'mclaren', 'mclean', 'mcnulty', 'mendel', 'mendeleev', 'meitner', 'meninsky', 'merkle', 'mestorf', 'mirzakhani', 'montalcini', 'moore', 'morse', 'murdock', 'moser', 'napier', 'nash', 'neumann', 'newton', 'nightingale', 'nobel', 'noether', 'northcutt', 'noyce', 'panini', 'pare', 'pascal', 'pasteur', 'payne', 'perlman', 'pike', 'poincare', 'poitras', 'proskuriakova', 'ptolemy', 'raman', 'ramanujan', 'ride', 'ritchie', 'rhodes', 'robinson', 'roentgen', 'rosalind', 'rubin', 'saha', 'sammet', 'sanderson', 'satoshi', 'shamir', 'shannon', 'shaw', 'shirley', 'shockley', 'shtern', 'sinoussi', 'snyder', 'solomon', 'spence', 'stonebraker', 'sutherland', 'swanson', 'swartz', 'swirles', 'taussig', 'tereshkova', 'tesla', 'tharp', 'thompson', 'torvalds', 'tu', 'turing', 'varahamihira', 'vaughan', 'visvesvaraya', 'volhard', 'villani', 'wescoff', 'wilbur', 'wiles', 'williams', 'williamson', 'wilson', 'wing', 'wozniak', 'wright', 'wu', 'yalow', 'yonath', 'zhukovsky'];\nconst randomName = function () {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n  const name = `${ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)] ?? ''}${separator}${NAMES[Math.floor(Math.random() * NAMES.length)] ?? ''}`;\n  if (name === `boring${separator}wozniak`) {\n    return randomName(prefix, separator);\n  }\n  return prefix.length > 0 ? `${prefix}${separator}${name}` : name;\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalProject = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Project' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    id: data.id,\n    name: data.name,\n    organizationId: data.organization_id,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalListProjectsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListProjectsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    projects: unmarshalArrayOfObject(data.projects, unmarshalProject),\n    totalCount: data.total_count\n  };\n};\nconst marshalCreateProjectRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name || randomName('proj'),\n  organization_id: request.organizationId ?? defaults.defaultOrganizationId\n});\nconst marshalUpdateProjectRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$m = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Account API.\n *\n * User related data. This API allows you to manage projects.\n */\nlet API$p = class API extends API$q {\n  /**\n   * Create a new Project for an Organization. Generate a new Project for an\n   * Organization, specifying its configuration including name and description.\n   *\n   * @param request - The request {@link CreateProjectRequest}\n   * @returns A Promise of Project\n   */\n  createProject = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateProjectRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$m,\n    method: 'POST',\n    path: `/account/v2/projects`\n  }, unmarshalProject);\n  pageOfListProjects = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/account/v2/projects`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_ids', request.projectIds])\n  }, unmarshalListProjectsResponse);\n\n  /**\n   * List all Projects of an Organization. List all Projects of an Organization.\n   * The response will include the total number of Projects as well as their\n   * associated Organizations, names and IDs. Other information include the\n   * creation and update date of the Project.\n   *\n   * @param request - The request {@link ListProjectsRequest}\n   * @returns A Promise of ListProjectsResponse\n   */\n  listProjects = (request = {}) => enrichForPagination('projects', this.pageOfListProjects, request);\n\n  /**\n   * Get an existing Project. Retrieve information about an existing Project,\n   * specified by its Project ID. Its full details, including ID, name and\n   * description, are returned in the response object.\n   *\n   * @param request - The request {@link GetProjectRequest}\n   * @returns A Promise of Project\n   */\n  getProject = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/account/v2/projects/${validatePathParam('projectId', request.projectId ?? this.client.settings.defaultProjectId)}`\n  }, unmarshalProject);\n\n  /**\n   * Delete an existing Project. Delete an existing Project, specified by its\n   * Project ID. The Project needs to be empty (meaning there are no resources\n   * left in it) to be deleted effectively. Note that deleting a Project is\n   * permanent, and cannot be undone.\n   *\n   * @param request - The request {@link DeleteProjectRequest}\n   */\n  deleteProject = (request = {}) => this.client.fetch({\n    method: 'DELETE',\n    path: `/account/v2/projects/${validatePathParam('projectId', request.projectId ?? this.client.settings.defaultProjectId)}`\n  });\n\n  /**\n   * Update Project. Update the parameters of an existing Project, specified by\n   * its Project ID. These parameters include the name and description.\n   *\n   * @param request - The request {@link UpdateProjectRequest}\n   * @returns A Promise of Project\n   */\n  updateProject = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalUpdateProjectRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$m,\n    method: 'PATCH',\n    path: `/account/v2/projects/${validatePathParam('projectId', request.projectId ?? this.client.settings.defaultProjectId)}`\n  }, unmarshalProject);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$l = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$p\n});\n\nvar index$s = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v2: index_gen$l\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link ServerStatus}. */\nconst SERVER_TRANSIENT_STATUSES$2 = ['starting', 'rebooting', 'updating', 'locking', 'unlocking', 'reinstalling'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalServerTypeCPU = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeCPU' failed as data isn't a dictionary.`);\n  }\n  return {\n    coreCount: data.core_count,\n    name: data.name\n  };\n};\nconst unmarshalServerTypeDisk = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeDisk' failed as data isn't a dictionary.`);\n  }\n  return {\n    capacity: data.capacity,\n    type: data.type\n  };\n};\nconst unmarshalServerTypeMemory = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeMemory' failed as data isn't a dictionary.`);\n  }\n  return {\n    capacity: data.capacity,\n    type: data.type\n  };\n};\nconst unmarshalOS$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'OS' failed as data isn't a dictionary.`);\n  }\n  return {\n    compatibleServerTypes: data.compatible_server_types,\n    id: data.id,\n    imageUrl: data.image_url,\n    label: data.label,\n    name: data.name\n  };\n};\nconst unmarshalServer$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Server' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    deletableAt: unmarshalDate(data.deletable_at),\n    id: data.id,\n    ip: data.ip,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    status: data.status,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at),\n    vncUrl: data.vnc_url,\n    zone: data.zone\n  };\n};\nconst unmarshalServerType$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerType' failed as data isn't a dictionary.`);\n  }\n  return {\n    cpu: data.cpu ? unmarshalServerTypeCPU(data.cpu) : undefined,\n    disk: data.disk ? unmarshalServerTypeDisk(data.disk) : undefined,\n    memory: data.memory ? unmarshalServerTypeMemory(data.memory) : undefined,\n    minimumLeaseDuration: data.minimum_lease_duration,\n    name: data.name,\n    stock: data.stock\n  };\n};\nconst unmarshalListOSResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListOSResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    os: unmarshalArrayOfObject(data.os, unmarshalOS$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListServerTypesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServerTypesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    serverTypes: unmarshalArrayOfObject(data.server_types, unmarshalServerType$1)\n  };\n};\nconst unmarshalListServersResponse$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalArrayOfObject(data.servers, unmarshalServer$2),\n    totalCount: data.total_count\n  };\n};\nconst marshalCreateServerRequest$2 = (request, defaults) => ({\n  name: request.name || randomName('as'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  type: request.type\n});\nconst marshalUpdateServerRequest$2 = (request, defaults) => ({\n  name: request.name\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$l = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Apple silicon API.\n *\n * Apple Mac mini as a service. Scaleway Apple silicon as-a-Service is built\n * using the latest generation of Apple Mac mini hardware (fifth generation).\n *\n * These dedicated Mac mini M1s are designed for developing, building, testing,\n * and signing applications for Apple devices, including iPhones, iPads, Mac\n * computers and much more.\n *\n * Get set to explore, learn and build on a dedicated Mac mini M1 with more\n * performance and speed than you ever thought possible.\n *\n * _Apple silicon as a Service comes with a minimum allocation period of 24\n * hours_*.\n *\n * Mac mini and macOS are trademarks of Apple Inc., registered in the U.S. and\n * other countries and regions. IOS is a trademark or registered trademark of\n * Cisco in the U.S. and other countries and is used by Apple under license.\n * Scaleway is not affiliated with Apple Inc.\n */\nlet API$o = class API extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-3'];\n\n  /**\n   * List server types. List all technical details about Apple silicon server\n   * types available in the specified zone. Since there is only one Availability\n   * Zone for Apple silicon servers, the targeted value is `fr-par-3`.\n   *\n   * @param request - The request {@link ListServerTypesRequest}\n   * @returns A Promise of ListServerTypesResponse\n   */\n  listServerTypes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/server-types`\n  }, unmarshalListServerTypesResponse);\n\n  /**\n   * Get a server type. Get technical details (CPU, disk size etc.) of a server\n   * type.\n   *\n   * @param request - The request {@link GetServerTypeRequest}\n   * @returns A Promise of ServerType\n   */\n  getServerType = request => this.client.fetch({\n    method: 'GET',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/server-type/${validatePathParam('serverType', request.serverType)}`\n  }, unmarshalServerType$1);\n\n  /**\n   * Create a server. Create a new server in the targeted zone, specifying its\n   * configuration including name and type.\n   *\n   * @param request - The request {@link CreateServerRequest}\n   * @returns A Promise of Server\n   */\n  createServer = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateServerRequest$2(request, this.client.settings)),\n    headers: jsonContentHeaders$l,\n    method: 'POST',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers`\n  }, unmarshalServer$2);\n  pageOfListServers = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListServersResponse$2);\n\n  /**\n   * List all servers. List all servers in the specified zone. By default,\n   * returned servers in the list are ordered by creation date in ascending\n   * order, though this can be modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListServersRequest}\n   * @returns A Promise of ListServersResponse\n   */\n  listServers = (request = {}) => enrichForPagination('servers', this.pageOfListServers, request);\n  pageOfListOS = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/os`,\n    urlParams: urlParams(['name', request.name], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['server_type', request.serverType])\n  }, unmarshalListOSResponse$1);\n\n  /**\n   * List all Operating Systems (OS). List all Operating Systems (OS). The\n   * response will include the total number of OS as well as their associated\n   * IDs, names and labels.\n   *\n   * @param request - The request {@link ListOSRequest}\n   * @returns A Promise of ListOSResponse\n   */\n  listOS = (request = {}) => enrichForPagination('os', this.pageOfListOS, request);\n\n  /**\n   * Get an Operating System (OS). Get an Operating System (OS). The response\n   * will include the OS's unique ID as well as its name and label.\n   *\n   * @param request - The request {@link GetOSRequest}\n   * @returns A Promise of OS\n   */\n  getOS = request => this.client.fetch({\n    method: 'GET',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/os/${validatePathParam('osId', request.osId)}`\n  }, unmarshalOS$1);\n\n  /**\n   * Get a server. Retrieve information about an existing Apple silicon server,\n   * specified by its server ID. Its full details, including name, status and IP\n   * address, are returned in the response object.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @returns A Promise of Server\n   */\n  getServer = request => this.client.fetch({\n    method: 'GET',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  }, unmarshalServer$2);\n\n  /**\n   * Waits for {@link Server} to be in a final state.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Server\n   */\n  waitForServer = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!SERVER_TRANSIENT_STATUSES$2.includes(res.status))), this.getServer, request, options);\n\n  /**\n   * Update a server. Update the parameters of an existing Apple silicon server,\n   * specified by its server ID.\n   *\n   * @param request - The request {@link UpdateServerRequest}\n   * @returns A Promise of Server\n   */\n  updateServer = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateServerRequest$2(request, this.client.settings)),\n    headers: jsonContentHeaders$l,\n    method: 'PATCH',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  }, unmarshalServer$2);\n\n  /**\n   * Delete a server. Delete an existing Apple silicon server, specified by its\n   * server ID. Deleting a server is permanent, and cannot be undone. Note that\n   * the minimum allocation period for Apple silicon-as-a-service is 24 hours,\n   * meaning you cannot delete your server prior to that.\n   *\n   * @param request - The request {@link DeleteServerRequest}\n   */\n  deleteServer = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  });\n\n  /**\n   * Reboot a server. Reboot an existing Apple silicon server, specified by its\n   * server ID.\n   *\n   * @param request - The request {@link RebootServerRequest}\n   * @returns A Promise of Server\n   */\n  rebootServer = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$l,\n    method: 'POST',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/reboot`\n  }, unmarshalServer$2);\n\n  /**\n   * Reinstall a server. Reinstall an existing Apple silicon server (specified\n   * by its server ID) from a new image (OS). All the data on the disk is\n   * deleted and all configuration is reset to the defailt configuration values\n   * of the image (OS).\n   *\n   * @param request - The request {@link ReinstallServerRequest}\n   * @returns A Promise of Server\n   */\n  reinstallServer = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$l,\n    method: 'POST',\n    path: `/apple-silicon/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/reinstall`\n  }, unmarshalServer$2);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$k = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$o,\n  SERVER_TRANSIENT_STATUSES: SERVER_TRANSIENT_STATUSES$2\n});\n\nvar index$r = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1alpha1: index_gen$k\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link ServerInstallStatus}. */\nconst SERVER_INSTALL_TRANSIENT_STATUSES = ['to_install', 'installing'];\n\n/** Lists transient statutes of the enum {@link ServerPrivateNetworkStatus}. */\nconst SERVER_PRIVATE_NETWORK_TRANSIENT_STATUSES = ['attaching', 'detaching'];\n\n/** Lists transient statutes of the enum {@link ServerStatus}. */\nconst SERVER_TRANSIENT_STATUSES$1 = ['delivering', 'stopping', 'starting', 'deleting', 'ordered', 'resetting'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalCPU = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CPU' failed as data isn't a dictionary.`);\n  }\n  return {\n    benchmark: data.benchmark,\n    coreCount: data.core_count,\n    frequency: data.frequency,\n    name: data.name,\n    threadCount: data.thread_count\n  };\n};\nconst unmarshalDisk = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Disk' failed as data isn't a dictionary.`);\n  }\n  return {\n    capacity: data.capacity,\n    type: data.type\n  };\n};\nconst unmarshalIP$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'IP' failed as data isn't a dictionary.`);\n  }\n  return {\n    address: data.address,\n    id: data.id,\n    reverse: data.reverse,\n    reverseStatus: data.reverse_status,\n    reverseStatusMessage: data.reverse_status_message,\n    version: data.version\n  };\n};\nconst unmarshalMemory = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Memory' failed as data isn't a dictionary.`);\n  }\n  return {\n    capacity: data.capacity,\n    frequency: data.frequency,\n    isEcc: data.is_ecc,\n    type: data.type\n  };\n};\nconst unmarshalOSOSField = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'OSOSField' failed as data isn't a dictionary.`);\n  }\n  return {\n    defaultValue: data.default_value,\n    editable: data.editable,\n    required: data.required\n  };\n};\nconst unmarshalOfferOptionOffer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'OfferOptionOffer' failed as data isn't a dictionary.`);\n  }\n  return {\n    enabled: data.enabled,\n    id: data.id,\n    manageable: data.manageable,\n    name: data.name,\n    osId: data.os_id,\n    price: data.price ? unmarshalMoney(data.price) : undefined,\n    subscriptionPeriod: data.subscription_period\n  };\n};\nconst unmarshalPersistentMemory = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PersistentMemory' failed as data isn't a dictionary.`);\n  }\n  return {\n    capacity: data.capacity,\n    frequency: data.frequency,\n    type: data.type\n  };\n};\nconst unmarshalRaidController = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RaidController' failed as data isn't a dictionary.`);\n  }\n  return {\n    model: data.model,\n    raidLevel: data.raid_level\n  };\n};\nconst unmarshalServerInstall = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerInstall' failed as data isn't a dictionary.`);\n  }\n  return {\n    hostname: data.hostname,\n    osId: data.os_id,\n    serviceUrl: data.service_url,\n    serviceUser: data.service_user,\n    sshKeyIds: data.ssh_key_ids,\n    status: data.status,\n    user: data.user\n  };\n};\nconst unmarshalServerOption = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerOption' failed as data isn't a dictionary.`);\n  }\n  return {\n    expiresAt: unmarshalDate(data.expires_at),\n    id: data.id,\n    manageable: data.manageable,\n    name: data.name,\n    status: data.status\n  };\n};\nconst unmarshalServerRescueServer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerRescueServer' failed as data isn't a dictionary.`);\n  }\n  return {\n    password: data.password,\n    user: data.user\n  };\n};\nconst unmarshalOS = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'OS' failed as data isn't a dictionary.`);\n  }\n  return {\n    allowed: data.allowed,\n    enabled: data.enabled,\n    id: data.id,\n    licenseRequired: data.license_required,\n    logoUrl: data.logo_url,\n    name: data.name,\n    password: data.password ? unmarshalOSOSField(data.password) : undefined,\n    servicePassword: data.service_password ? unmarshalOSOSField(data.service_password) : undefined,\n    serviceUser: data.service_user ? unmarshalOSOSField(data.service_user) : undefined,\n    ssh: data.ssh ? unmarshalOSOSField(data.ssh) : undefined,\n    user: data.user ? unmarshalOSOSField(data.user) : undefined,\n    version: data.version\n  };\n};\nconst unmarshalOffer$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Offer' failed as data isn't a dictionary.`);\n  }\n  return {\n    bandwidth: data.bandwidth,\n    commercialRange: data.commercial_range,\n    cpus: unmarshalArrayOfObject(data.cpus, unmarshalCPU),\n    disks: unmarshalArrayOfObject(data.disks, unmarshalDisk),\n    enable: data.enable,\n    fee: data.fee ? unmarshalMoney(data.fee) : undefined,\n    id: data.id,\n    incompatibleOsIds: data.incompatible_os_ids,\n    memories: unmarshalArrayOfObject(data.memories, unmarshalMemory),\n    name: data.name,\n    operationPath: data.operation_path,\n    options: unmarshalArrayOfObject(data.options, unmarshalOfferOptionOffer),\n    persistentMemories: unmarshalArrayOfObject(data.persistent_memories, unmarshalPersistentMemory),\n    pricePerHour: data.price_per_hour ? unmarshalMoney(data.price_per_hour) : undefined,\n    pricePerMonth: data.price_per_month ? unmarshalMoney(data.price_per_month) : undefined,\n    privateBandwidth: data.private_bandwidth,\n    quotaName: data.quota_name,\n    raidControllers: unmarshalArrayOfObject(data.raid_controllers, unmarshalRaidController),\n    sharedBandwidth: data.shared_bandwidth,\n    stock: data.stock,\n    subscriptionPeriod: data.subscription_period,\n    tags: data.tags\n  };\n};\nconst unmarshalOption = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Option' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    manageable: data.manageable,\n    name: data.name\n  };\n};\nconst unmarshalServer$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Server' failed as data isn't a dictionary.`);\n  }\n  return {\n    bootType: data.boot_type,\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    domain: data.domain,\n    id: data.id,\n    install: data.install ? unmarshalServerInstall(data.install) : undefined,\n    ips: unmarshalArrayOfObject(data.ips, unmarshalIP$1),\n    name: data.name,\n    offerId: data.offer_id,\n    offerName: data.offer_name,\n    options: unmarshalArrayOfObject(data.options, unmarshalServerOption),\n    organizationId: data.organization_id,\n    pingStatus: data.ping_status,\n    projectId: data.project_id,\n    rescueServer: data.rescue_server ? unmarshalServerRescueServer(data.rescue_server) : undefined,\n    status: data.status,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalServerEvent = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerEvent' failed as data isn't a dictionary.`);\n  }\n  return {\n    action: data.action,\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalServerPrivateNetwork = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerPrivateNetwork' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    privateNetworkId: data.private_network_id,\n    projectId: data.project_id,\n    serverId: data.server_id,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at),\n    vlan: data.vlan\n  };\n};\nconst unmarshalSetting = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Setting' failed as data isn't a dictionary.`);\n  }\n  return {\n    enabled: data.enabled,\n    id: data.id,\n    projectId: data.project_id,\n    type: data.type\n  };\n};\nconst unmarshalBMCAccess = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'BMCAccess' failed as data isn't a dictionary.`);\n  }\n  return {\n    expiresAt: unmarshalDate(data.expires_at),\n    login: data.login,\n    password: data.password,\n    url: data.url\n  };\n};\nconst unmarshalGetServerMetricsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetServerMetricsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    pings: data.pings ? unmarshalTimeSeries(data.pings) : undefined\n  };\n};\nconst unmarshalListOSResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListOSResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    os: unmarshalArrayOfObject(data.os, unmarshalOS),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListOffersResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListOffersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    offers: unmarshalArrayOfObject(data.offers, unmarshalOffer$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListOptionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListOptionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    options: unmarshalArrayOfObject(data.options, unmarshalOption),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListServerEventsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServerEventsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    events: unmarshalArrayOfObject(data.events, unmarshalServerEvent),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListServerPrivateNetworksResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServerPrivateNetworksResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    serverPrivateNetworks: unmarshalArrayOfObject(data.server_private_networks, unmarshalServerPrivateNetwork),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListServersResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalArrayOfObject(data.servers, unmarshalServer$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSettingsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSettingsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    settings: unmarshalArrayOfObject(data.settings, unmarshalSetting),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalSetServerPrivateNetworksResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetServerPrivateNetworksResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    serverPrivateNetworks: unmarshalArrayOfObject(data.server_private_networks, unmarshalServerPrivateNetwork)\n  };\n};\nconst marshalCreateServerRequestInstall = (request, defaults) => ({\n  hostname: request.hostname,\n  os_id: request.osId,\n  password: request.password,\n  service_password: request.servicePassword,\n  service_user: request.serviceUser,\n  ssh_key_ids: request.sshKeyIds,\n  user: request.user\n});\nconst marshalAddOptionServerRequest = (request, defaults) => ({\n  expires_at: request.expiresAt\n});\nconst marshalCreateServerRequest$1 = (request, defaults) => ({\n  description: request.description,\n  install: request.install ? marshalCreateServerRequestInstall(request.install) : undefined,\n  name: request.name,\n  offer_id: request.offerId,\n  option_ids: request.optionIds,\n  tags: request.tags,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalInstallServerRequest = (request, defaults) => ({\n  hostname: request.hostname,\n  os_id: request.osId,\n  password: request.password,\n  service_password: request.servicePassword,\n  service_user: request.serviceUser,\n  ssh_key_ids: request.sshKeyIds,\n  user: request.user\n});\nconst marshalPrivateNetworkApiAddServerPrivateNetworkRequest = (request, defaults) => ({\n  private_network_id: request.privateNetworkId\n});\nconst marshalPrivateNetworkApiSetServerPrivateNetworksRequest = (request, defaults) => ({\n  private_network_ids: request.privateNetworkIds\n});\nconst marshalRebootServerRequest = (request, defaults) => ({\n  boot_type: request.bootType ?? 'unknown_boot_type'\n});\nconst marshalStartBMCAccessRequest = (request, defaults) => ({\n  ip: request.ip\n});\nconst marshalStartServerRequest = (request, defaults) => ({\n  boot_type: request.bootType ?? 'unknown_boot_type'\n});\nconst marshalUpdateIPRequest$1 = (request, defaults) => ({\n  reverse: request.reverse\n});\nconst marshalUpdateServerRequest$1 = (request, defaults) => ({\n  description: request.description,\n  name: request.name,\n  tags: request.tags\n});\nconst marshalUpdateSettingRequest = (request, defaults) => ({\n  enabled: request.enabled\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$k = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Elastic Metal API.\n *\n * This API allows to manage your Elastic Metal server. Elastic Metal API.\n */\nlet API$n = class API extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-1', 'fr-par-2', 'nl-ams-1'];\n  pageOfListServers = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers`,\n    urlParams: urlParams(['name', request.name], ['option_id', request.optionId], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['status', request.status], ['tags', request.tags])\n  }, unmarshalListServersResponse$1);\n\n  /**\n   * List Elastic Metal servers for an Organization. List Elastic Metal servers\n   * for a specific Organization.\n   *\n   * @param request - The request {@link ListServersRequest}\n   * @returns A Promise of ListServersResponse\n   */\n  listServers = (request = {}) => enrichForPagination('servers', this.pageOfListServers, request);\n\n  /**\n   * Get a specific Elastic Metal server. Get full details of an existing\n   * Elastic Metal server associated with the ID.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @returns A Promise of Server\n   */\n  getServer = request => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  }, unmarshalServer$1);\n\n  /**\n   * Waits for {@link Server} to be in a final state.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Server\n   */\n  waitForServer = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!SERVER_TRANSIENT_STATUSES$1.includes(res.status))), this.getServer, request, options);\n\n  /**\n   * Create an Elastic Metal server. Create a new Elastic Metal server. Once the\n   * server is created, proceed with the [installation of an OS](#post-3e949e).\n   *\n   * @param request - The request {@link CreateServerRequest}\n   * @returns A Promise of Server\n   */\n  createServer = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateServerRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers`\n  }, unmarshalServer$1);\n\n  /**\n   * Update an Elastic Metal server. Update the server associated with the ID.\n   * You can update parameters such as the server's name, tags and description.\n   * Any parameters left null in the request body are not updated.\n   *\n   * @param request - The request {@link UpdateServerRequest}\n   * @returns A Promise of Server\n   */\n  updateServer = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateServerRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'PATCH',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  }, unmarshalServer$1);\n\n  /**\n   * Install an Elastic Metal server. Install an Operating System (OS) on the\n   * Elastic Metal server with a specific ID.\n   *\n   * @param request - The request {@link InstallServerRequest}\n   * @returns A Promise of Server\n   */\n  installServer = request => this.client.fetch({\n    body: JSON.stringify(marshalInstallServerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/install`\n  }, unmarshalServer$1);\n\n  /**\n   * Return server metrics. Get the ping status of the server associated with\n   * the ID.\n   *\n   * @param request - The request {@link GetServerMetricsRequest}\n   * @returns A Promise of GetServerMetricsResponse\n   */\n  getServerMetrics = request => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/metrics`\n  }, unmarshalGetServerMetricsResponse);\n\n  /**\n   * Delete an Elastic Metal server. Delete the server associated with the ID.\n   *\n   * @param request - The request {@link DeleteServerRequest}\n   * @returns A Promise of Server\n   */\n  deleteServer = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  }, unmarshalServer$1);\n\n  /**\n   * Reboot an Elastic Metal server. Reboot the Elastic Metal server associated\n   * with the ID, use the `boot_type` `rescue` to reboot the server in rescue\n   * mode.\n   *\n   * @param request - The request {@link RebootServerRequest}\n   * @returns A Promise of Server\n   */\n  rebootServer = request => this.client.fetch({\n    body: JSON.stringify(marshalRebootServerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/reboot`\n  }, unmarshalServer$1);\n\n  /**\n   * Start an Elastic Metal server. Start the server associated with the ID.\n   *\n   * @param request - The request {@link StartServerRequest}\n   * @returns A Promise of Server\n   */\n  startServer = request => this.client.fetch({\n    body: JSON.stringify(marshalStartServerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/start`\n  }, unmarshalServer$1);\n\n  /**\n   * Stop an Elastic Metal server. Stop the server associated with the ID. The\n   * server remains allocated to your account and all data remains on the local\n   * storage of the server.\n   *\n   * @param request - The request {@link StopServerRequest}\n   * @returns A Promise of Server\n   */\n  stopServer = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/stop`\n  }, unmarshalServer$1);\n  pageOfListServerEvents = request => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/events`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListServerEventsResponse);\n\n  /**\n   * List server events. List event (i.e. start/stop/reboot) associated to the\n   * server ID.\n   *\n   * @param request - The request {@link ListServerEventsRequest}\n   * @returns A Promise of ListServerEventsResponse\n   */\n  listServerEvents = request => enrichForPagination('events', this.pageOfListServerEvents, request);\n\n  /**\n   * Start BMC access. Start BMC (Baseboard Management Controller) access\n   * associated with the ID. The BMC (Baseboard Management Controller) access is\n   * available one hour after the installation of the server. You need first to\n   * create an option Remote Access. You will find the ID and the price with a\n   * call to listOffers\n   * (https://developers.scaleway.com/en/products/baremetal/api/#get-78db92).\n   * Then add the option\n   * https://developers.scaleway.com/en/products/baremetal/api/#post-b14abd.\n   * After adding the BMC option, you need to Get Remote Access to get the\n   * login/password\n   * https://developers.scaleway.com/en/products/baremetal/api/#get-cefc0f. Do\n   * not forget to delete the Option after use.\n   *\n   * @param request - The request {@link StartBMCAccessRequest}\n   * @returns A Promise of BMCAccess\n   */\n  startBMCAccess = request => this.client.fetch({\n    body: JSON.stringify(marshalStartBMCAccessRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/bmc-access`\n  }, unmarshalBMCAccess);\n\n  /**\n   * Get BMC access. Get the BMC (Baseboard Management Controller) access\n   * associated with the ID, including the URL and login information needed to\n   * connect.\n   *\n   * @param request - The request {@link GetBMCAccessRequest}\n   * @returns A Promise of BMCAccess\n   */\n  getBMCAccess = request => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/bmc-access`\n  }, unmarshalBMCAccess);\n\n  /**\n   * Stop BMC access. Stop BMC (Baseboard Management Controller) access\n   * associated with the ID.\n   *\n   * @param request - The request {@link StopBMCAccessRequest}\n   */\n  stopBMCAccess = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/bmc-access`\n  });\n\n  /**\n   * Update IP. Configure the IP address associated with the server ID and IP\n   * ID. You can use this method to set a reverse DNS for an IP address.\n   *\n   * @param request - The request {@link UpdateIPRequest}\n   * @returns A Promise of IP\n   */\n  updateIP = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateIPRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'PATCH',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/ips/${validatePathParam('ipId', request.ipId)}`\n  }, unmarshalIP$1);\n\n  /**\n   * Add server option. Add an option, such as Private Networks, to a specific\n   * server.\n   *\n   * @param request - The request {@link AddOptionServerRequest}\n   * @returns A Promise of Server\n   */\n  addOptionServer = request => this.client.fetch({\n    body: JSON.stringify(marshalAddOptionServerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/options/${validatePathParam('optionId', request.optionId)}`\n  }, unmarshalServer$1);\n\n  /**\n   * Delete server option. Delete an option from a specific server.\n   *\n   * @param request - The request {@link DeleteOptionServerRequest}\n   * @returns A Promise of Server\n   */\n  deleteOptionServer = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/options/${validatePathParam('optionId', request.optionId)}`\n  }, unmarshalServer$1);\n  pageOfListOffers = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/offers`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['subscription_period', request.subscriptionPeriod ?? 'unknown_subscription_period'])\n  }, unmarshalListOffersResponse$1);\n\n  /**\n   * List offers. List all available Elastic Metal server configurations.\n   *\n   * @param request - The request {@link ListOffersRequest}\n   * @returns A Promise of ListOffersResponse\n   */\n  listOffers = (request = {}) => enrichForPagination('offers', this.pageOfListOffers, request);\n\n  /**\n   * Get offer. Get details of an offer identified by its offer ID.\n   *\n   * @param request - The request {@link GetOfferRequest}\n   * @returns A Promise of Offer\n   */\n  getOffer = request => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/offers/${validatePathParam('offerId', request.offerId)}`\n  }, unmarshalOffer$1);\n\n  /**\n   * Get option. Return specific option for the ID.\n   *\n   * @param request - The request {@link GetOptionRequest}\n   * @returns A Promise of Option\n   */\n  getOption = request => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/options/${validatePathParam('optionId', request.optionId)}`\n  }, unmarshalOption);\n  pageOfListOptions = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/options`,\n    urlParams: urlParams(['name', request.name], ['offer_id', request.offerId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListOptionsResponse);\n\n  /**\n   * List options. List all options matching with filters.\n   *\n   * @param request - The request {@link ListOptionsRequest}\n   * @returns A Promise of ListOptionsResponse\n   */\n  listOptions = (request = {}) => enrichForPagination('options', this.pageOfListOptions, request);\n  pageOfListSettings = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/settings`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId ?? this.client.settings.defaultProjectId])\n  }, unmarshalListSettingsResponse);\n\n  /**\n   * List all settings. Return all settings for a Project ID.\n   *\n   * @param request - The request {@link ListSettingsRequest}\n   * @returns A Promise of ListSettingsResponse\n   */\n  listSettings = (request = {}) => enrichForPagination('settings', this.pageOfListSettings, request);\n\n  /**\n   * Update setting. Update a setting for a Project ID (enable or disable).\n   *\n   * @param request - The request {@link UpdateSettingRequest}\n   * @returns A Promise of Setting\n   */\n  updateSetting = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateSettingRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'PATCH',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/settings/${validatePathParam('settingId', request.settingId)}`\n  }, unmarshalSetting);\n  pageOfListOS = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/os`,\n    urlParams: urlParams(['offer_id', request.offerId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListOSResponse);\n\n  /**\n   * List available OSes. List all OSes that are available for installation on\n   * Elastic Metal servers.\n   *\n   * @param request - The request {@link ListOSRequest}\n   * @returns A Promise of ListOSResponse\n   */\n  listOS = (request = {}) => enrichForPagination('os', this.pageOfListOS, request);\n\n  /**\n   * Get OS with an ID. Return the specific OS for the ID.\n   *\n   * @param request - The request {@link GetOSRequest}\n   * @returns A Promise of OS\n   */\n  getOS = request => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/os/${validatePathParam('osId', request.osId)}`\n  }, unmarshalOS);\n};\n\n/** Elastic Metal Private Network API. */\nclass PrivateNetworkAPI extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-2'];\n\n  /**\n   * Add a server to a Private Network.\n   *\n   * @param request - The request\n   *   {@link PrivateNetworkApiAddServerPrivateNetworkRequest}\n   * @returns A Promise of ServerPrivateNetwork\n   */\n  addServerPrivateNetwork = request => this.client.fetch({\n    body: JSON.stringify(marshalPrivateNetworkApiAddServerPrivateNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'POST',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private-networks`\n  }, unmarshalServerPrivateNetwork);\n\n  /**\n   * Set multiple Private Networks on a server.\n   *\n   * @param request - The request\n   *   {@link PrivateNetworkApiSetServerPrivateNetworksRequest}\n   * @returns A Promise of SetServerPrivateNetworksResponse\n   */\n  setServerPrivateNetworks = request => this.client.fetch({\n    body: JSON.stringify(marshalPrivateNetworkApiSetServerPrivateNetworksRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$k,\n    method: 'PUT',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private-networks`\n  }, unmarshalSetServerPrivateNetworksResponse);\n  pageOfListServerPrivateNetworks = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/server-private-networks`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['private_network_id', request.privateNetworkId], ['project_id', request.projectId], ['server_id', request.serverId])\n  }, unmarshalListServerPrivateNetworksResponse);\n\n  /**\n   * List the Private Networks of a server.\n   *\n   * @param request - The request\n   *   {@link PrivateNetworkApiListServerPrivateNetworksRequest}\n   * @returns A Promise of ListServerPrivateNetworksResponse\n   */\n  listServerPrivateNetworks = (request = {}) => enrichForPagination('serverPrivateNetworks', this.pageOfListServerPrivateNetworks, request);\n\n  /**\n   * Delete a Private Network.\n   *\n   * @param request - The request\n   *   {@link PrivateNetworkApiDeleteServerPrivateNetworkRequest}\n   */\n  deleteServerPrivateNetwork = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/baremetal/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}`\n  });\n}\n\nclass BaremetalV1UtilsAPI extends API$n {\n  /**\n   * Waits for {@link ServerInstall} to be in a final state.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @param options - The waiting options\n   * @returns A Promise of ServerInstall\n   */\n  waitForServerInstall = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getServer(request).then(server => {\n      if (!server.install) {\n        throw new Error(`Server creation has not begun for server ${request.serverId}`);\n      }\n      return server.install;\n    });\n    return {\n      done: !SERVER_INSTALL_TRANSIENT_STATUSES.includes(value.status),\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n}\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nconst CreateServerRequest = {\n  description: {\n    maxLength: 255\n  },\n  name: {\n    minLength: 1\n  }\n};\nconst CreateServerRequestInstall = {\n  hostname: {\n    maxLength: 255\n  },\n  password: {\n    maxLength: 255\n  },\n  servicePassword: {\n    maxLength: 255\n  },\n  serviceUser: {\n    maxLength: 255\n  },\n  user: {\n    maxLength: 255\n  }\n};\nconst InstallServerRequest = {\n  hostname: {\n    maxLength: 255\n  },\n  password: {\n    maxLength: 255\n  },\n  servicePassword: {\n    maxLength: 255\n  },\n  serviceUser: {\n    maxLength: 255\n  },\n  user: {\n    maxLength: 255\n  }\n};\nconst ListOSRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst ListOffersRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst ListOptionsRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst ListServerEventsRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst ListServersRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst ListSettingsRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst UpdateServerRequest = {\n  description: {\n    maxLength: 255\n  },\n  name: {\n    maxLength: 255\n  }\n};\n\nvar validationRules_gen$4 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CreateServerRequest: CreateServerRequest,\n  CreateServerRequestInstall: CreateServerRequestInstall,\n  InstallServerRequest: InstallServerRequest,\n  ListOSRequest: ListOSRequest,\n  ListOffersRequest: ListOffersRequest,\n  ListOptionsRequest: ListOptionsRequest,\n  ListServerEventsRequest: ListServerEventsRequest,\n  ListServersRequest: ListServersRequest,\n  ListSettingsRequest: ListSettingsRequest,\n  UpdateServerRequest: UpdateServerRequest\n});\n\nvar index$q = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: BaremetalV1UtilsAPI,\n  PrivateNetworkAPI: PrivateNetworkAPI,\n  SERVER_INSTALL_TRANSIENT_STATUSES: SERVER_INSTALL_TRANSIENT_STATUSES,\n  SERVER_PRIVATE_NETWORK_TRANSIENT_STATUSES: SERVER_PRIVATE_NETWORK_TRANSIENT_STATUSES,\n  SERVER_TRANSIENT_STATUSES: SERVER_TRANSIENT_STATUSES$1,\n  ValidationRules: validationRules_gen$4\n});\n\nvar index$p = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index$q\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalGetConsumptionResponseConsumption = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetConsumptionResponseConsumption' failed as data isn't a dictionary.`);\n  }\n  return {\n    category: data.category,\n    description: data.description,\n    operationPath: data.operation_path,\n    projectId: data.project_id,\n    value: data.value ? unmarshalMoney(data.value) : undefined\n  };\n};\nconst unmarshalInvoice = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Invoice' failed as data isn't a dictionary.`);\n  }\n  return {\n    dueDate: unmarshalDate(data.due_date),\n    id: data.id,\n    invoiceType: data.invoice_type,\n    issuedDate: unmarshalDate(data.issued_date),\n    number: data.number,\n    startDate: unmarshalDate(data.start_date),\n    totalTaxed: data.total_taxed ? unmarshalMoney(data.total_taxed) : undefined,\n    totalUntaxed: data.total_untaxed ? unmarshalMoney(data.total_untaxed) : undefined\n  };\n};\nconst unmarshalGetConsumptionResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetConsumptionResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    consumptions: unmarshalArrayOfObject(data.consumptions, unmarshalGetConsumptionResponseConsumption),\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalListInvoicesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListInvoicesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    invoices: unmarshalArrayOfObject(data.invoices, unmarshalInvoice),\n    totalCount: data.total_count\n  };\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n/**\n * Billing API.\n *\n * This API allows you to query your consumption. Billing API.\n */\nlet API$m = class API extends API$q {\n  getConsumption = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/billing/v2alpha1/consumption`,\n    urlParams: urlParams(['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId])\n  }, unmarshalGetConsumptionResponse);\n  pageOfListInvoices = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/billing/v2alpha1/invoices`,\n    urlParams: urlParams(['invoice_type', request.invoiceType ?? 'unknown_type'], ['order_by', request.orderBy ?? 'invoice_number_desc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['started_after', request.startedAfter], ['started_before', request.startedBefore])\n  }, unmarshalListInvoicesResponse);\n  listInvoices = (request = {}) => enrichForPagination('invoices', this.pageOfListInvoices, request);\n  downloadInvoice = request => this.client.fetch({\n    method: 'GET',\n    path: `/billing/v2alpha1/invoices/${validatePathParam('invoiceId', request.invoiceId)}/download`,\n    urlParams: urlParams(['dl', 1], ['file_type', request.fileType ?? 'pdf']),\n    responseType: 'blob'\n  });\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$j = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$m\n});\n\nvar index$o = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v2alpha1: index_gen$j\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link CockpitStatus}. */\nconst COCKPIT_TRANSIENT_STATUSES = ['creating', 'deleting', 'updating'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalContactPointEmail = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactPointEmail' failed as data isn't a dictionary.`);\n  }\n  return {\n    to: data.to\n  };\n};\nconst unmarshalTokenScopes = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'TokenScopes' failed as data isn't a dictionary.`);\n  }\n  return {\n    queryLogs: data.query_logs,\n    queryMetrics: data.query_metrics,\n    setupAlerts: data.setup_alerts,\n    setupLogsRules: data.setup_logs_rules,\n    setupMetricsRules: data.setup_metrics_rules,\n    writeLogs: data.write_logs,\n    writeMetrics: data.write_metrics\n  };\n};\nconst unmarshalCockpitEndpoints = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CockpitEndpoints' failed as data isn't a dictionary.`);\n  }\n  return {\n    alertmanagerUrl: data.alertmanager_url,\n    grafanaUrl: data.grafana_url,\n    logsUrl: data.logs_url,\n    metricsUrl: data.metrics_url\n  };\n};\nconst unmarshalContactPoint = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactPoint' failed as data isn't a dictionary.`);\n  }\n  return {\n    email: data.email ? unmarshalContactPointEmail(data.email) : undefined\n  };\n};\nconst unmarshalGrafanaUser = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GrafanaUser' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    login: data.login,\n    password: data.password,\n    role: data.role\n  };\n};\nconst unmarshalPlan = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Plan' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    logsIngestionPrice: data.logs_ingestion_price,\n    name: data.name,\n    retentionLogsInterval: data.retention_logs_interval,\n    retentionMetricsInterval: data.retention_metrics_interval,\n    retentionPrice: data.retention_price,\n    sampleIngestionPrice: data.sample_ingestion_price\n  };\n};\nconst unmarshalToken$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Token' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    name: data.name,\n    projectId: data.project_id,\n    scopes: data.scopes ? unmarshalTokenScopes(data.scopes) : undefined,\n    secretKey: data.secret_key,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalCockpit = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Cockpit' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    endpoints: data.endpoints ? unmarshalCockpitEndpoints(data.endpoints) : undefined,\n    managedAlertsEnabled: data.managed_alerts_enabled,\n    plan: data.plan ? unmarshalPlan(data.plan) : undefined,\n    projectId: data.project_id,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalCockpitMetrics = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CockpitMetrics' failed as data isn't a dictionary.`);\n  }\n  return {\n    timeseries: unmarshalArrayOfObject(data.timeseries, unmarshalTimeSeries)\n  };\n};\nconst unmarshalListContactPointsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListContactPointsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    contactPoints: unmarshalArrayOfObject(data.contact_points, unmarshalContactPoint),\n    hasAdditionalContactPoints: data.has_additional_contact_points,\n    hasAdditionalReceivers: data.has_additional_receivers,\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListGrafanaUsersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListGrafanaUsersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    grafanaUsers: unmarshalArrayOfObject(data.grafana_users, unmarshalGrafanaUser),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPlansResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPlansResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    plans: unmarshalArrayOfObject(data.plans, unmarshalPlan),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListTokensResponse$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTokensResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    tokens: unmarshalArrayOfObject(data.tokens, unmarshalToken$2),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalSelectPlanResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SelectPlanResponse' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst marshalContactPointEmail = (request, defaults) => ({\n  to: request.to\n});\nconst marshalContactPoint = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'email',\n    value: request.email ? marshalContactPointEmail(request.email) : undefined\n  }])\n});\nconst marshalTokenScopes = (request, defaults) => ({\n  query_logs: request.queryLogs,\n  query_metrics: request.queryMetrics,\n  setup_alerts: request.setupAlerts,\n  setup_logs_rules: request.setupLogsRules,\n  setup_metrics_rules: request.setupMetricsRules,\n  write_logs: request.writeLogs,\n  write_metrics: request.writeMetrics\n});\nconst marshalActivateCockpitRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalCreateContactPointRequest = (request, defaults) => ({\n  contact_point: request.contactPoint ? marshalContactPoint(request.contactPoint) : undefined,\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalCreateGrafanaUserRequest = (request, defaults) => ({\n  login: request.login,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  role: request.role ?? 'unknown_role'\n});\nconst marshalCreateTokenRequest$2 = (request, defaults) => ({\n  name: request.name || randomName('token'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  scopes: request.scopes ? marshalTokenScopes(request.scopes) : undefined\n});\nconst marshalDeactivateCockpitRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalDeleteContactPointRequest = (request, defaults) => ({\n  contact_point: request.contactPoint ? marshalContactPoint(request.contactPoint) : undefined,\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalDeleteGrafanaUserRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalDisableManagedAlertsRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalEnableManagedAlertsRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalResetCockpitGrafanaRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalResetGrafanaUserPasswordRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalSelectPlanRequest = (request, defaults) => ({\n  plan_id: request.planId,\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalTriggerTestAlertRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$j = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Cockpit API.\n *\n * Cockpit API. Cockpit's API allows you to activate your Cockpit on your\n * Projects. Scaleway's Cockpit stores metrics and logs and provides a dedicated\n * Grafana for dashboarding to visualize them.\n */\nlet API$l = class API extends API$q {\n  /**\n   * Activate a Cockpit. Activate the Cockpit of the specified Project ID.\n   *\n   * @param request - The request {@link ActivateCockpitRequest}\n   * @returns A Promise of Cockpit\n   */\n  activateCockpit = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalActivateCockpitRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/activate`\n  }, unmarshalCockpit);\n\n  /**\n   * Get a Cockpit. Retrieve the Cockpit of the specified Project ID.\n   *\n   * @param request - The request {@link GetCockpitRequest}\n   * @returns A Promise of Cockpit\n   */\n  getCockpit = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/cockpit/v1beta1/cockpit`,\n    urlParams: urlParams(['project_id', request.projectId ?? this.client.settings.defaultProjectId])\n  }, unmarshalCockpit);\n\n  /**\n   * Waits for {@link Cockpit} to be in a final state.\n   *\n   * @param request - The request {@link GetCockpitRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Cockpit\n   */\n  waitForCockpit = (request = {}, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!COCKPIT_TRANSIENT_STATUSES.includes(res.status))), this.getCockpit, request, options);\n\n  /**\n   * Get Cockpit metrics. Get metrics from your Cockpit with the specified\n   * Project ID.\n   *\n   * @param request - The request {@link GetCockpitMetricsRequest}\n   * @returns A Promise of CockpitMetrics\n   */\n  getCockpitMetrics = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/cockpit/v1beta1/cockpit/metrics`,\n    urlParams: urlParams(['end_date', request.endDate], ['metric_name', request.metricName], ['project_id', request.projectId ?? this.client.settings.defaultProjectId], ['start_date', request.startDate])\n  }, unmarshalCockpitMetrics);\n\n  /**\n   * Deactivate a Cockpit. Deactivate the Cockpit of the specified Project ID.\n   *\n   * @param request - The request {@link DeactivateCockpitRequest}\n   * @returns A Promise of Cockpit\n   */\n  deactivateCockpit = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalDeactivateCockpitRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/deactivate`\n  }, unmarshalCockpit);\n\n  /**\n   * Reset a Grafana. Reset your Cockpit's Grafana associated with the specified\n   * Project ID.\n   *\n   * @param request - The request {@link ResetCockpitGrafanaRequest}\n   * @returns A Promise of Cockpit\n   */\n  resetCockpitGrafana = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalResetCockpitGrafanaRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/reset-grafana`\n  }, unmarshalCockpit);\n\n  /**\n   * Create a token. Create a token associated with the specified Project ID.\n   *\n   * @param request - The request {@link CreateTokenRequest}\n   * @returns A Promise of Token\n   */\n  createToken = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateTokenRequest$2(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/tokens`\n  }, unmarshalToken$2);\n  pageOfListTokens = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/cockpit/v1beta1/tokens`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId ?? this.client.settings.defaultProjectId])\n  }, unmarshalListTokensResponse$2);\n\n  /**\n   * List tokens. Get a list of tokens associated with the specified Project ID.\n   *\n   * @param request - The request {@link ListTokensRequest}\n   * @returns A Promise of ListTokensResponse\n   */\n  listTokens = (request = {}) => enrichForPagination('tokens', this.pageOfListTokens, request);\n\n  /**\n   * Get a token. Retrieve the token associated with the specified token ID.\n   *\n   * @param request - The request {@link GetTokenRequest}\n   * @returns A Promise of Token\n   */\n  getToken = request => this.client.fetch({\n    method: 'GET',\n    path: `/cockpit/v1beta1/tokens/${validatePathParam('tokenId', request.tokenId)}`\n  }, unmarshalToken$2);\n\n  /**\n   * Delete a token. Delete the token associated with the specified token ID.\n   *\n   * @param request - The request {@link DeleteTokenRequest}\n   */\n  deleteToken = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/cockpit/v1beta1/tokens/${validatePathParam('tokenId', request.tokenId)}`\n  });\n\n  /**\n   * Create a contact point. Create a contact point to receive alerts for the\n   * default receiver.\n   *\n   * @param request - The request {@link CreateContactPointRequest}\n   * @returns A Promise of ContactPoint\n   */\n  createContactPoint = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateContactPointRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/contact-points`\n  }, unmarshalContactPoint);\n  pageOfListContactPoints = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/cockpit/v1beta1/contact-points`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId ?? this.client.settings.defaultProjectId])\n  }, unmarshalListContactPointsResponse);\n\n  /**\n   * List contact points. Get a list of contact points for the Cockpit\n   * associated with the specified Project ID.\n   *\n   * @param request - The request {@link ListContactPointsRequest}\n   * @returns A Promise of ListContactPointsResponse\n   */\n  listContactPoints = (request = {}) => enrichForPagination('contactPoints', this.pageOfListContactPoints, request);\n\n  /**\n   * Delete an alert contact point. Delete a contact point for the default\n   * receiver.\n   *\n   * @param request - The request {@link DeleteContactPointRequest}\n   */\n  deleteContactPoint = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalDeleteContactPointRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/delete-contact-point`\n  });\n\n  /**\n   * Enable managed alerts. Enable the sending of managed alerts for the\n   * specified Project's Cockpit.\n   *\n   * @param request - The request {@link EnableManagedAlertsRequest}\n   */\n  enableManagedAlerts = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalEnableManagedAlertsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/enable-managed-alerts`\n  });\n\n  /**\n   * Disable managed alerts. Disable the sending of managed alerts for the\n   * specified Project's Cockpit.\n   *\n   * @param request - The request {@link DisableManagedAlertsRequest}\n   */\n  disableManagedAlerts = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalDisableManagedAlertsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/disable-managed-alerts`\n  });\n\n  /**\n   * Trigger a test alert. Trigger a test alert to all of the Cockpit's\n   * receivers.\n   *\n   * @param request - The request {@link TriggerTestAlertRequest}\n   */\n  triggerTestAlert = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalTriggerTestAlertRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/trigger-test-alert`\n  });\n\n  /**\n   * Create a Grafana user. Create a Grafana user for your Cockpit's Grafana\n   * instance. Make sure you save the automatically-generated password and the\n   * Grafana user ID.\n   *\n   * @param request - The request {@link CreateGrafanaUserRequest}\n   * @returns A Promise of GrafanaUser\n   */\n  createGrafanaUser = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateGrafanaUserRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/grafana-users`\n  }, unmarshalGrafanaUser);\n  pageOfListGrafanaUsers = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/cockpit/v1beta1/grafana-users`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'login_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId ?? this.client.settings.defaultProjectId])\n  }, unmarshalListGrafanaUsersResponse);\n\n  /**\n   * List Grafana users. Get a list of Grafana users who are able to connect to\n   * the Cockpit's Grafana instance.\n   *\n   * @param request - The request {@link ListGrafanaUsersRequest}\n   * @returns A Promise of ListGrafanaUsersResponse\n   */\n  listGrafanaUsers = (request = {}) => enrichForPagination('grafanaUsers', this.pageOfListGrafanaUsers, request);\n\n  /**\n   * Delete a Grafana user. Delete a Grafana user from a Grafana instance,\n   * specified by the Cockpit's Project ID and the Grafana user ID.\n   *\n   * @param request - The request {@link DeleteGrafanaUserRequest}\n   */\n  deleteGrafanaUser = request => this.client.fetch({\n    body: JSON.stringify(marshalDeleteGrafanaUserRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/grafana-users/${validatePathParam('grafanaUserId', request.grafanaUserId)}/delete`\n  });\n\n  /**\n   * Reset a Grafana user's password. Reset a Grafana user's password specified\n   * by the Cockpit's Project ID and the Grafana user ID.\n   *\n   * @param request - The request {@link ResetGrafanaUserPasswordRequest}\n   * @returns A Promise of GrafanaUser\n   */\n  resetGrafanaUserPassword = request => this.client.fetch({\n    body: JSON.stringify(marshalResetGrafanaUserPasswordRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/grafana-users/${validatePathParam('grafanaUserId', request.grafanaUserId)}/reset-password`\n  }, unmarshalGrafanaUser);\n  pageOfListPlans = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/cockpit/v1beta1/plans`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListPlansResponse);\n\n  /**\n   * List pricing plans. Get a list of all pricing plans available.\n   *\n   * @param request - The request {@link ListPlansRequest}\n   * @returns A Promise of ListPlansResponse\n   */\n  listPlans = (request = {}) => enrichForPagination('plans', this.pageOfListPlans, request);\n\n  /**\n   * Select pricing plan. Select your chosen pricing plan for your Cockpit,\n   * specifying the Cockpit's Project ID and the pricing plan's ID in the\n   * request.\n   *\n   * @param request - The request {@link SelectPlanRequest}\n   * @returns A Promise of SelectPlanResponse\n   */\n  selectPlan = request => this.client.fetch({\n    body: JSON.stringify(marshalSelectPlanRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$j,\n    method: 'POST',\n    path: `/cockpit/v1beta1/select-plan`\n  }, unmarshalSelectPlanResponse);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$i = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$l,\n  COCKPIT_TRANSIENT_STATUSES: COCKPIT_TRANSIENT_STATUSES\n});\n\nvar index$n = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1beta1: index_gen$i\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link ContainerStatus}. */\nconst CONTAINER_TRANSIENT_STATUSES = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link CronStatus}. */\nconst CRON_TRANSIENT_STATUSES$1 = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link DomainStatus}. */\nconst DOMAIN_TRANSIENT_STATUSES$3 = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link NamespaceStatus}. */\nconst NAMESPACE_TRANSIENT_STATUSES$2 = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link TokenStatus}. */\nconst TOKEN_TRANSIENT_STATUSES$1 = ['deleting', 'creating'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalSecretHashedValue$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SecretHashedValue' failed as data isn't a dictionary.`);\n  }\n  return {\n    hashedValue: data.hashed_value,\n    key: data.key\n  };\n};\nconst unmarshalContainer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Container' failed as data isn't a dictionary.`);\n  }\n  return {\n    cpuLimit: data.cpu_limit,\n    description: data.description,\n    domainName: data.domain_name,\n    environmentVariables: data.environment_variables,\n    errorMessage: data.error_message,\n    httpOption: data.http_option,\n    id: data.id,\n    maxConcurrency: data.max_concurrency,\n    maxScale: data.max_scale,\n    memoryLimit: data.memory_limit,\n    minScale: data.min_scale,\n    name: data.name,\n    namespaceId: data.namespace_id,\n    port: data.port,\n    privacy: data.privacy,\n    protocol: data.protocol,\n    region: data.region,\n    registryImage: data.registry_image,\n    secretEnvironmentVariables: unmarshalArrayOfObject(data.secret_environment_variables, unmarshalSecretHashedValue$1),\n    status: data.status,\n    timeout: data.timeout\n  };\n};\nconst unmarshalCron$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Cron' failed as data isn't a dictionary.`);\n  }\n  return {\n    args: data.args,\n    containerId: data.container_id,\n    id: data.id,\n    name: data.name,\n    schedule: data.schedule,\n    status: data.status\n  };\n};\nconst unmarshalDomain$3 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Domain' failed as data isn't a dictionary.`);\n  }\n  return {\n    containerId: data.container_id,\n    errorMessage: data.error_message,\n    hostname: data.hostname,\n    id: data.id,\n    status: data.status,\n    url: data.url\n  };\n};\nconst unmarshalLog$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Log' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    level: data.level,\n    message: data.message,\n    source: data.source,\n    stream: data.stream,\n    timestamp: unmarshalDate(data.timestamp)\n  };\n};\nconst unmarshalNamespace$3 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Namespace' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    environmentVariables: data.environment_variables,\n    errorMessage: data.error_message,\n    id: data.id,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    region: data.region,\n    registryEndpoint: data.registry_endpoint,\n    registryNamespaceId: data.registry_namespace_id,\n    secretEnvironmentVariables: unmarshalArrayOfObject(data.secret_environment_variables, unmarshalSecretHashedValue$1),\n    status: data.status\n  };\n};\nconst unmarshalToken$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Token' failed as data isn't a dictionary.`);\n  }\n  return {\n    containerId: data.container_id,\n    description: data.description,\n    expiresAt: unmarshalDate(data.expires_at),\n    id: data.id,\n    namespaceId: data.namespace_id,\n    publicKey: data.public_key,\n    status: data.status,\n    token: data.token\n  };\n};\nconst unmarshalListContainersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListContainersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    containers: unmarshalArrayOfObject(data.containers, unmarshalContainer),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListCronsResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListCronsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    crons: unmarshalArrayOfObject(data.crons, unmarshalCron$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDomainsResponse$3 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    domains: unmarshalArrayOfObject(data.domains, unmarshalDomain$3),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListLogsResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListLogsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    logs: unmarshalArrayOfObject(data.logs, unmarshalLog$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNamespacesResponse$3 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    namespaces: unmarshalArrayOfObject(data.namespaces, unmarshalNamespace$3),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListTokensResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTokensResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    tokens: unmarshalArrayOfObject(data.tokens, unmarshalToken$1),\n    totalCount: data.total_count\n  };\n};\nconst marshalSecret$1 = (request, defaults) => ({\n  key: request.key,\n  value: request.value\n});\nconst marshalCreateContainerRequest = (request, defaults) => ({\n  cpu_limit: request.cpuLimit,\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  http_option: request.httpOption ?? 'unknown_http_option',\n  max_concurrency: request.maxConcurrency,\n  max_scale: request.maxScale,\n  memory_limit: request.memoryLimit,\n  min_scale: request.minScale,\n  name: request.name,\n  namespace_id: request.namespaceId,\n  port: request.port,\n  privacy: request.privacy ?? 'unknown_privacy',\n  protocol: request.protocol ?? 'unknown_protocol',\n  registry_image: request.registryImage,\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret$1(elt)) : undefined,\n  timeout: request.timeout\n});\nconst marshalCreateCronRequest$1 = (request, defaults) => ({\n  args: request.args,\n  container_id: request.containerId,\n  name: request.name,\n  schedule: request.schedule\n});\nconst marshalCreateDomainRequest$2 = (request, defaults) => ({\n  container_id: request.containerId,\n  hostname: request.hostname\n});\nconst marshalCreateNamespaceRequest$3 = (request, defaults) => ({\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  name: request.name || randomName('cns'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret$1(elt)) : undefined\n});\nconst marshalCreateTokenRequest$1 = (request, defaults) => ({\n  description: request.description,\n  expires_at: request.expiresAt,\n  ...resolveOneOf([{\n    param: 'container_id',\n    value: request.containerId\n  }, {\n    param: 'namespace_id',\n    value: request.namespaceId\n  }])\n});\nconst marshalUpdateContainerRequest = (request, defaults) => ({\n  cpu_limit: request.cpuLimit,\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  http_option: request.httpOption ?? 'unknown_http_option',\n  max_concurrency: request.maxConcurrency,\n  max_scale: request.maxScale,\n  memory_limit: request.memoryLimit,\n  min_scale: request.minScale,\n  port: request.port,\n  privacy: request.privacy ?? 'unknown_privacy',\n  protocol: request.protocol ?? 'unknown_protocol',\n  redeploy: request.redeploy,\n  registry_image: request.registryImage,\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret$1(elt)) : undefined,\n  timeout: request.timeout\n});\nconst marshalUpdateCronRequest$1 = (request, defaults) => ({\n  args: request.args,\n  container_id: request.containerId,\n  name: request.name,\n  schedule: request.schedule\n});\nconst marshalUpdateNamespaceRequest$3 = (request, defaults) => ({\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret$1(elt)) : undefined\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$i = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Serverless Containers API. */\nlet API$k = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par', 'nl-ams', 'pl-waw'];\n  pageOfListNamespaces = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListNamespacesResponse$3);\n\n  /**\n   * List all your namespaces. List all namespaces in a specified region.\n   *\n   * @param request - The request {@link ListNamespacesRequest}\n   * @returns A Promise of ListNamespacesResponse\n   */\n  listNamespaces = (request = {}) => enrichForPagination('namespaces', this.pageOfListNamespaces, request);\n\n  /**\n   * Get a namespace. Get the namespace associated with the specified ID.\n   *\n   * @param request - The request {@link GetNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  getNamespace = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace$3);\n\n  /**\n   * Waits for {@link Namespace} to be in a final state.\n   *\n   * @param request - The request {@link GetNamespaceRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Namespace\n   */\n  waitForNamespace = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!NAMESPACE_TRANSIENT_STATUSES$2.includes(res.status))), this.getNamespace, request, options);\n\n  /**\n   * Create a new namespace. Create a new namespace in a specified region.\n   *\n   * @param request - The request {@link CreateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  createNamespace = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateNamespaceRequest$3(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'POST',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`\n  }, unmarshalNamespace$3);\n\n  /**\n   * Update an existing namespace. Update the space associated with the\n   * specified ID.\n   *\n   * @param request - The request {@link UpdateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  updateNamespace = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateNamespaceRequest$3(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'PATCH',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace$3);\n\n  /**\n   * Delete an existing namespace. Delete the namespace associated with the\n   * specified ID.\n   *\n   * @param request - The request {@link DeleteNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  deleteNamespace = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace$3);\n  pageOfListContainers = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/containers`,\n    urlParams: urlParams(['name', request.name], ['namespace_id', request.namespaceId], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListContainersResponse);\n\n  /**\n   * List all your containers. List all containers for a specified region.\n   *\n   * @param request - The request {@link ListContainersRequest}\n   * @returns A Promise of ListContainersResponse\n   */\n  listContainers = request => enrichForPagination('containers', this.pageOfListContainers, request);\n\n  /**\n   * Get a container. Get the container associated with the specified ID.\n   *\n   * @param request - The request {@link GetContainerRequest}\n   * @returns A Promise of Container\n   */\n  getContainer = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/containers/${validatePathParam('containerId', request.containerId)}`\n  }, unmarshalContainer);\n\n  /**\n   * Waits for {@link Container} to be in a final state.\n   *\n   * @param request - The request {@link GetContainerRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Container\n   */\n  waitForContainer = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!CONTAINER_TRANSIENT_STATUSES.includes(res.status))), this.getContainer, request, options);\n\n  /**\n   * Create a new container. Create a new container in the specified region.\n   *\n   * @param request - The request {@link CreateContainerRequest}\n   * @returns A Promise of Container\n   */\n  createContainer = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateContainerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'POST',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/containers`\n  }, unmarshalContainer);\n\n  /**\n   * Update an existing container. Update the container associated with the\n   * specified ID.\n   *\n   * @param request - The request {@link UpdateContainerRequest}\n   * @returns A Promise of Container\n   */\n  updateContainer = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateContainerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'PATCH',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/containers/${validatePathParam('containerId', request.containerId)}`\n  }, unmarshalContainer);\n\n  /**\n   * Delete a container. Delete the container associated with the specified ID.\n   *\n   * @param request - The request {@link DeleteContainerRequest}\n   * @returns A Promise of Container\n   */\n  deleteContainer = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/containers/${validatePathParam('containerId', request.containerId)}`\n  }, unmarshalContainer);\n\n  /**\n   * Deploy a container. Deploy a container associated with the specified ID.\n   *\n   * @param request - The request {@link DeployContainerRequest}\n   * @returns A Promise of Container\n   */\n  deployContainer = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$i,\n    method: 'POST',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/containers/${validatePathParam('containerId', request.containerId)}/deploy`\n  }, unmarshalContainer);\n  pageOfListCrons = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons`,\n    urlParams: urlParams(['container_id', request.containerId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListCronsResponse$1);\n\n  /**\n   * List all your crons.\n   *\n   * @param request - The request {@link ListCronsRequest}\n   * @returns A Promise of ListCronsResponse\n   */\n  listCrons = request => enrichForPagination('crons', this.pageOfListCrons, request);\n\n  /**\n   * Get a cron. Get the cron associated with the specified ID.\n   *\n   * @param request - The request {@link GetCronRequest}\n   * @returns A Promise of Cron\n   */\n  getCron = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons/${validatePathParam('cronId', request.cronId)}`\n  }, unmarshalCron$1);\n\n  /**\n   * Waits for {@link Cron} to be in a final state.\n   *\n   * @param request - The request {@link GetCronRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Cron\n   */\n  waitForCron = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!CRON_TRANSIENT_STATUSES$1.includes(res.status))), this.getCron, request, options);\n\n  /**\n   * Create a new cron.\n   *\n   * @param request - The request {@link CreateCronRequest}\n   * @returns A Promise of Cron\n   */\n  createCron = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateCronRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'POST',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons`\n  }, unmarshalCron$1);\n\n  /**\n   * Update an existing cron. Update the cron associated with the specified ID.\n   *\n   * @param request - The request {@link UpdateCronRequest}\n   * @returns A Promise of Cron\n   */\n  updateCron = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateCronRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'PATCH',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons/${validatePathParam('cronId', request.cronId)}`\n  }, unmarshalCron$1);\n\n  /**\n   * Delete an existing cron. Delete the cron associated with the specified ID.\n   *\n   * @param request - The request {@link DeleteCronRequest}\n   * @returns A Promise of Cron\n   */\n  deleteCron = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons/${validatePathParam('cronId', request.cronId)}`\n  }, unmarshalCron$1);\n  pageOfListLogs = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/containers/${validatePathParam('containerId', request.containerId)}/logs`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'timestamp_desc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListLogsResponse$1);\n\n  /**\n   * List your container logs. List the logs of the container with the specified\n   * ID.\n   *\n   * @param request - The request {@link ListLogsRequest}\n   * @returns A Promise of ListLogsResponse\n   */\n  listLogs = request => enrichForPagination('logs', this.pageOfListLogs, request);\n  pageOfListDomains = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains`,\n    urlParams: urlParams(['container_id', request.containerId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListDomainsResponse$3);\n\n  /**\n   * List all domain name bindings. List all domain name bindings in a specified\n   * region.\n   *\n   * @param request - The request {@link ListDomainsRequest}\n   * @returns A Promise of ListDomainsResponse\n   */\n  listDomains = request => enrichForPagination('domains', this.pageOfListDomains, request);\n\n  /**\n   * Get a domain name binding. Get a domain name binding for the container with\n   * the specified ID.\n   *\n   * @param request - The request {@link GetDomainRequest}\n   * @returns A Promise of Domain\n   */\n  getDomain = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domainId', request.domainId)}`\n  }, unmarshalDomain$3);\n\n  /**\n   * Waits for {@link Domain} to be in a final state.\n   *\n   * @param request - The request {@link GetDomainRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Domain\n   */\n  waitForDomain = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!DOMAIN_TRANSIENT_STATUSES$3.includes(res.status))), this.getDomain, request, options);\n\n  /**\n   * Create a domain name binding. Create a domain name binding for the\n   * container with the specified ID.\n   *\n   * @param request - The request {@link CreateDomainRequest}\n   * @returns A Promise of Domain\n   */\n  createDomain = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDomainRequest$2(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'POST',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains`\n  }, unmarshalDomain$3);\n\n  /**\n   * Delete a domain name binding. Delete the domain name binding with the\n   * specific ID.\n   *\n   * @param request - The request {@link DeleteDomainRequest}\n   * @returns A Promise of Domain\n   */\n  deleteDomain = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domainId', request.domainId)}`\n  }, unmarshalDomain$3);\n\n  /**\n   * @deprecated\n   * @param request - The request {@link IssueJWTRequest}\n   * @returns A Promise of Token\n   */\n  issueJWT = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/issue-jwt`,\n    urlParams: urlParams(['expires_at', request.expiresAt], ...Object.entries(resolveOneOf([{\n      param: 'container_id',\n      value: request.containerId\n    }, {\n      param: 'namespace_id',\n      value: request.namespaceId\n    }])))\n  }, unmarshalToken$1);\n\n  /**\n   * Create a new revocable token.\n   *\n   * @param request - The request {@link CreateTokenRequest}\n   * @returns A Promise of Token\n   */\n  createToken = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateTokenRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$i,\n    method: 'POST',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens`\n  }, unmarshalToken$1);\n\n  /**\n   * Get a token. Get a token with a specified ID.\n   *\n   * @param request - The request {@link GetTokenRequest}\n   * @returns A Promise of Token\n   */\n  getToken = request => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens/${validatePathParam('tokenId', request.tokenId)}`\n  }, unmarshalToken$1);\n\n  /**\n   * Waits for {@link Token} to be in a final state.\n   *\n   * @param request - The request {@link GetTokenRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Token\n   */\n  waitForToken = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!TOKEN_TRANSIENT_STATUSES$1.includes(res.status))), this.getToken, request, options);\n  pageOfListTokens = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens`,\n    urlParams: urlParams(['container_id', request.containerId], ['namespace_id', request.namespaceId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListTokensResponse$1);\n\n  /**\n   * List all tokens. List all tokens belonging to a specified Organization or\n   * Project.\n   *\n   * @param request - The request {@link ListTokensRequest}\n   * @returns A Promise of ListTokensResponse\n   */\n  listTokens = (request = {}) => enrichForPagination('tokens', this.pageOfListTokens, request);\n\n  /**\n   * Delete a token. Delete a token with a specified ID.\n   *\n   * @param request - The request {@link DeleteTokenRequest}\n   * @returns A Promise of Token\n   */\n  deleteToken = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/containers/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens/${validatePathParam('tokenId', request.tokenId)}`\n  }, unmarshalToken$1);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$h = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$k,\n  CONTAINER_TRANSIENT_STATUSES: CONTAINER_TRANSIENT_STATUSES,\n  CRON_TRANSIENT_STATUSES: CRON_TRANSIENT_STATUSES$1,\n  DOMAIN_TRANSIENT_STATUSES: DOMAIN_TRANSIENT_STATUSES$3,\n  NAMESPACE_TRANSIENT_STATUSES: NAMESPACE_TRANSIENT_STATUSES$2,\n  TOKEN_TRANSIENT_STATUSES: TOKEN_TRANSIENT_STATUSES$1\n});\n\nvar index$m = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1beta1: index_gen$h\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link DNSZoneStatus}. */\nconst DNS_ZONE_TRANSIENT_STATUSES = ['pending'];\n\n/** Lists transient statutes of the enum {@link DomainFeatureStatus}. */\nconst DOMAIN_FEATURE_TRANSIENT_STATUSES = ['enabling', 'disabling'];\n\n/**\n * Lists transient statutes of the enum\n * {@link DomainRegistrationStatusTransferStatus}.\n */\nconst DOMAIN_REGISTRATION_STATUS_TRANSFER_TRANSIENT_STATUSES = ['pending', 'processing'];\n\n/** Lists transient statutes of the enum {@link DomainStatus}. */\nconst DOMAIN_TRANSIENT_STATUSES$2 = ['creating', 'renewing', 'xfering', 'expiring', 'updating', 'checking', 'deleting'];\n\n/** Lists transient statutes of the enum {@link HostStatus}. */\nconst HOST_TRANSIENT_STATUSES = ['updating', 'deleting'];\n\n/** Lists transient statutes of the enum {@link SSLCertificateStatus}. */\nconst SSL_CERTIFICATE_TRANSIENT_STATUSES = ['pending'];\n\n/** Lists transient statutes of the enum {@link TaskStatus}. */\nconst TASK_TRANSIENT_STATUSES$1 = ['pending'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalDomainRecordGeoIPConfigMatch = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecordGeoIPConfigMatch' failed as data isn't a dictionary.`);\n  }\n  return {\n    continents: data.continents,\n    countries: data.countries,\n    data: data.data\n  };\n};\nconst unmarshalDomainRecordViewConfigView = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecordViewConfigView' failed as data isn't a dictionary.`);\n  }\n  return {\n    data: data.data,\n    subnet: data.subnet\n  };\n};\nconst unmarshalDomainRecordWeightedConfigWeightedIP = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecordWeightedConfigWeightedIP' failed as data isn't a dictionary.`);\n  }\n  return {\n    ip: data.ip,\n    weight: data.weight\n  };\n};\nconst unmarshalContactExtensionFRAssociationInfo = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionFRAssociationInfo' failed as data isn't a dictionary.`);\n  }\n  return {\n    publicationJo: unmarshalDate(data.publication_jo),\n    publicationJoPage: data.publication_jo_page\n  };\n};\nconst unmarshalContactExtensionFRCodeAuthAfnicInfo = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionFRCodeAuthAfnicInfo' failed as data isn't a dictionary.`);\n  }\n  return {\n    codeAuthAfnic: data.code_auth_afnic\n  };\n};\nconst unmarshalContactExtensionFRDunsInfo = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionFRDunsInfo' failed as data isn't a dictionary.`);\n  }\n  return {\n    dunsId: data.duns_id,\n    localId: data.local_id\n  };\n};\nconst unmarshalContactExtensionFRIndividualInfo = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionFRIndividualInfo' failed as data isn't a dictionary.`);\n  }\n  return {\n    whoisOptIn: data.whois_opt_in\n  };\n};\nconst unmarshalContactExtensionFRTrademarkInfo = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionFRTrademarkInfo' failed as data isn't a dictionary.`);\n  }\n  return {\n    trademarkInpi: data.trademark_inpi\n  };\n};\nconst unmarshalDSRecordPublicKey = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DSRecordPublicKey' failed as data isn't a dictionary.`);\n  }\n  return {\n    key: data.key\n  };\n};\nconst unmarshalDomainRecordGeoIPConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecordGeoIPConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    default: data.default,\n    matches: unmarshalArrayOfObject(data.matches, unmarshalDomainRecordGeoIPConfigMatch)\n  };\n};\nconst unmarshalDomainRecordHTTPServiceConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecordHTTPServiceConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    ips: data.ips,\n    mustContain: data.must_contain,\n    strategy: data.strategy,\n    url: data.url,\n    userAgent: data.user_agent\n  };\n};\nconst unmarshalDomainRecordViewConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecordViewConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    views: unmarshalArrayOfObject(data.views, unmarshalDomainRecordViewConfigView)\n  };\n};\nconst unmarshalDomainRecordWeightedConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecordWeightedConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    weightedIps: unmarshalArrayOfObject(data.weighted_ips, unmarshalDomainRecordWeightedConfigWeightedIP)\n  };\n};\nconst unmarshalContactExtensionEU = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionEU' failed as data isn't a dictionary.`);\n  }\n  return {\n    europeanCitizenship: data.european_citizenship\n  };\n};\nconst unmarshalContactExtensionFR = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionFR' failed as data isn't a dictionary.`);\n  }\n  return {\n    associationInfo: data.association_info ? unmarshalContactExtensionFRAssociationInfo(data.association_info) : undefined,\n    codeAuthAfnicInfo: data.code_auth_afnic_info ? unmarshalContactExtensionFRCodeAuthAfnicInfo(data.code_auth_afnic_info) : undefined,\n    dunsInfo: data.duns_info ? unmarshalContactExtensionFRDunsInfo(data.duns_info) : undefined,\n    individualInfo: data.individual_info ? unmarshalContactExtensionFRIndividualInfo(data.individual_info) : undefined,\n    mode: data.mode,\n    trademarkInfo: data.trademark_info ? unmarshalContactExtensionFRTrademarkInfo(data.trademark_info) : undefined\n  };\n};\nconst unmarshalContactExtensionNL = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactExtensionNL' failed as data isn't a dictionary.`);\n  }\n  return {\n    legalForm: data.legal_form,\n    legalFormRegistrationNumber: data.legal_form_registration_number\n  };\n};\nconst unmarshalContactQuestion = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactQuestion' failed as data isn't a dictionary.`);\n  }\n  return {\n    answer: data.answer,\n    question: data.question\n  };\n};\nconst unmarshalDSRecordDigest = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DSRecordDigest' failed as data isn't a dictionary.`);\n  }\n  return {\n    digest: data.digest,\n    publicKey: data.public_key ? unmarshalDSRecordPublicKey(data.public_key) : undefined,\n    type: data.type\n  };\n};\nconst unmarshalDomainRecord = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRecord' failed as data isn't a dictionary.`);\n  }\n  return {\n    comment: data.comment,\n    data: data.data,\n    geoIpConfig: data.geo_ip_config ? unmarshalDomainRecordGeoIPConfig(data.geo_ip_config) : undefined,\n    httpServiceConfig: data.http_service_config ? unmarshalDomainRecordHTTPServiceConfig(data.http_service_config) : undefined,\n    id: data.id,\n    name: data.name,\n    priority: data.priority,\n    ttl: data.ttl,\n    type: data.type,\n    viewConfig: data.view_config ? unmarshalDomainRecordViewConfig(data.view_config) : undefined,\n    weightedConfig: data.weighted_config ? unmarshalDomainRecordWeightedConfig(data.weighted_config) : undefined\n  };\n};\nconst unmarshalRecordIdentifier = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RecordIdentifier' failed as data isn't a dictionary.`);\n  }\n  return {\n    data: data.data,\n    name: data.name,\n    ttl: data.ttl,\n    type: data.type\n  };\n};\nconst unmarshalTldOffer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'TldOffer' failed as data isn't a dictionary.`);\n  }\n  return {\n    action: data.action,\n    operationPath: data.operation_path,\n    price: data.price ? unmarshalMoney(data.price) : undefined\n  };\n};\nconst unmarshalContact = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Contact' failed as data isn't a dictionary.`);\n  }\n  return {\n    addressLine1: data.address_line_1,\n    addressLine2: data.address_line_2,\n    city: data.city,\n    companyIdentificationCode: data.company_identification_code,\n    companyName: data.company_name,\n    country: data.country,\n    email: data.email,\n    emailAlt: data.email_alt,\n    emailStatus: data.email_status,\n    extensionEu: data.extension_eu ? unmarshalContactExtensionEU(data.extension_eu) : undefined,\n    extensionFr: data.extension_fr ? unmarshalContactExtensionFR(data.extension_fr) : undefined,\n    extensionNl: data.extension_nl ? unmarshalContactExtensionNL(data.extension_nl) : undefined,\n    faxNumber: data.fax_number,\n    firstname: data.firstname,\n    id: data.id,\n    lang: data.lang,\n    lastname: data.lastname,\n    legalForm: data.legal_form,\n    phoneNumber: data.phone_number,\n    questions: unmarshalArrayOfObject(data.questions, unmarshalContactQuestion, false),\n    resale: data.resale,\n    state: data.state,\n    vatIdentificationCode: data.vat_identification_code,\n    whoisOptIn: data.whois_opt_in,\n    zip: data.zip\n  };\n};\nconst unmarshalContactRolesRoles = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactRolesRoles' failed as data isn't a dictionary.`);\n  }\n  return {\n    isAdministrative: data.is_administrative,\n    isOwner: data.is_owner,\n    isTechnical: data.is_technical\n  };\n};\nconst unmarshalDSRecord = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DSRecord' failed as data isn't a dictionary.`);\n  }\n  return {\n    algorithm: data.algorithm,\n    digest: data.digest ? unmarshalDSRecordDigest(data.digest) : undefined,\n    keyId: data.key_id,\n    publicKey: data.public_key ? unmarshalDSRecordPublicKey(data.public_key) : undefined\n  };\n};\nconst unmarshalDomainRegistrationStatusExternalDomain = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRegistrationStatusExternalDomain' failed as data isn't a dictionary.`);\n  }\n  return {\n    validationToken: data.validation_token\n  };\n};\nconst unmarshalDomainRegistrationStatusTransfer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainRegistrationStatusTransfer' failed as data isn't a dictionary.`);\n  }\n  return {\n    status: data.status,\n    voteCurrentOwner: data.vote_current_owner,\n    voteNewOwner: data.vote_new_owner\n  };\n};\nconst unmarshalRecordChangeAdd = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RecordChangeAdd' failed as data isn't a dictionary.`);\n  }\n  return {\n    records: unmarshalArrayOfObject(data.records, unmarshalDomainRecord)\n  };\n};\nconst unmarshalRecordChangeClear = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RecordChangeClear' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalRecordChangeDelete = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RecordChangeDelete' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    idFields: data.id_fields ? unmarshalRecordIdentifier(data.id_fields) : undefined\n  };\n};\nconst unmarshalRecordChangeSet = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RecordChangeSet' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    idFields: data.id_fields ? unmarshalRecordIdentifier(data.id_fields) : undefined,\n    records: unmarshalArrayOfObject(data.records, unmarshalDomainRecord)\n  };\n};\nconst unmarshalTld = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Tld' failed as data isn't a dictionary.`);\n  }\n  return {\n    dnssecSupport: data.dnssec_support,\n    durationInYearsMax: data.duration_in_years_max,\n    durationInYearsMin: data.duration_in_years_min,\n    idnSupport: data.idn_support,\n    name: data.name,\n    offers: unmarshalMapOfObject(data.offers, unmarshalTldOffer),\n    specifications: data.specifications\n  };\n};\nconst unmarshalAvailableDomain = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AvailableDomain' failed as data isn't a dictionary.`);\n  }\n  return {\n    available: data.available,\n    domain: data.domain,\n    tld: data.tld ? unmarshalTld(data.tld) : undefined\n  };\n};\nconst unmarshalCheckContactsCompatibilityResponseContactCheckResult = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CheckContactsCompatibilityResponseContactCheckResult' failed as data isn't a dictionary.`);\n  }\n  return {\n    compatible: data.compatible,\n    errorMessage: data.error_message\n  };\n};\nconst unmarshalContactRoles = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ContactRoles' failed as data isn't a dictionary.`);\n  }\n  return {\n    contact: data.contact ? unmarshalContact(data.contact) : undefined,\n    roles: unmarshalMapOfObject(data.roles, unmarshalContactRolesRoles)\n  };\n};\nconst unmarshalDNSZone = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DNSZone' failed as data isn't a dictionary.`);\n  }\n  return {\n    domain: data.domain,\n    message: data.message,\n    ns: data.ns,\n    nsDefault: data.ns_default,\n    nsMaster: data.ns_master,\n    projectId: data.project_id,\n    status: data.status,\n    subdomain: data.subdomain,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalDNSZoneVersion = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DNSZoneVersion' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id\n  };\n};\nconst unmarshalDomainDNSSEC = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainDNSSEC' failed as data isn't a dictionary.`);\n  }\n  return {\n    dsRecords: unmarshalArrayOfObject(data.ds_records, unmarshalDSRecord),\n    status: data.status\n  };\n};\nconst unmarshalDomainSummary = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainSummary' failed as data isn't a dictionary.`);\n  }\n  return {\n    autoRenewStatus: data.auto_renew_status,\n    dnssecStatus: data.dnssec_status,\n    domain: data.domain,\n    eppCode: data.epp_code,\n    expiredAt: unmarshalDate(data.expired_at),\n    externalDomainRegistrationStatus: data.external_domain_registration_status ? unmarshalDomainRegistrationStatusExternalDomain(data.external_domain_registration_status) : undefined,\n    isExternal: data.is_external,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    registrar: data.registrar,\n    status: data.status,\n    transferRegistrationStatus: data.transfer_registration_status ? unmarshalDomainRegistrationStatusTransfer(data.transfer_registration_status) : undefined,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalHost = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Host' failed as data isn't a dictionary.`);\n  }\n  return {\n    domain: data.domain,\n    ips: data.ips,\n    name: data.name,\n    status: data.status\n  };\n};\nconst unmarshalNameserver$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Nameserver' failed as data isn't a dictionary.`);\n  }\n  return {\n    ip: data.ip,\n    name: data.name\n  };\n};\nconst unmarshalRecordChange = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RecordChange' failed as data isn't a dictionary.`);\n  }\n  return {\n    add: data.add ? unmarshalRecordChangeAdd(data.add) : undefined,\n    clear: data.clear ? unmarshalRecordChangeClear(data.clear) : undefined,\n    delete: data.delete ? unmarshalRecordChangeDelete(data.delete) : undefined,\n    set: data.set ? unmarshalRecordChangeSet(data.set) : undefined\n  };\n};\nconst unmarshalRenewableDomain = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RenewableDomain' failed as data isn't a dictionary.`);\n  }\n  return {\n    domain: data.domain,\n    estimatedDeleteAt: unmarshalDate(data.estimated_delete_at),\n    expiredAt: unmarshalDate(data.expired_at),\n    limitRedemptionAt: unmarshalDate(data.limit_redemption_at),\n    limitRenewAt: unmarshalDate(data.limit_renew_at),\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    renewableDurationInYears: data.renewable_duration_in_years,\n    status: data.status,\n    tld: data.tld ? unmarshalTld(data.tld) : undefined\n  };\n};\nconst unmarshalSSLCertificate = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SSLCertificate' failed as data isn't a dictionary.`);\n  }\n  return {\n    alternativeDnsZones: data.alternative_dns_zones,\n    certificateChain: data.certificate_chain,\n    createdAt: unmarshalDate(data.created_at),\n    dnsZone: data.dns_zone,\n    expiredAt: unmarshalDate(data.expired_at),\n    privateKey: data.private_key,\n    status: data.status\n  };\n};\nconst unmarshalTask$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Task' failed as data isn't a dictionary.`);\n  }\n  return {\n    domain: data.domain,\n    id: data.id,\n    message: data.message,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    startedAt: unmarshalDate(data.started_at),\n    status: data.status,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalCheckContactsCompatibilityResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CheckContactsCompatibilityResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    administrativeCheckResult: data.administrative_check_result ? unmarshalCheckContactsCompatibilityResponseContactCheckResult(data.administrative_check_result) : undefined,\n    compatible: data.compatible,\n    ownerCheckResult: data.owner_check_result ? unmarshalCheckContactsCompatibilityResponseContactCheckResult(data.owner_check_result) : undefined,\n    technicalCheckResult: data.technical_check_result ? unmarshalCheckContactsCompatibilityResponseContactCheckResult(data.technical_check_result) : undefined\n  };\n};\nconst unmarshalClearDNSZoneRecordsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClearDNSZoneRecordsResponse' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalDeleteDNSZoneResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DeleteDNSZoneResponse' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalDeleteExternalDomainResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DeleteExternalDomainResponse' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalDeleteSSLCertificateResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DeleteSSLCertificateResponse' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalDomain$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Domain' failed as data isn't a dictionary.`);\n  }\n  return {\n    administrativeContact: data.administrative_contact ? unmarshalContact(data.administrative_contact) : undefined,\n    autoRenewStatus: data.auto_renew_status,\n    dnssec: data.dnssec ? unmarshalDomainDNSSEC(data.dnssec) : undefined,\n    dnsZones: unmarshalArrayOfObject(data.dns_zones, unmarshalDNSZone),\n    domain: data.domain,\n    eppCode: data.epp_code,\n    expiredAt: unmarshalDate(data.expired_at),\n    externalDomainRegistrationStatus: data.external_domain_registration_status ? unmarshalDomainRegistrationStatusExternalDomain(data.external_domain_registration_status) : undefined,\n    isExternal: data.is_external,\n    organizationId: data.organization_id,\n    ownerContact: data.owner_contact ? unmarshalContact(data.owner_contact) : undefined,\n    projectId: data.project_id,\n    registrar: data.registrar,\n    status: data.status,\n    technicalContact: data.technical_contact ? unmarshalContact(data.technical_contact) : undefined,\n    tld: data.tld ? unmarshalTld(data.tld) : undefined,\n    transferRegistrationStatus: data.transfer_registration_status ? unmarshalDomainRegistrationStatusTransfer(data.transfer_registration_status) : undefined,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalGetDNSZoneTsigKeyResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetDNSZoneTsigKeyResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    algorithm: data.algorithm,\n    key: data.key,\n    name: data.name\n  };\n};\nconst unmarshalGetDNSZoneVersionDiffResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetDNSZoneVersionDiffResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    changes: unmarshalArrayOfObject(data.changes, unmarshalRecordChange)\n  };\n};\nconst unmarshalGetDomainAuthCodeResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetDomainAuthCodeResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    authCode: data.auth_code\n  };\n};\nconst unmarshalImportProviderDNSZoneResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ImportProviderDNSZoneResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    records: unmarshalArrayOfObject(data.records, unmarshalDomainRecord)\n  };\n};\nconst unmarshalImportRawDNSZoneResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ImportRawDNSZoneResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    records: unmarshalArrayOfObject(data.records, unmarshalDomainRecord)\n  };\n};\nconst unmarshalListContactsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListContactsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    contacts: unmarshalArrayOfObject(data.contacts, unmarshalContactRoles),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDNSZoneNameserversResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDNSZoneNameserversResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ns: unmarshalArrayOfObject(data.ns, unmarshalNameserver$1)\n  };\n};\nconst unmarshalListDNSZoneRecordsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDNSZoneRecordsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    records: unmarshalArrayOfObject(data.records, unmarshalDomainRecord),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDNSZoneVersionRecordsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDNSZoneVersionRecordsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    records: unmarshalArrayOfObject(data.records, unmarshalDomainRecord),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDNSZoneVersionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDNSZoneVersionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    versions: unmarshalArrayOfObject(data.versions, unmarshalDNSZoneVersion)\n  };\n};\nconst unmarshalListDNSZonesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDNSZonesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    dnsZones: unmarshalArrayOfObject(data.dns_zones, unmarshalDNSZone),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDomainHostsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDomainHostsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    hosts: unmarshalArrayOfObject(data.hosts, unmarshalHost),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDomainsResponse$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    domains: unmarshalArrayOfObject(data.domains, unmarshalDomainSummary),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListRenewableDomainsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListRenewableDomainsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    domains: unmarshalArrayOfObject(data.domains, unmarshalRenewableDomain),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSSLCertificatesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSSLCertificatesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    certificates: unmarshalArrayOfObject(data.certificates, unmarshalSSLCertificate),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListTasksResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTasksResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    tasks: unmarshalArrayOfObject(data.tasks, unmarshalTask$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalOrderResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'OrderResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    domains: data.domains,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    taskId: data.task_id\n  };\n};\nconst unmarshalRefreshDNSZoneResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RefreshDNSZoneResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    dnsZones: unmarshalArrayOfObject(data.dns_zones, unmarshalDNSZone)\n  };\n};\nconst unmarshalRegisterExternalDomainResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RegisterExternalDomainResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    domain: data.domain,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    validationToken: data.validation_token\n  };\n};\nconst unmarshalRestoreDNSZoneVersionResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RestoreDNSZoneVersionResponse' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalSearchAvailableDomainsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SearchAvailableDomainsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    availableDomains: unmarshalArrayOfObject(data.available_domains, unmarshalAvailableDomain)\n  };\n};\nconst unmarshalUpdateDNSZoneNameserversResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpdateDNSZoneNameserversResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ns: unmarshalArrayOfObject(data.ns, unmarshalNameserver$1)\n  };\n};\nconst unmarshalUpdateDNSZoneRecordsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpdateDNSZoneRecordsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    records: unmarshalArrayOfObject(data.records, unmarshalDomainRecord)\n  };\n};\nconst marshalDomainRecordGeoIPConfigMatch = (request, defaults) => ({\n  continents: request.continents,\n  countries: request.countries,\n  data: request.data\n});\nconst marshalDomainRecordViewConfigView = (request, defaults) => ({\n  data: request.data,\n  subnet: request.subnet\n});\nconst marshalDomainRecordWeightedConfigWeightedIP = (request, defaults) => ({\n  ip: request.ip,\n  weight: request.weight\n});\nconst marshalDomainRecordGeoIPConfig = (request, defaults) => ({\n  default: request.default,\n  matches: request.matches.map(elt => marshalDomainRecordGeoIPConfigMatch(elt))\n});\nconst marshalDomainRecordHTTPServiceConfig = (request, defaults) => ({\n  ips: request.ips,\n  must_contain: request.mustContain,\n  strategy: request.strategy,\n  url: request.url,\n  user_agent: request.userAgent\n});\nconst marshalDomainRecordViewConfig = (request, defaults) => ({\n  views: request.views.map(elt => marshalDomainRecordViewConfigView(elt))\n});\nconst marshalDomainRecordWeightedConfig = (request, defaults) => ({\n  weighted_ips: request.weightedIps.map(elt => marshalDomainRecordWeightedConfigWeightedIP(elt))\n});\nconst marshalContactExtensionFRAssociationInfo = (request, defaults) => ({\n  publication_jo: request.publicationJo,\n  publication_jo_page: request.publicationJoPage\n});\nconst marshalContactExtensionFRCodeAuthAfnicInfo = (request, defaults) => ({\n  code_auth_afnic: request.codeAuthAfnic\n});\nconst marshalContactExtensionFRDunsInfo = (request, defaults) => ({\n  duns_id: request.dunsId,\n  local_id: request.localId\n});\nconst marshalContactExtensionFRIndividualInfo = (request, defaults) => ({\n  whois_opt_in: request.whoisOptIn\n});\nconst marshalContactExtensionFRTrademarkInfo = (request, defaults) => ({\n  trademark_inpi: request.trademarkInpi\n});\nconst marshalDSRecordPublicKey = (request, defaults) => ({\n  key: request.key\n});\nconst marshalDomainRecord = (request, defaults) => ({\n  comment: request.comment,\n  data: request.data,\n  id: request.id,\n  name: request.name,\n  priority: request.priority,\n  ttl: request.ttl,\n  type: request.type,\n  ...resolveOneOf([{\n    param: 'geo_ip_config',\n    value: request.geoIpConfig ? marshalDomainRecordGeoIPConfig(request.geoIpConfig) : undefined\n  }, {\n    param: 'http_service_config',\n    value: request.httpServiceConfig ? marshalDomainRecordHTTPServiceConfig(request.httpServiceConfig) : undefined\n  }, {\n    param: 'weighted_config',\n    value: request.weightedConfig ? marshalDomainRecordWeightedConfig(request.weightedConfig) : undefined\n  }, {\n    param: 'view_config',\n    value: request.viewConfig ? marshalDomainRecordViewConfig(request.viewConfig) : undefined\n  }])\n});\nconst marshalRecordIdentifier = (request, defaults) => ({\n  data: request.data,\n  name: request.name,\n  ttl: request.ttl,\n  type: request.type\n});\nconst marshalContactExtensionEU = (request, defaults) => ({\n  european_citizenship: request.europeanCitizenship\n});\nconst marshalContactExtensionFR = (request, defaults) => ({\n  mode: request.mode,\n  ...resolveOneOf([{\n    param: 'individual_info',\n    value: request.individualInfo ? marshalContactExtensionFRIndividualInfo(request.individualInfo) : undefined\n  }, {\n    param: 'duns_info',\n    value: request.dunsInfo ? marshalContactExtensionFRDunsInfo(request.dunsInfo) : undefined\n  }, {\n    param: 'association_info',\n    value: request.associationInfo ? marshalContactExtensionFRAssociationInfo(request.associationInfo) : undefined\n  }, {\n    param: 'trademark_info',\n    value: request.trademarkInfo ? marshalContactExtensionFRTrademarkInfo(request.trademarkInfo) : undefined\n  }, {\n    param: 'code_auth_afnic_info',\n    value: request.codeAuthAfnicInfo ? marshalContactExtensionFRCodeAuthAfnicInfo(request.codeAuthAfnicInfo) : undefined\n  }])\n});\nconst marshalContactExtensionNL = (request, defaults) => ({\n  legal_form: request.legalForm,\n  legal_form_registration_number: request.legalFormRegistrationNumber\n});\nconst marshalContactQuestion = (request, defaults) => ({\n  answer: request.answer,\n  question: request.question\n});\nconst marshalDSRecordDigest = (request, defaults) => ({\n  digest: request.digest,\n  public_key: request.publicKey ? marshalDSRecordPublicKey(request.publicKey) : undefined,\n  type: request.type\n});\nconst marshalImportRawDNSZoneRequestTsigKey = (request, defaults) => ({\n  algorithm: request.algorithm,\n  key: request.key,\n  name: request.name\n});\nconst marshalRecordChangeAdd = (request, defaults) => ({\n  records: request.records.map(elt => marshalDomainRecord(elt))\n});\nconst marshalRecordChangeClear = (request, defaults) => ({});\nconst marshalRecordChangeDelete = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'id',\n    value: request.id\n  }, {\n    param: 'id_fields',\n    value: request.idFields ? marshalRecordIdentifier(request.idFields) : undefined\n  }])\n});\nconst marshalRecordChangeSet = (request, defaults) => ({\n  records: request.records.map(elt => marshalDomainRecord(elt)),\n  ...resolveOneOf([{\n    param: 'id',\n    value: request.id\n  }, {\n    param: 'id_fields',\n    value: request.idFields ? marshalRecordIdentifier(request.idFields) : undefined\n  }])\n});\nconst marshalDSRecord = (request, defaults) => ({\n  algorithm: request.algorithm,\n  key_id: request.keyId,\n  ...resolveOneOf([{\n    param: 'digest',\n    value: request.digest ? marshalDSRecordDigest(request.digest) : undefined\n  }, {\n    param: 'public_key',\n    value: request.publicKey ? marshalDSRecordPublicKey(request.publicKey) : undefined\n  }])\n});\nconst marshalImportProviderDNSZoneRequestOnlineV1 = (request, defaults) => ({\n  token: request.token\n});\nconst marshalImportRawDNSZoneRequestAXFRSource = (request, defaults) => ({\n  name_server: request.nameServer,\n  tsig_key: request.tsigKey ? marshalImportRawDNSZoneRequestTsigKey(request.tsigKey) : undefined\n});\nconst marshalImportRawDNSZoneRequestBindSource = (request, defaults) => ({\n  content: request.content\n});\nconst marshalNameserver = (request, defaults) => ({\n  ip: request.ip,\n  name: request.name\n});\nconst marshalNewContact = (request, defaults) => ({\n  address_line_1: request.addressLine1,\n  address_line_2: request.addressLine2,\n  city: request.city,\n  company_identification_code: request.companyIdentificationCode,\n  company_name: request.companyName,\n  country: request.country,\n  email: request.email,\n  email_alt: request.emailAlt,\n  extension_eu: request.extensionEu ? marshalContactExtensionEU(request.extensionEu) : undefined,\n  extension_fr: request.extensionFr ? marshalContactExtensionFR(request.extensionFr) : undefined,\n  extension_nl: request.extensionNl ? marshalContactExtensionNL(request.extensionNl) : undefined,\n  fax_number: request.faxNumber,\n  firstname: request.firstname,\n  lang: request.lang,\n  lastname: request.lastname,\n  legal_form: request.legalForm,\n  phone_number: request.phoneNumber,\n  questions: request.questions ? request.questions.map(elt => marshalContactQuestion(elt)) : undefined,\n  resale: request.resale,\n  state: request.state,\n  vat_identification_code: request.vatIdentificationCode,\n  whois_opt_in: request.whoisOptIn,\n  zip: request.zip\n});\nconst marshalRecordChange = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'add',\n    value: request.add ? marshalRecordChangeAdd(request.add) : undefined\n  }, {\n    param: 'set',\n    value: request.set ? marshalRecordChangeSet(request.set) : undefined\n  }, {\n    param: 'delete',\n    value: request.delete ? marshalRecordChangeDelete(request.delete) : undefined\n  }, {\n    param: 'clear',\n    value: request.clear ? marshalRecordChangeClear(request.clear) : undefined\n  }])\n});\nconst marshalTransferInDomainRequestTransferRequest = (request, defaults) => ({\n  auth_code: request.authCode,\n  domain: request.domain\n});\nconst marshalUpdateContactRequestQuestion = (request, defaults) => ({\n  answer: request.answer,\n  question: request.question\n});\nconst marshalCloneDNSZoneRequest = (request, defaults) => ({\n  dest_dns_zone: request.destDnsZone,\n  overwrite: request.overwrite,\n  project_id: request.projectId\n});\nconst marshalCreateDNSZoneRequest = (request, defaults) => ({\n  domain: request.domain,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  subdomain: request.subdomain\n});\nconst marshalCreateSSLCertificateRequest = (request, defaults) => ({\n  alternative_dns_zones: request.alternativeDnsZones,\n  dns_zone: request.dnsZone\n});\nconst marshalImportProviderDNSZoneRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'online_v1',\n    value: request.onlineV1 ? marshalImportProviderDNSZoneRequestOnlineV1(request.onlineV1) : undefined\n  }])\n});\nconst marshalImportRawDNSZoneRequest = (request, defaults) => ({\n  content: request.content,\n  format: request.format,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  ...resolveOneOf([{\n    param: 'bind_source',\n    value: request.bindSource ? marshalImportRawDNSZoneRequestBindSource(request.bindSource) : undefined\n  }, {\n    param: 'axfr_source',\n    value: request.axfrSource ? marshalImportRawDNSZoneRequestAXFRSource(request.axfrSource) : undefined\n  }])\n});\nconst marshalRefreshDNSZoneRequest = (request, defaults) => ({\n  recreate_dns_zone: request.recreateDnsZone,\n  recreate_sub_dns_zone: request.recreateSubDnsZone\n});\nconst marshalRegistrarApiBuyDomainsRequest = (request, defaults) => ({\n  domains: request.domains,\n  duration_in_years: request.durationInYears,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  ...resolveOneOf([{\n    param: 'administrative_contact_id',\n    value: request.administrativeContactId\n  }, {\n    param: 'administrative_contact',\n    value: request.administrativeContact ? marshalNewContact(request.administrativeContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'owner_contact_id',\n    value: request.ownerContactId\n  }, {\n    param: 'owner_contact',\n    value: request.ownerContact ? marshalNewContact(request.ownerContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'technical_contact_id',\n    value: request.technicalContactId\n  }, {\n    param: 'technical_contact',\n    value: request.technicalContact ? marshalNewContact(request.technicalContact) : undefined\n  }])\n});\nconst marshalRegistrarApiCheckContactsCompatibilityRequest = (request, defaults) => ({\n  domains: request.domains,\n  tlds: request.tlds,\n  ...resolveOneOf([{\n    param: 'administrative_contact_id',\n    value: request.administrativeContactId\n  }, {\n    param: 'administrative_contact',\n    value: request.administrativeContact ? marshalNewContact(request.administrativeContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'owner_contact_id',\n    value: request.ownerContactId\n  }, {\n    param: 'owner_contact',\n    value: request.ownerContact ? marshalNewContact(request.ownerContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'technical_contact_id',\n    value: request.technicalContactId\n  }, {\n    param: 'technical_contact',\n    value: request.technicalContact ? marshalNewContact(request.technicalContact) : undefined\n  }])\n});\nconst marshalRegistrarApiCreateDomainHostRequest = (request, defaults) => ({\n  ips: request.ips,\n  name: request.name\n});\nconst marshalRegistrarApiEnableDomainDNSSECRequest = (request, defaults) => ({\n  ds_record: request.dsRecord ? marshalDSRecord(request.dsRecord) : undefined\n});\nconst marshalRegistrarApiRegisterExternalDomainRequest = (request, defaults) => ({\n  domain: request.domain,\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalRegistrarApiRenewDomainsRequest = (request, defaults) => ({\n  domains: request.domains,\n  duration_in_years: request.durationInYears,\n  force_late_renewal: request.forceLateRenewal\n});\nconst marshalRegistrarApiTradeDomainRequest = (request, defaults) => ({\n  project_id: request.projectId,\n  ...resolveOneOf([{\n    param: 'new_owner_contact_id',\n    value: request.newOwnerContactId\n  }, {\n    param: 'new_owner_contact',\n    value: request.newOwnerContact ? marshalNewContact(request.newOwnerContact) : undefined\n  }])\n});\nconst marshalRegistrarApiTransferInDomainRequest = (request, defaults) => ({\n  domains: request.domains.map(elt => marshalTransferInDomainRequestTransferRequest(elt)),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  ...resolveOneOf([{\n    param: 'administrative_contact_id',\n    value: request.administrativeContactId\n  }, {\n    param: 'administrative_contact',\n    value: request.administrativeContact ? marshalNewContact(request.administrativeContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'owner_contact_id',\n    value: request.ownerContactId\n  }, {\n    param: 'owner_contact',\n    value: request.ownerContact ? marshalNewContact(request.ownerContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'technical_contact_id',\n    value: request.technicalContactId\n  }, {\n    param: 'technical_contact',\n    value: request.technicalContact ? marshalNewContact(request.technicalContact) : undefined\n  }])\n});\nconst marshalRegistrarApiUpdateContactRequest = (request, defaults) => ({\n  address_line_1: request.addressLine1,\n  address_line_2: request.addressLine2,\n  city: request.city,\n  company_identification_code: request.companyIdentificationCode,\n  country: request.country,\n  email: request.email,\n  email_alt: request.emailAlt,\n  extension_eu: request.extensionEu ? marshalContactExtensionEU(request.extensionEu) : undefined,\n  extension_fr: request.extensionFr ? marshalContactExtensionFR(request.extensionFr) : undefined,\n  extension_nl: request.extensionNl ? marshalContactExtensionNL(request.extensionNl) : undefined,\n  fax_number: request.faxNumber,\n  lang: request.lang ?? 'unknown_language_code',\n  phone_number: request.phoneNumber,\n  questions: request.questions ? request.questions.map(elt => marshalUpdateContactRequestQuestion(elt)) : undefined,\n  resale: request.resale,\n  state: request.state,\n  vat_identification_code: request.vatIdentificationCode,\n  whois_opt_in: request.whoisOptIn,\n  zip: request.zip\n});\nconst marshalRegistrarApiUpdateDomainHostRequest = (request, defaults) => ({\n  ips: request.ips\n});\nconst marshalRegistrarApiUpdateDomainRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'administrative_contact_id',\n    value: request.administrativeContactId\n  }, {\n    param: 'administrative_contact',\n    value: request.administrativeContact ? marshalNewContact(request.administrativeContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'owner_contact_id',\n    value: request.ownerContactId\n  }, {\n    param: 'owner_contact',\n    value: request.ownerContact ? marshalNewContact(request.ownerContact) : undefined\n  }]),\n  ...resolveOneOf([{\n    param: 'technical_contact_id',\n    value: request.technicalContactId\n  }, {\n    param: 'technical_contact',\n    value: request.technicalContact ? marshalNewContact(request.technicalContact) : undefined\n  }])\n});\nconst marshalUpdateDNSZoneNameserversRequest = (request, defaults) => ({\n  ns: request.ns.map(elt => marshalNameserver(elt))\n});\nconst marshalUpdateDNSZoneRecordsRequest = (request, defaults) => ({\n  changes: request.changes.map(elt => marshalRecordChange(elt)),\n  disallow_new_zone_creation: request.disallowNewZoneCreation,\n  return_all_records: request.returnAllRecords,\n  serial: request.serial\n});\nconst marshalUpdateDNSZoneRequest = (request, defaults) => ({\n  new_dns_zone: request.newDnsZone,\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$h = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Domains and DNS API.\n *\n * Domains and DNS API. Manage your domains, DNS zones and records with the\n * Domains and DNS API.\n */\nlet API$j = class API extends API$q {\n  pageOfListDNSZones = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones`,\n    urlParams: urlParams(['dns_zone', request.dnsZone], ['domain', request.domain], ['order_by', request.orderBy ?? 'domain_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListDNSZonesResponse);\n\n  /**\n   * List DNS zones. Retrieve the list of DNS zones you can manage and filter\n   * DNS zones associated with specific domain names.\n   *\n   * @param request - The request {@link ListDNSZonesRequest}\n   * @returns A Promise of ListDNSZonesResponse\n   */\n  listDNSZones = request => enrichForPagination('dnsZones', this.pageOfListDNSZones, request);\n\n  /**\n   * Create a DNS zone. Create a new DNS zone specified by the domain name, the\n   * subdomain and the Project ID.\n   *\n   * @param request - The request {@link CreateDNSZoneRequest}\n   * @returns A Promise of DNSZone\n   */\n  createDNSZone = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDNSZoneRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/dns-zones`\n  }, unmarshalDNSZone);\n\n  /**\n   * Update a DNS zone. Update the name and/or the Organizations for a DNS zone.\n   *\n   * @param request - The request {@link UpdateDNSZoneRequest}\n   * @returns A Promise of DNSZone\n   */\n  updateDNSZone = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateDNSZoneRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'PATCH',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}`\n  }, unmarshalDNSZone);\n\n  /**\n   * Clone a DNS zone. Clone an existing DNS zone with all its records into a\n   * new DNS zone.\n   *\n   * @param request - The request {@link CloneDNSZoneRequest}\n   * @returns A Promise of DNSZone\n   */\n  cloneDNSZone = request => this.client.fetch({\n    body: JSON.stringify(marshalCloneDNSZoneRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/clone`\n  }, unmarshalDNSZone);\n\n  /**\n   * Delete a DNS zone. Delete a DNS zone and all its records.\n   *\n   * @param request - The request {@link DeleteDNSZoneRequest}\n   * @returns A Promise of DeleteDNSZoneResponse\n   */\n  deleteDNSZone = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}`,\n    urlParams: urlParams(['project_id', request.projectId ?? this.client.settings.defaultProjectId])\n  }, unmarshalDeleteDNSZoneResponse);\n  pageOfListDNSZoneRecords = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/records`,\n    urlParams: urlParams(['id', request.id], ['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['type', request.type ?? 'unknown'])\n  }, unmarshalListDNSZoneRecordsResponse);\n\n  /**\n   * List records within a DNS zone. Retrieve a list of DNS records within a DNS\n   * zone that has default name servers. You can filter records by type and\n   * name.\n   *\n   * @param request - The request {@link ListDNSZoneRecordsRequest}\n   * @returns A Promise of ListDNSZoneRecordsResponse\n   */\n  listDNSZoneRecords = request => enrichForPagination('records', this.pageOfListDNSZoneRecords, request);\n\n  /**\n   * Update records within a DNS zone. Update records within a DNS zone that has\n   * default name servers and perform several actions on your records.\n   *\n   * Actions include:\n   *\n   * - Add: allows you to add a new record or add a new IP to an existing A\n   *   record, for example\n   * - Set: allows you to edit a record or edit an IP from an existing A record,\n   *   for example\n   * - Delete: allows you to delete a record or delete an IP from an existing A\n   *   record, for example\n   * - Clear: allows you to delete all records from a DNS zone\n   *\n   * All edits will be versioned.\n   *\n   * @param request - The request {@link UpdateDNSZoneRecordsRequest}\n   * @returns A Promise of UpdateDNSZoneRecordsResponse\n   */\n  updateDNSZoneRecords = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateDNSZoneRecordsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'PATCH',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/records`\n  }, unmarshalUpdateDNSZoneRecordsResponse);\n\n  /**\n   * List name servers within a DNS zone. Retrieve a list of name servers within\n   * a DNS zone and their optional glue records.\n   *\n   * @param request - The request {@link ListDNSZoneNameserversRequest}\n   * @returns A Promise of ListDNSZoneNameserversResponse\n   */\n  listDNSZoneNameservers = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/nameservers`,\n    urlParams: urlParams(['project_id', request.projectId])\n  }, unmarshalListDNSZoneNameserversResponse);\n\n  /**\n   * Update name servers within a DNS zone. Update name servers within a DNS\n   * zone and set optional glue records.\n   *\n   * @param request - The request {@link UpdateDNSZoneNameserversRequest}\n   * @returns A Promise of UpdateDNSZoneNameserversResponse\n   */\n  updateDNSZoneNameservers = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateDNSZoneNameserversRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'PUT',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/nameservers`\n  }, unmarshalUpdateDNSZoneNameserversResponse);\n\n  /**\n   * Clear records within a DNS zone. Delete all records within a DNS zone that\n   * has default name servers.<br/> All edits will be versioned.\n   *\n   * @param request - The request {@link ClearDNSZoneRecordsRequest}\n   * @returns A Promise of ClearDNSZoneRecordsResponse\n   */\n  clearDNSZoneRecords = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/records`\n  }, unmarshalClearDNSZoneRecordsResponse);\n\n  /**\n   * Export a raw DNS zone. Export a DNS zone with default name servers, in a\n   * specific format.\n   *\n   * @param request - The request {@link ExportRawDNSZoneRequest}\n   * @returns A Promise of Blob\n   */\n  exportRawDNSZone = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/raw`,\n    urlParams: urlParams(['dl', 1], ['format', request.format ?? 'unknown_raw_format']),\n    responseType: 'blob'\n  });\n\n  /**\n   * Import a raw DNS zone. Import and replace the format of records from a\n   * given provider, with default name servers.\n   *\n   * @param request - The request {@link ImportRawDNSZoneRequest}\n   * @returns A Promise of ImportRawDNSZoneResponse\n   */\n  importRawDNSZone = request => this.client.fetch({\n    body: JSON.stringify(marshalImportRawDNSZoneRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/raw`\n  }, unmarshalImportRawDNSZoneResponse);\n\n  /**\n   * Import a DNS zone from another provider. Import and replace the format of\n   * records from a given provider, with default name servers.\n   *\n   * @param request - The request {@link ImportProviderDNSZoneRequest}\n   * @returns A Promise of ImportProviderDNSZoneResponse\n   */\n  importProviderDNSZone = request => this.client.fetch({\n    body: JSON.stringify(marshalImportProviderDNSZoneRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/import-provider`\n  }, unmarshalImportProviderDNSZoneResponse);\n\n  /**\n   * Refresh a DNS zone. Refresh an SOA DNS zone to reload the records in the\n   * DNS zone and update the SOA serial. You can recreate the given DNS zone and\n   * its sub DNS zone if needed.\n   *\n   * @param request - The request {@link RefreshDNSZoneRequest}\n   * @returns A Promise of RefreshDNSZoneResponse\n   */\n  refreshDNSZone = request => this.client.fetch({\n    body: JSON.stringify(marshalRefreshDNSZoneRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/refresh`\n  }, unmarshalRefreshDNSZoneResponse);\n  pageOfListDNSZoneVersions = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/versions`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListDNSZoneVersionsResponse);\n\n  /**\n   * List versions of a DNS zone. Retrieve a list of a DNS zone's versions.<br/>\n   * The maximum version count is 100. If the count reaches this limit, the\n   * oldest version will be deleted after each new modification.\n   *\n   * @param request - The request {@link ListDNSZoneVersionsRequest}\n   * @returns A Promise of ListDNSZoneVersionsResponse\n   */\n  listDNSZoneVersions = request => enrichForPagination('versions', this.pageOfListDNSZoneVersions, request);\n  pageOfListDNSZoneVersionRecords = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones/version/${validatePathParam('dnsZoneVersionId', request.dnsZoneVersionId)}`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListDNSZoneVersionRecordsResponse);\n\n  /**\n   * List records from a given version of a specific DNS zone. Retrieve a list\n   * of records from a specific DNS zone version.\n   *\n   * @param request - The request {@link ListDNSZoneVersionRecordsRequest}\n   * @returns A Promise of ListDNSZoneVersionRecordsResponse\n   */\n  listDNSZoneVersionRecords = request => enrichForPagination('records', this.pageOfListDNSZoneVersionRecords, request);\n\n  /**\n   * Access differences from a specific DNS zone version. Access a previous DNS\n   * zone version to see the differences from another specific version.\n   *\n   * @param request - The request {@link GetDNSZoneVersionDiffRequest}\n   * @returns A Promise of GetDNSZoneVersionDiffResponse\n   */\n  getDNSZoneVersionDiff = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones/version/${validatePathParam('dnsZoneVersionId', request.dnsZoneVersionId)}/diff`\n  }, unmarshalGetDNSZoneVersionDiffResponse);\n\n  /**\n   * Restore a DNS zone version. Restore and activate a version of a specific\n   * DNS zone.\n   *\n   * @param request - The request {@link RestoreDNSZoneVersionRequest}\n   * @returns A Promise of RestoreDNSZoneVersionResponse\n   */\n  restoreDNSZoneVersion = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/dns-zones/version/${validatePathParam('dnsZoneVersionId', request.dnsZoneVersionId)}/restore`\n  }, unmarshalRestoreDNSZoneVersionResponse);\n\n  /**\n   * Get a DNS zone's TLS certificate. Get the DNS zone's TLS certificate. If\n   * you do not have a certificate, the ouptut returns `no certificate found`.\n   *\n   * @param request - The request {@link GetSSLCertificateRequest}\n   * @returns A Promise of SSLCertificate\n   */\n  getSSLCertificate = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/ssl-certificates/${validatePathParam('dnsZone', request.dnsZone)}`\n  }, unmarshalSSLCertificate);\n\n  /**\n   * Waits for {@link SSLCertificate} to be in a final state.\n   *\n   * @param request - The request {@link GetSSLCertificateRequest}\n   * @param options - The waiting options\n   * @returns A Promise of SSLCertificate\n   */\n  waitForSSLCertificate = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!SSL_CERTIFICATE_TRANSIENT_STATUSES.includes(res.status))), this.getSSLCertificate, request, options);\n\n  /**\n   * Create or get the DNS zone's TLS certificate. Create a new TLS certificate\n   * or retrieve information about an existing TLS certificate.\n   *\n   * @param request - The request {@link CreateSSLCertificateRequest}\n   * @returns A Promise of SSLCertificate\n   */\n  createSSLCertificate = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSSLCertificateRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/ssl-certificates`\n  }, unmarshalSSLCertificate);\n  pageOfListSSLCertificates = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/ssl-certificates`,\n    urlParams: urlParams(['dns_zone', request.dnsZone], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListSSLCertificatesResponse);\n\n  /**\n   * List a user's TLS certificates. List all the TLS certificates a user has\n   * created, specified by the user's Project ID and the DNS zone.\n   *\n   * @param request - The request {@link ListSSLCertificatesRequest}\n   * @returns A Promise of ListSSLCertificatesResponse\n   */\n  listSSLCertificates = request => enrichForPagination('certificates', this.pageOfListSSLCertificates, request);\n\n  /**\n   * Delete a TLS certificate. Delete an existing TLS certificate specified by\n   * its DNS zone. Deleting a TLS certificate is permanent and cannot be\n   * undone.\n   *\n   * @param request - The request {@link DeleteSSLCertificateRequest}\n   * @returns A Promise of DeleteSSLCertificateResponse\n   */\n  deleteSSLCertificate = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/domain/v2beta1/ssl-certificates/${validatePathParam('dnsZone', request.dnsZone)}`\n  }, unmarshalDeleteSSLCertificateResponse);\n\n  /**\n   * Get the DNS zone's TSIG key. Retrieve information about the TSIG key of a\n   * given DNS zone to allow AXFR requests.\n   *\n   * @param request - The request {@link GetDNSZoneTsigKeyRequest}\n   * @returns A Promise of GetDNSZoneTsigKeyResponse\n   */\n  getDNSZoneTsigKey = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/tsig-key`\n  }, unmarshalGetDNSZoneTsigKeyResponse);\n\n  /**\n   * Delete the DNS zone's TSIG key. Delete an existing TSIG key specified by\n   * its DNS zone. Deleting a TSIG key is permanent and cannot be undone.\n   *\n   * @param request - The request {@link DeleteDNSZoneTsigKeyRequest}\n   */\n  deleteDNSZoneTsigKey = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/domain/v2beta1/dns-zones/${validatePathParam('dnsZone', request.dnsZone)}/tsig-key`\n  });\n};\n\n/**\n * Domains and DNS - Registrar API.\n *\n * Domains and DNS - Registrar API. Manage your domains and contacts.\n */\nclass RegistrarAPI extends API$q {\n  pageOfListTasks = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/tasks`,\n    urlParams: urlParams(['domain', request.domain], ['order_by', request.orderBy ?? 'domain_desc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['statuses', request.statuses], ['types', request.types])\n  }, unmarshalListTasksResponse);\n\n  /**\n   * List tasks. List all account tasks. You can filter the list by domain name.\n   *\n   * @param request - The request {@link RegistrarApiListTasksRequest}\n   * @returns A Promise of ListTasksResponse\n   */\n  listTasks = (request = {}) => enrichForPagination('tasks', this.pageOfListTasks, request);\n\n  /**\n   * Buy one or more domains. Request the registration of domain names. You can\n   * provide an already existing domain's contact or a new contact.\n   *\n   * @param request - The request {@link RegistrarApiBuyDomainsRequest}\n   * @returns A Promise of OrderResponse\n   */\n  buyDomains = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiBuyDomainsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/buy-domains`\n  }, unmarshalOrderResponse);\n\n  /**\n   * Renew one or more domains. Request the renewal of domain names.\n   *\n   * @param request - The request {@link RegistrarApiRenewDomainsRequest}\n   * @returns A Promise of OrderResponse\n   */\n  renewDomains = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiRenewDomainsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/renew-domains`\n  }, unmarshalOrderResponse);\n\n  /**\n   * Transfer a domain. Request the transfer from another registrar domain to\n   * Scaleway.\n   *\n   * @param request - The request {@link RegistrarApiTransferInDomainRequest}\n   * @returns A Promise of OrderResponse\n   */\n  transferInDomain = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiTransferInDomainRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/transfer-domains`\n  }, unmarshalOrderResponse);\n\n  /**\n   * Trade a domain contact. Request a trade for the contact owner.<br/> If an\n   * `organization_id` is given, the change is from the current Scaleway account\n   * to another Scaleway account.<br/> If no contact is given, the first contact\n   * of the other Scaleway account is taken.<br/> If the other Scaleway account\n   * has no contact. An error occurs.\n   *\n   * @param request - The request {@link RegistrarApiTradeDomainRequest}\n   * @returns A Promise of OrderResponse\n   */\n  tradeDomain = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiTradeDomainRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/trade`\n  }, unmarshalOrderResponse);\n\n  /**\n   * Register an external domain. Request the registration of an external domain\n   * name.\n   *\n   * @param request - The request\n   *   {@link RegistrarApiRegisterExternalDomainRequest}\n   * @returns A Promise of RegisterExternalDomainResponse\n   */\n  registerExternalDomain = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiRegisterExternalDomainRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/external-domains`\n  }, unmarshalRegisterExternalDomainResponse);\n\n  /**\n   * Delete an external domain. Delete an external domain name.\n   *\n   * @param request - The request {@link RegistrarApiDeleteExternalDomainRequest}\n   * @returns A Promise of DeleteExternalDomainResponse\n   */\n  deleteExternalDomain = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/domain/v2beta1/external-domains/${validatePathParam('domain', request.domain)}`\n  }, unmarshalDeleteExternalDomainResponse);\n\n  /**\n   * Check if contacts are compatible against a domain or a tld. Check if\n   * contacts are compatible against a domain or a tld. If not, it will return\n   * the information requiring a correction.\n   *\n   * @param request - The request\n   *   {@link RegistrarApiCheckContactsCompatibilityRequest}\n   * @returns A Promise of CheckContactsCompatibilityResponse\n   */\n  checkContactsCompatibility = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiCheckContactsCompatibilityRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/check-contacts-compatibility`\n  }, unmarshalCheckContactsCompatibilityResponse);\n  pageOfListContacts = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/contacts`,\n    urlParams: urlParams(['domain', request.domain], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListContactsResponse);\n\n  /**\n   * List contacts. Return a list of contacts with their domains and roles. You\n   * can filter the list by domain name.\n   *\n   * @param request - The request {@link RegistrarApiListContactsRequest}\n   * @returns A Promise of ListContactsResponse\n   */\n  listContacts = (request = {}) => enrichForPagination('contacts', this.pageOfListContacts, request);\n\n  /**\n   * Get a contact. Return a contact details retrieved from the registrar using\n   * a given contact ID.\n   *\n   * @param request - The request {@link RegistrarApiGetContactRequest}\n   * @returns A Promise of Contact\n   */\n  getContact = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/contacts/${validatePathParam('contactId', request.contactId)}`\n  }, unmarshalContact);\n\n  /**\n   * Update contact. You can edit the contact coordinates.\n   *\n   * @param request - The request {@link RegistrarApiUpdateContactRequest}\n   * @returns A Promise of Contact\n   */\n  updateContact = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiUpdateContactRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'PATCH',\n    path: `/domain/v2beta1/contacts/${validatePathParam('contactId', request.contactId)}`\n  }, unmarshalContact);\n  pageOfListDomains = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/domains`,\n    urlParams: urlParams(['domain', request.domain], ['is_external', request.isExternal], ['order_by', request.orderBy ?? 'domain_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['registrar', request.registrar], ['status', request.status ?? 'status_unknown'])\n  }, unmarshalListDomainsResponse$2);\n\n  /**\n   * List domains. Returns a list of domains owned by the user.\n   *\n   * @param request - The request {@link RegistrarApiListDomainsRequest}\n   * @returns A Promise of ListDomainsResponse\n   */\n  listDomains = (request = {}) => enrichForPagination('domains', this.pageOfListDomains, request);\n  pageOfListRenewableDomains = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/renewable-domains`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'domain_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListRenewableDomainsResponse);\n\n  /**\n   * List scaleway domains that can or not be renewed. Returns a list of domains\n   * owned by the user with a renew status and if renewable, the maximum renew\n   * duration in years.\n   *\n   * @param request - The request {@link RegistrarApiListRenewableDomainsRequest}\n   * @returns A Promise of ListRenewableDomainsResponse\n   */\n  listRenewableDomains = (request = {}) => enrichForPagination('domains', this.pageOfListRenewableDomains, request);\n\n  /**\n   * Get domain. Returns a the domain with more informations.\n   *\n   * @param request - The request {@link RegistrarApiGetDomainRequest}\n   * @returns A Promise of Domain\n   */\n  getDomain = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}`\n  }, unmarshalDomain$2);\n\n  /**\n   * Waits for {@link Domain} to be in a final state.\n   *\n   * @param request - The request {@link GetDomainRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Domain\n   */\n  waitForDomain = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!DOMAIN_TRANSIENT_STATUSES$2.includes(res.status))), this.getDomain, request, options);\n\n  /**\n   * Update a domain. Update the domain contacts or create a new one.<br/> If\n   * you add the same contact for multiple roles. Only one ID will be created\n   * and used for all of them.\n   *\n   * @param request - The request {@link RegistrarApiUpdateDomainRequest}\n   * @returns A Promise of Domain\n   */\n  updateDomain = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiUpdateDomainRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'PATCH',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}`\n  }, unmarshalDomain$2);\n\n  /**\n   * Lock domain transfer. Lock domain transfer. A locked domain transfer can't\n   * be transferred and the auth code can't be requested.\n   *\n   * @param request - The request {@link RegistrarApiLockDomainTransferRequest}\n   * @returns A Promise of Domain\n   */\n  lockDomainTransfer = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/lock-transfer`\n  }, unmarshalDomain$2);\n\n  /**\n   * Unlock domain transfer. Unlock domain transfer. An unlocked domain can be\n   * transferred and the auth code can be requested for this.\n   *\n   * @param request - The request {@link RegistrarApiUnlockDomainTransferRequest}\n   * @returns A Promise of Domain\n   */\n  unlockDomainTransfer = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/unlock-transfer`\n  }, unmarshalDomain$2);\n\n  /**\n   * Enable domain auto renew.\n   *\n   * @param request - The request\n   *   {@link RegistrarApiEnableDomainAutoRenewRequest}\n   * @returns A Promise of Domain\n   */\n  enableDomainAutoRenew = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/enable-auto-renew`\n  }, unmarshalDomain$2);\n\n  /**\n   * Disable domain auto renew.\n   *\n   * @param request - The request\n   *   {@link RegistrarApiDisableDomainAutoRenewRequest}\n   * @returns A Promise of Domain\n   */\n  disableDomainAutoRenew = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/disable-auto-renew`\n  }, unmarshalDomain$2);\n\n  /**\n   * Return domain auth code. If possible, return the auth code for an unlocked\n   * domain transfer, or an error if the domain is locked. Some TLD may have a\n   * different procedure to retrieve the auth code, in that case, the\n   * information is given in the message field.\n   *\n   * @param request - The request {@link RegistrarApiGetDomainAuthCodeRequest}\n   * @returns A Promise of GetDomainAuthCodeResponse\n   */\n  getDomainAuthCode = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/auth-code`\n  }, unmarshalGetDomainAuthCodeResponse);\n\n  /**\n   * Update domain DNSSEC. If your domain has the default Scaleway NS and uses\n   * another registrar, you have to update the DS record manually. For the\n   * algorithm, here are the code numbers for each type:\n   *\n   * - 1: RSAMD5\n   * - 2: DIFFIE_HELLMAN\n   * - 3: DSA_SHA1\n   * - 5: RSA_SHA1\n   * - 6: DSA_NSEC3_SHA1\n   * - 7: RSASHA1_NSEC3_SHA1\n   * - 8: RSASHA256\n   * - 10: RSASHA512\n   * - 12: ECC_GOST\n   * - 13: ECDSAP256SHA256\n   * - 14: ECDSAP384SHA384\n   *\n   * And for the digest type:\n   *\n   * - 1: SHA_1\n   * - 2: SHA_256\n   * - 3: GOST_R_34_11_94\n   * - 4: SHA_384\n   *\n   * @param request - The request {@link RegistrarApiEnableDomainDNSSECRequest}\n   * @returns A Promise of Domain\n   */\n  enableDomainDNSSEC = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiEnableDomainDNSSECRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/enable-dnssec`\n  }, unmarshalDomain$2);\n\n  /**\n   * Disable domain DNSSEC.\n   *\n   * @param request - The request {@link RegistrarApiDisableDomainDNSSECRequest}\n   * @returns A Promise of Domain\n   */\n  disableDomainDNSSEC = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/disable-dnssec`\n  }, unmarshalDomain$2);\n\n  /**\n   * Search available domains. Search a domain (or at maximum, 10 domains).\n   *\n   * If the TLD list is empty or not set the search returns the results from the\n   * most popular TLDs.\n   *\n   * @param request - The request\n   *   {@link RegistrarApiSearchAvailableDomainsRequest}\n   * @returns A Promise of SearchAvailableDomainsResponse\n   */\n  searchAvailableDomains = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/search-domains`,\n    urlParams: urlParams(['domains', request.domains], ['strict_search', request.strictSearch], ['tlds', request.tlds])\n  }, unmarshalSearchAvailableDomainsResponse);\n\n  /**\n   * Create domain hostname with glue IPs.\n   *\n   * @param request - The request {@link RegistrarApiCreateDomainHostRequest}\n   * @returns A Promise of Host\n   */\n  createDomainHost = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiCreateDomainHostRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'POST',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/hosts`\n  }, unmarshalHost);\n  pageOfListDomainHosts = request => this.client.fetch({\n    method: 'GET',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/hosts`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListDomainHostsResponse);\n\n  /**\n   * List domain hostnames with they glue IPs.\n   *\n   * @param request - The request {@link RegistrarApiListDomainHostsRequest}\n   * @returns A Promise of ListDomainHostsResponse\n   */\n  listDomainHosts = request => enrichForPagination('hosts', this.pageOfListDomainHosts, request);\n\n  /**\n   * Update domain hostname with glue IPs.\n   *\n   * @param request - The request {@link RegistrarApiUpdateDomainHostRequest}\n   * @returns A Promise of Host\n   */\n  updateDomainHost = request => this.client.fetch({\n    body: JSON.stringify(marshalRegistrarApiUpdateDomainHostRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$h,\n    method: 'PATCH',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/hosts/${validatePathParam('name', request.name)}`\n  }, unmarshalHost);\n\n  /**\n   * Delete domain hostname.\n   *\n   * @param request - The request {@link RegistrarApiDeleteDomainHostRequest}\n   * @returns A Promise of Host\n   */\n  deleteDomainHost = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/domain/v2beta1/domains/${validatePathParam('domain', request.domain)}/hosts/${validatePathParam('name', request.name)}`\n  }, unmarshalHost);\n}\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$g = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$j,\n  DNS_ZONE_TRANSIENT_STATUSES: DNS_ZONE_TRANSIENT_STATUSES,\n  DOMAIN_FEATURE_TRANSIENT_STATUSES: DOMAIN_FEATURE_TRANSIENT_STATUSES,\n  DOMAIN_REGISTRATION_STATUS_TRANSFER_TRANSIENT_STATUSES: DOMAIN_REGISTRATION_STATUS_TRANSFER_TRANSIENT_STATUSES,\n  DOMAIN_TRANSIENT_STATUSES: DOMAIN_TRANSIENT_STATUSES$2,\n  HOST_TRANSIENT_STATUSES: HOST_TRANSIENT_STATUSES,\n  RegistrarAPI: RegistrarAPI,\n  SSL_CERTIFICATE_TRANSIENT_STATUSES: SSL_CERTIFICATE_TRANSIENT_STATUSES,\n  TASK_TRANSIENT_STATUSES: TASK_TRANSIENT_STATUSES$1\n});\n\nvar index$l = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v2beta1: index_gen$g\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link FlexibleIPStatus}. */\nconst FLEXIBLE_IP_TRANSIENT_STATUSES = ['updating', 'detaching'];\n\n/** Lists transient statutes of the enum {@link MACAddressStatus}. */\nconst MAC_ADDRESS_TRANSIENT_STATUSES = ['updating', 'deleting'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalMACAddress = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'MACAddress' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    macAddress: data.mac_address,\n    macType: data.mac_type,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalFlexibleIP = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'FlexibleIP' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    id: data.id,\n    ipAddress: data.ip_address,\n    macAddress: data.mac_address ? unmarshalMACAddress(data.mac_address) : undefined,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    reverse: data.reverse,\n    serverId: data.server_id,\n    status: data.status,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalAttachFlexibleIPsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AttachFlexibleIPsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    flexibleIps: unmarshalArrayOfObject(data.flexible_ips, unmarshalFlexibleIP),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalDetachFlexibleIPsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DetachFlexibleIPsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    flexibleIps: unmarshalArrayOfObject(data.flexible_ips, unmarshalFlexibleIP),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListFlexibleIPsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListFlexibleIPsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    flexibleIps: unmarshalArrayOfObject(data.flexible_ips, unmarshalFlexibleIP),\n    totalCount: data.total_count\n  };\n};\nconst marshalAttachFlexibleIPRequest = (request, defaults) => ({\n  fips_ids: request.fipsIds,\n  server_id: request.serverId\n});\nconst marshalCreateFlexibleIPRequest = (request, defaults) => ({\n  description: request.description,\n  is_ipv6: request.isIpv6,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  reverse: request.reverse,\n  server_id: request.serverId,\n  tags: request.tags\n});\nconst marshalDetachFlexibleIPRequest = (request, defaults) => ({\n  fips_ids: request.fipsIds\n});\nconst marshalDuplicateMACAddrRequest = (request, defaults) => ({\n  duplicate_from_fip_id: request.duplicateFromFipId\n});\nconst marshalGenerateMACAddrRequest = (request, defaults) => ({\n  mac_type: request.macType\n});\nconst marshalMoveMACAddrRequest = (request, defaults) => ({\n  dst_fip_id: request.dstFipId\n});\nconst marshalUpdateFlexibleIPRequest = (request, defaults) => ({\n  description: request.description,\n  reverse: request.reverse,\n  tags: request.tags\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$g = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Elastic Metal - Flexible IP API. */\nlet API$i = class API extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-1', 'fr-par-2', 'nl-ams-1'];\n\n  /**\n   * Create a new flexible IP. Generate a new flexible IP within a given zone,\n   * specifying its configuration including Project ID and description.\n   *\n   * @param request - The request {@link CreateFlexibleIPRequest}\n   * @returns A Promise of FlexibleIP\n   */\n  createFlexibleIP = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateFlexibleIPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$g,\n    method: 'POST',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips`\n  }, unmarshalFlexibleIP);\n\n  /**\n   * Get an existing flexible IP. Retrieve information about an existing\n   * flexible IP, specified by its ID and zone. Its full details, including\n   * Project ID, description and status, are returned in the response object.\n   *\n   * @param request - The request {@link GetFlexibleIPRequest}\n   * @returns A Promise of FlexibleIP\n   */\n  getFlexibleIP = request => this.client.fetch({\n    method: 'GET',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/${validatePathParam('fipId', request.fipId)}`\n  }, unmarshalFlexibleIP);\n\n  /**\n   * Waits for {@link FlexibleIP} to be in a final state.\n   *\n   * @param request - The request {@link GetFlexibleIPRequest}\n   * @param options - The waiting options\n   * @returns A Promise of FlexibleIP\n   */\n  waitForFlexibleIP = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!FLEXIBLE_IP_TRANSIENT_STATUSES.includes(res.status))), this.getFlexibleIP, request, options);\n  pageOfListFlexibleIPs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['server_ids', request.serverIds], ['status', request.status], ['tags', request.tags])\n  }, unmarshalListFlexibleIPsResponse);\n\n  /**\n   * List flexible IPs. List all flexible IPs within a given zone.\n   *\n   * @param request - The request {@link ListFlexibleIPsRequest}\n   * @returns A Promise of ListFlexibleIPsResponse\n   */\n  listFlexibleIPs = (request = {}) => enrichForPagination('flexibleIps', this.pageOfListFlexibleIPs, request);\n\n  /**\n   * Update an existing flexible IP. Update the parameters of an existing\n   * flexible IP, specified by its ID and zone. These parameters include tags\n   * and description.\n   *\n   * @param request - The request {@link UpdateFlexibleIPRequest}\n   * @returns A Promise of FlexibleIP\n   */\n  updateFlexibleIP = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateFlexibleIPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$g,\n    method: 'PATCH',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/${validatePathParam('fipId', request.fipId)}`\n  }, unmarshalFlexibleIP);\n\n  /**\n   * Delete an existing flexible IP. Delete an existing flexible IP, specified\n   * by its ID and zone. Note that deleting a flexible IP is permanent and\n   * cannot be undone.\n   *\n   * @param request - The request {@link DeleteFlexibleIPRequest}\n   */\n  deleteFlexibleIP = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/${validatePathParam('fipId', request.fipId)}`\n  });\n\n  /**\n   * Attach an existing flexible IP to a server. Attach an existing flexible IP\n   * to a specified Elastic Metal server.\n   *\n   * @param request - The request {@link AttachFlexibleIPRequest}\n   * @returns A Promise of AttachFlexibleIPsResponse\n   */\n  attachFlexibleIP = request => this.client.fetch({\n    body: JSON.stringify(marshalAttachFlexibleIPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$g,\n    method: 'POST',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/attach`\n  }, unmarshalAttachFlexibleIPsResponse);\n\n  /**\n   * Detach an existing flexible IP from a server. Detach an existing flexible\n   * IP from a specified Elastic Metal server.\n   *\n   * @param request - The request {@link DetachFlexibleIPRequest}\n   * @returns A Promise of DetachFlexibleIPsResponse\n   */\n  detachFlexibleIP = request => this.client.fetch({\n    body: JSON.stringify(marshalDetachFlexibleIPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$g,\n    method: 'POST',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/detach`\n  }, unmarshalDetachFlexibleIPsResponse);\n\n  /**\n   * Generate a virtual MAC address on an existing flexible IP. Generate a\n   * virtual MAC (Media Access Control) address on an existing flexible IP.\n   *\n   * @param request - The request {@link GenerateMACAddrRequest}\n   * @returns A Promise of FlexibleIP\n   */\n  generateMACAddr = request => this.client.fetch({\n    body: JSON.stringify(marshalGenerateMACAddrRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$g,\n    method: 'POST',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/${validatePathParam('fipId', request.fipId)}/mac`\n  }, unmarshalFlexibleIP);\n\n  /**\n   * Duplicate a virtual MAC address to another flexible IP. Duplicate a virtual\n   * MAC address from a given flexible IP to another flexible IP attached to the\n   * same server.\n   *\n   * @param request - The request {@link DuplicateMACAddrRequest}\n   * @returns A Promise of FlexibleIP\n   */\n  duplicateMACAddr = request => this.client.fetch({\n    body: JSON.stringify(marshalDuplicateMACAddrRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$g,\n    method: 'POST',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/${validatePathParam('fipId', request.fipId)}/mac/duplicate`\n  }, unmarshalFlexibleIP);\n\n  /**\n   * Relocate an existing virtual MAC address to a different flexible IP.\n   * Relocate a virtual MAC (Media Access Control) address from an existing\n   * flexible IP to a different flexible IP.\n   *\n   * @param request - The request {@link MoveMACAddrRequest}\n   * @returns A Promise of FlexibleIP\n   */\n  moveMACAddr = request => this.client.fetch({\n    body: JSON.stringify(marshalMoveMACAddrRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$g,\n    method: 'POST',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/${validatePathParam('fipId', request.fipId)}/mac/move`\n  }, unmarshalFlexibleIP);\n\n  /**\n   * Detach a given virtual MAC address from an existing flexible IP. Detach a\n   * given MAC (Media Access Control) address from an existing flexible IP.\n   *\n   * @param request - The request {@link DeleteMACAddrRequest}\n   */\n  deleteMACAddr = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/flexible-ip/v1alpha1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/fips/${validatePathParam('fipId', request.fipId)}/mac`\n  });\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nconst ListFlexibleIPsRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\n\nvar validationRules_gen$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ListFlexibleIPsRequest: ListFlexibleIPsRequest\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$f = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$i,\n  FLEXIBLE_IP_TRANSIENT_STATUSES: FLEXIBLE_IP_TRANSIENT_STATUSES,\n  MAC_ADDRESS_TRANSIENT_STATUSES: MAC_ADDRESS_TRANSIENT_STATUSES,\n  ValidationRules: validationRules_gen$3\n});\n\nvar index$k = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1alpha1: index_gen$f\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link CronStatus}. */\nconst CRON_TRANSIENT_STATUSES = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link DomainStatus}. */\nconst DOMAIN_TRANSIENT_STATUSES$1 = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link FunctionStatus}. */\nconst FUNCTION_TRANSIENT_STATUSES = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link NamespaceStatus}. */\nconst NAMESPACE_TRANSIENT_STATUSES$1 = ['deleting', 'creating', 'pending'];\n\n/** Lists transient statutes of the enum {@link TokenStatus}. */\nconst TOKEN_TRANSIENT_STATUSES = ['deleting', 'creating'];\n\n/** Lists transient statutes of the enum {@link TriggerStatus}. */\nconst TRIGGER_TRANSIENT_STATUSES = ['deleting', 'creating', 'pending'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalSecretHashedValue = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SecretHashedValue' failed as data isn't a dictionary.`);\n  }\n  return {\n    hashedValue: data.hashed_value,\n    key: data.key\n  };\n};\nconst unmarshalTriggerMnqNatsClientConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'TriggerMnqNatsClientConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    mnqCredentialId: data.mnq_credential_id,\n    mnqNamespaceId: data.mnq_namespace_id,\n    mnqProjectId: data.mnq_project_id,\n    mnqRegion: data.mnq_region,\n    subject: data.subject\n  };\n};\nconst unmarshalTriggerMnqSqsClientConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'TriggerMnqSqsClientConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    mnqCredentialId: data.mnq_credential_id,\n    mnqNamespaceId: data.mnq_namespace_id,\n    mnqProjectId: data.mnq_project_id,\n    mnqRegion: data.mnq_region,\n    queue: data.queue\n  };\n};\nconst unmarshalTriggerSqsClientConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'TriggerSqsClientConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    accessKey: data.access_key,\n    endpoint: data.endpoint,\n    queueUrl: data.queue_url,\n    secretKey: data.secret_key\n  };\n};\nconst unmarshalCron = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Cron' failed as data isn't a dictionary.`);\n  }\n  return {\n    args: data.args,\n    functionId: data.function_id,\n    id: data.id,\n    name: data.name,\n    schedule: data.schedule,\n    status: data.status\n  };\n};\nconst unmarshalDomain$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Domain' failed as data isn't a dictionary.`);\n  }\n  return {\n    errorMessage: data.error_message,\n    functionId: data.function_id,\n    hostname: data.hostname,\n    id: data.id,\n    status: data.status,\n    url: data.url\n  };\n};\nconst unmarshalFunction = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Function' failed as data isn't a dictionary.`);\n  }\n  return {\n    buildMessage: data.build_message,\n    cpuLimit: data.cpu_limit,\n    description: data.description,\n    domainName: data.domain_name,\n    environmentVariables: data.environment_variables,\n    errorMessage: data.error_message,\n    handler: data.handler,\n    httpOption: data.http_option,\n    id: data.id,\n    maxScale: data.max_scale,\n    memoryLimit: data.memory_limit,\n    minScale: data.min_scale,\n    name: data.name,\n    namespaceId: data.namespace_id,\n    privacy: data.privacy,\n    region: data.region,\n    runtime: data.runtime,\n    runtimeMessage: data.runtime_message,\n    secretEnvironmentVariables: unmarshalArrayOfObject(data.secret_environment_variables, unmarshalSecretHashedValue),\n    status: data.status,\n    timeout: data.timeout\n  };\n};\nconst unmarshalLog = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Log' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    level: data.level,\n    message: data.message,\n    source: data.source,\n    stream: data.stream,\n    timestamp: unmarshalDate(data.timestamp)\n  };\n};\nconst unmarshalNamespace$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Namespace' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    environmentVariables: data.environment_variables,\n    errorMessage: data.error_message,\n    id: data.id,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    region: data.region,\n    registryEndpoint: data.registry_endpoint,\n    registryNamespaceId: data.registry_namespace_id,\n    secretEnvironmentVariables: unmarshalArrayOfObject(data.secret_environment_variables, unmarshalSecretHashedValue),\n    status: data.status\n  };\n};\nconst unmarshalRuntime = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Runtime' failed as data isn't a dictionary.`);\n  }\n  return {\n    codeSample: data.code_sample,\n    defaultHandler: data.default_handler,\n    extension: data.extension,\n    implementation: data.implementation,\n    language: data.language,\n    logoUrl: data.logo_url,\n    name: data.name,\n    status: data.status,\n    statusMessage: data.status_message,\n    version: data.version\n  };\n};\nconst unmarshalToken = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Token' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    expiresAt: unmarshalDate(data.expires_at),\n    functionId: data.function_id,\n    id: data.id,\n    namespaceId: data.namespace_id,\n    publicKey: data.public_key,\n    status: data.status,\n    token: data.token\n  };\n};\nconst unmarshalTrigger = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Trigger' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    errorMessage: data.error_message,\n    functionId: data.function_id,\n    id: data.id,\n    inputType: data.input_type,\n    name: data.name,\n    scwNatsConfig: data.scw_nats_config ? unmarshalTriggerMnqNatsClientConfig(data.scw_nats_config) : undefined,\n    scwSqsConfig: data.scw_sqs_config ? unmarshalTriggerMnqSqsClientConfig(data.scw_sqs_config) : undefined,\n    sqsConfig: data.sqs_config ? unmarshalTriggerSqsClientConfig(data.sqs_config) : undefined,\n    status: data.status\n  };\n};\nconst unmarshalDownloadURL = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DownloadURL' failed as data isn't a dictionary.`);\n  }\n  return {\n    headers: data.headers,\n    url: data.url\n  };\n};\nconst unmarshalListCronsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListCronsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    crons: unmarshalArrayOfObject(data.crons, unmarshalCron),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDomainsResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    domains: unmarshalArrayOfObject(data.domains, unmarshalDomain$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListFunctionRuntimesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListFunctionRuntimesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    runtimes: unmarshalArrayOfObject(data.runtimes, unmarshalRuntime),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListFunctionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListFunctionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    functions: unmarshalArrayOfObject(data.functions, unmarshalFunction),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListLogsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListLogsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    logs: unmarshalArrayOfObject(data.logs, unmarshalLog),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNamespacesResponse$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    namespaces: unmarshalArrayOfObject(data.namespaces, unmarshalNamespace$2),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListTokensResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTokensResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    tokens: unmarshalArrayOfObject(data.tokens, unmarshalToken),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListTriggersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTriggersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    triggers: unmarshalArrayOfObject(data.triggers, unmarshalTrigger)\n  };\n};\nconst unmarshalUploadURL = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UploadURL' failed as data isn't a dictionary.`);\n  }\n  return {\n    headers: data.headers,\n    url: data.url\n  };\n};\nconst marshalCreateTriggerRequestMnqNatsClientConfig = (request, defaults) => ({\n  mnq_namespace_id: request.mnqNamespaceId,\n  mnq_project_id: request.mnqProjectId,\n  mnq_region: request.mnqRegion,\n  subject: request.subject\n});\nconst marshalCreateTriggerRequestMnqSqsClientConfig = (request, defaults) => ({\n  mnq_namespace_id: request.mnqNamespaceId,\n  mnq_project_id: request.mnqProjectId,\n  mnq_region: request.mnqRegion,\n  queue: request.queue\n});\nconst marshalCreateTriggerRequestSqsClientConfig = (request, defaults) => ({\n  access_key: request.accessKey,\n  endpoint: request.endpoint,\n  queue_url: request.queueUrl,\n  secret_key: request.secretKey\n});\nconst marshalSecret = (request, defaults) => ({\n  key: request.key,\n  value: request.value\n});\nconst marshalUpdateTriggerRequestSqsClientConfig = (request, defaults) => ({\n  access_key: request.accessKey,\n  secret_key: request.secretKey\n});\nconst marshalCreateCronRequest = (request, defaults) => ({\n  args: request.args,\n  function_id: request.functionId,\n  name: request.name,\n  schedule: request.schedule\n});\nconst marshalCreateDomainRequest$1 = (request, defaults) => ({\n  function_id: request.functionId,\n  hostname: request.hostname\n});\nconst marshalCreateFunctionRequest = (request, defaults) => ({\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  handler: request.handler,\n  http_option: request.httpOption ?? 'unknown_http_option',\n  max_scale: request.maxScale,\n  memory_limit: request.memoryLimit,\n  min_scale: request.minScale,\n  name: request.name || randomName('fn'),\n  namespace_id: request.namespaceId,\n  privacy: request.privacy ?? 'unknown_privacy',\n  runtime: request.runtime ?? 'unknown_runtime',\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret(elt)) : undefined,\n  timeout: request.timeout\n});\nconst marshalCreateNamespaceRequest$2 = (request, defaults) => ({\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  name: request.name || randomName('ns'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret(elt)) : undefined\n});\nconst marshalCreateTokenRequest = (request, defaults) => ({\n  description: request.description,\n  expires_at: request.expiresAt,\n  ...resolveOneOf([{\n    param: 'function_id',\n    value: request.functionId\n  }, {\n    param: 'namespace_id',\n    value: request.namespaceId\n  }])\n});\nconst marshalCreateTriggerRequest = (request, defaults) => ({\n  description: request.description,\n  function_id: request.functionId,\n  name: request.name,\n  ...resolveOneOf([{\n    param: 'scw_sqs_config',\n    value: request.scwSqsConfig ? marshalCreateTriggerRequestMnqSqsClientConfig(request.scwSqsConfig) : undefined\n  }, {\n    param: 'sqs_config',\n    value: request.sqsConfig ? marshalCreateTriggerRequestSqsClientConfig(request.sqsConfig) : undefined\n  }, {\n    param: 'scw_nats_config',\n    value: request.scwNatsConfig ? marshalCreateTriggerRequestMnqNatsClientConfig(request.scwNatsConfig) : undefined\n  }])\n});\nconst marshalUpdateCronRequest = (request, defaults) => ({\n  args: request.args,\n  function_id: request.functionId,\n  name: request.name,\n  schedule: request.schedule\n});\nconst marshalUpdateFunctionRequest = (request, defaults) => ({\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  handler: request.handler,\n  http_option: request.httpOption ?? 'unknown_http_option',\n  max_scale: request.maxScale,\n  memory_limit: request.memoryLimit,\n  min_scale: request.minScale,\n  privacy: request.privacy ?? 'unknown_privacy',\n  redeploy: request.redeploy,\n  runtime: request.runtime ?? 'unknown_runtime',\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret(elt)) : undefined,\n  timeout: request.timeout\n});\nconst marshalUpdateNamespaceRequest$2 = (request, defaults) => ({\n  description: request.description,\n  environment_variables: request.environmentVariables,\n  secret_environment_variables: request.secretEnvironmentVariables ? request.secretEnvironmentVariables.map(elt => marshalSecret(elt)) : undefined\n});\nconst marshalUpdateTriggerRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name,\n  ...resolveOneOf([{\n    param: 'sqs_config',\n    value: request.sqsConfig ? marshalUpdateTriggerRequestSqsClientConfig(request.sqsConfig) : undefined\n  }])\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$f = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Serverless Functions API. */\nlet API$h = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par', 'nl-ams', 'pl-waw'];\n  pageOfListNamespaces = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListNamespacesResponse$2);\n\n  /**\n   * List all your namespaces. List all existing namespaces in the specified\n   * region.\n   *\n   * @param request - The request {@link ListNamespacesRequest}\n   * @returns A Promise of ListNamespacesResponse\n   */\n  listNamespaces = (request = {}) => enrichForPagination('namespaces', this.pageOfListNamespaces, request);\n\n  /**\n   * Get a namespace. Get the namespace associated with the specified ID.\n   *\n   * @param request - The request {@link GetNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  getNamespace = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace$2);\n\n  /**\n   * Waits for {@link Namespace} to be in a final state.\n   *\n   * @param request - The request {@link GetNamespaceRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Namespace\n   */\n  waitForNamespace = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!NAMESPACE_TRANSIENT_STATUSES$1.includes(res.status))), this.getNamespace, request, options);\n\n  /**\n   * Create a new namespace. Create a new namespace in a specified Organization\n   * or Proejct.\n   *\n   * @param request - The request {@link CreateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  createNamespace = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateNamespaceRequest$2(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'POST',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`\n  }, unmarshalNamespace$2);\n\n  /**\n   * Update an existing namespace. Update the namespace associated with the\n   * specified ID.\n   *\n   * @param request - The request {@link UpdateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  updateNamespace = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateNamespaceRequest$2(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'PATCH',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace$2);\n\n  /**\n   * Delete an existing namespace. Delete the namespace associated with the\n   * specified ID.\n   *\n   * @param request - The request {@link DeleteNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  deleteNamespace = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace$2);\n  pageOfListFunctions = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions`,\n    urlParams: urlParams(['name', request.name], ['namespace_id', request.namespaceId], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListFunctionsResponse);\n\n  /**\n   * List all your functions.\n   *\n   * @param request - The request {@link ListFunctionsRequest}\n   * @returns A Promise of ListFunctionsResponse\n   */\n  listFunctions = request => enrichForPagination('functions', this.pageOfListFunctions, request);\n\n  /**\n   * Get a function. Get the function associated with the specified ID.\n   *\n   * @param request - The request {@link GetFunctionRequest}\n   * @returns A Promise of Function\n   */\n  getFunction = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions/${validatePathParam('functionId', request.functionId)}`\n  }, unmarshalFunction);\n\n  /**\n   * Waits for {@link Function} to be in a final state.\n   *\n   * @param request - The request {@link GetFunctionRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Function\n   */\n  waitForFunction = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!FUNCTION_TRANSIENT_STATUSES.includes(res.status))), this.getFunction, request, options);\n\n  /**\n   * Create a new function. Create a new function in the specified region for a\n   * specified Organization or Project.\n   *\n   * @param request - The request {@link CreateFunctionRequest}\n   * @returns A Promise of Function\n   */\n  createFunction = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateFunctionRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'POST',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions`\n  }, unmarshalFunction);\n\n  /**\n   * Update an existing function. Update the function associated with the\n   * specified ID.\n   *\n   * @param request - The request {@link UpdateFunctionRequest}\n   * @returns A Promise of Function\n   */\n  updateFunction = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateFunctionRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'PATCH',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions/${validatePathParam('functionId', request.functionId)}`\n  }, unmarshalFunction);\n\n  /**\n   * Delete a function. Delete the function associated with the specified ID.\n   *\n   * @param request - The request {@link DeleteFunctionRequest}\n   * @returns A Promise of Function\n   */\n  deleteFunction = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions/${validatePathParam('functionId', request.functionId)}`\n  }, unmarshalFunction);\n\n  /**\n   * Deploy a function. Deploy a function associated with the specified ID.\n   *\n   * @param request - The request {@link DeployFunctionRequest}\n   * @returns A Promise of Function\n   */\n  deployFunction = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$f,\n    method: 'POST',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions/${validatePathParam('functionId', request.functionId)}/deploy`\n  }, unmarshalFunction);\n\n  /**\n   * List function runtimes. List available function runtimes.\n   *\n   * @param request - The request {@link ListFunctionRuntimesRequest}\n   * @returns A Promise of ListFunctionRuntimesResponse\n   */\n  listFunctionRuntimes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/runtimes`\n  }, unmarshalListFunctionRuntimesResponse);\n\n  /**\n   * Get an upload URL of a function. Get an upload URL of a function associated\n   * with the specified ID.\n   *\n   * @param request - The request {@link GetFunctionUploadURLRequest}\n   * @returns A Promise of UploadURL\n   */\n  getFunctionUploadURL = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions/${validatePathParam('functionId', request.functionId)}/upload-url`,\n    urlParams: urlParams(['content_length', request.contentLength])\n  }, unmarshalUploadURL);\n\n  /**\n   * Get a download URL of a function. Get a download URL for a function\n   * associated with the specified ID.\n   *\n   * @param request - The request {@link GetFunctionDownloadURLRequest}\n   * @returns A Promise of DownloadURL\n   */\n  getFunctionDownloadURL = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions/${validatePathParam('functionId', request.functionId)}/download-url`\n  }, unmarshalDownloadURL);\n  pageOfListCrons = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons`,\n    urlParams: urlParams(['function_id', request.functionId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListCronsResponse);\n\n  /**\n   * List all crons. List all the cronjobs in a specified region.\n   *\n   * @param request - The request {@link ListCronsRequest}\n   * @returns A Promise of ListCronsResponse\n   */\n  listCrons = request => enrichForPagination('crons', this.pageOfListCrons, request);\n\n  /**\n   * Get a cron. Get the cron associated with the specified ID.\n   *\n   * @param request - The request {@link GetCronRequest}\n   * @returns A Promise of Cron\n   */\n  getCron = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons/${validatePathParam('cronId', request.cronId)}`\n  }, unmarshalCron);\n\n  /**\n   * Waits for {@link Cron} to be in a final state.\n   *\n   * @param request - The request {@link GetCronRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Cron\n   */\n  waitForCron = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!CRON_TRANSIENT_STATUSES.includes(res.status))), this.getCron, request, options);\n\n  /**\n   * Create a new cron. Create a new cronjob for a function with the specified\n   * ID.\n   *\n   * @param request - The request {@link CreateCronRequest}\n   * @returns A Promise of Cron\n   */\n  createCron = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateCronRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'POST',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons`\n  }, unmarshalCron);\n\n  /**\n   * Update an existing cron. Update the cron associated with the specified ID.\n   *\n   * @param request - The request {@link UpdateCronRequest}\n   * @returns A Promise of Cron\n   */\n  updateCron = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateCronRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'PATCH',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons/${validatePathParam('cronId', request.cronId)}`\n  }, unmarshalCron);\n\n  /**\n   * Delete an existing cron. Delete the cron associated with the specified ID.\n   *\n   * @param request - The request {@link DeleteCronRequest}\n   * @returns A Promise of Cron\n   */\n  deleteCron = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/crons/${validatePathParam('cronId', request.cronId)}`\n  }, unmarshalCron);\n  pageOfListLogs = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/functions/${validatePathParam('functionId', request.functionId)}/logs`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'timestamp_desc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListLogsResponse);\n\n  /**\n   * List application logs. List the application logs of the function with the\n   * specified ID.\n   *\n   * @param request - The request {@link ListLogsRequest}\n   * @returns A Promise of ListLogsResponse\n   */\n  listLogs = request => enrichForPagination('logs', this.pageOfListLogs, request);\n  pageOfListDomains = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains`,\n    urlParams: urlParams(['function_id', request.functionId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListDomainsResponse$1);\n\n  /**\n   * List all domain name bindings. List all domain name bindings in a specified\n   * region.\n   *\n   * @param request - The request {@link ListDomainsRequest}\n   * @returns A Promise of ListDomainsResponse\n   */\n  listDomains = request => enrichForPagination('domains', this.pageOfListDomains, request);\n\n  /**\n   * Get a domain name binding. Get a domain name binding for the function with\n   * the specified ID.\n   *\n   * @param request - The request {@link GetDomainRequest}\n   * @returns A Promise of Domain\n   */\n  getDomain = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domainId', request.domainId)}`\n  }, unmarshalDomain$1);\n\n  /**\n   * Waits for {@link Domain} to be in a final state.\n   *\n   * @param request - The request {@link GetDomainRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Domain\n   */\n  waitForDomain = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!DOMAIN_TRANSIENT_STATUSES$1.includes(res.status))), this.getDomain, request, options);\n\n  /**\n   * Create a domain name binding. Create a domain name binding for the function\n   * with the specified ID.\n   *\n   * @param request - The request {@link CreateDomainRequest}\n   * @returns A Promise of Domain\n   */\n  createDomain = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDomainRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'POST',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains`\n  }, unmarshalDomain$1);\n\n  /**\n   * Delete a domain name binding. Delete a domain name binding for the function\n   * with the specified ID.\n   *\n   * @param request - The request {@link DeleteDomainRequest}\n   * @returns A Promise of Domain\n   */\n  deleteDomain = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domainId', request.domainId)}`\n  }, unmarshalDomain$1);\n\n  /**\n   * @deprecated\n   * @param request - The request {@link IssueJWTRequest}\n   * @returns A Promise of Token\n   */\n  issueJWT = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/issue-jwt`,\n    urlParams: urlParams(['expires_at', request.expiresAt], ...Object.entries(resolveOneOf([{\n      param: 'function_id',\n      value: request.functionId\n    }, {\n      param: 'namespace_id',\n      value: request.namespaceId\n    }])))\n  }, unmarshalToken);\n\n  /**\n   * Create a new revocable token.\n   *\n   * @param request - The request {@link CreateTokenRequest}\n   * @returns A Promise of Token\n   */\n  createToken = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateTokenRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'POST',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens`\n  }, unmarshalToken);\n\n  /**\n   * Get a token.\n   *\n   * @param request - The request {@link GetTokenRequest}\n   * @returns A Promise of Token\n   */\n  getToken = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens/${validatePathParam('tokenId', request.tokenId)}`\n  }, unmarshalToken);\n\n  /**\n   * Waits for {@link Token} to be in a final state.\n   *\n   * @param request - The request {@link GetTokenRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Token\n   */\n  waitForToken = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!TOKEN_TRANSIENT_STATUSES.includes(res.status))), this.getToken, request, options);\n  pageOfListTokens = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens`,\n    urlParams: urlParams(['function_id', request.functionId], ['namespace_id', request.namespaceId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListTokensResponse);\n\n  /**\n   * List all tokens.\n   *\n   * @param request - The request {@link ListTokensRequest}\n   * @returns A Promise of ListTokensResponse\n   */\n  listTokens = (request = {}) => enrichForPagination('tokens', this.pageOfListTokens, request);\n\n  /**\n   * Delete a token.\n   *\n   * @param request - The request {@link DeleteTokenRequest}\n   * @returns A Promise of Token\n   */\n  deleteToken = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tokens/${validatePathParam('tokenId', request.tokenId)}`\n  }, unmarshalToken);\n  createTrigger = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateTriggerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'POST',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/triggers`\n  }, unmarshalTrigger);\n  getTrigger = request => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/triggers/${validatePathParam('triggerId', request.triggerId)}`\n  }, unmarshalTrigger);\n\n  /**\n   * Waits for {@link Trigger} to be in a final state.\n   *\n   * @param request - The request {@link GetTriggerRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Trigger\n   */\n  waitForTrigger = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!TRIGGER_TRANSIENT_STATUSES.includes(res.status))), this.getTrigger, request, options);\n  pageOfListTriggers = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/triggers`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ...Object.entries(resolveOneOf([{\n      default: this.client.settings.defaultProjectId,\n      param: 'project_id',\n      value: request.projectId\n    }, {\n      param: 'function_id',\n      value: request.functionId\n    }, {\n      param: 'namespace_id',\n      value: request.namespaceId\n    }])))\n  }, unmarshalListTriggersResponse);\n  listTriggers = (request = {}) => enrichForPagination('triggers', this.pageOfListTriggers, request);\n  updateTrigger = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateTriggerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$f,\n    method: 'PATCH',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/triggers/${validatePathParam('triggerId', request.triggerId)}`\n  }, unmarshalTrigger);\n  deleteTrigger = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/functions/v1beta1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/triggers/${validatePathParam('triggerId', request.triggerId)}`\n  }, unmarshalTrigger);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$e = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$h,\n  CRON_TRANSIENT_STATUSES: CRON_TRANSIENT_STATUSES,\n  DOMAIN_TRANSIENT_STATUSES: DOMAIN_TRANSIENT_STATUSES$1,\n  FUNCTION_TRANSIENT_STATUSES: FUNCTION_TRANSIENT_STATUSES,\n  NAMESPACE_TRANSIENT_STATUSES: NAMESPACE_TRANSIENT_STATUSES$1,\n  TOKEN_TRANSIENT_STATUSES: TOKEN_TRANSIENT_STATUSES,\n  TRIGGER_TRANSIENT_STATUSES: TRIGGER_TRANSIENT_STATUSES\n});\n\nvar index$j = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1beta1: index_gen$e\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalAPIKey = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'APIKey' failed as data isn't a dictionary.`);\n  }\n  return {\n    accessKey: data.access_key,\n    applicationId: data.application_id,\n    createdAt: unmarshalDate(data.created_at),\n    creationIp: data.creation_ip,\n    defaultProjectId: data.default_project_id,\n    description: data.description,\n    editable: data.editable,\n    expiresAt: unmarshalDate(data.expires_at),\n    secretKey: data.secret_key,\n    updatedAt: unmarshalDate(data.updated_at),\n    userId: data.user_id\n  };\n};\nconst unmarshalApplication = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Application' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    editable: data.editable,\n    id: data.id,\n    name: data.name,\n    nbApiKeys: data.nb_api_keys,\n    organizationId: data.organization_id,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalGroup = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Group' failed as data isn't a dictionary.`);\n  }\n  return {\n    applicationIds: data.application_ids,\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    id: data.id,\n    name: data.name,\n    organizationId: data.organization_id,\n    updatedAt: unmarshalDate(data.updated_at),\n    userIds: data.user_ids\n  };\n};\nconst unmarshalJWT = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'JWT' failed as data isn't a dictionary.`);\n  }\n  return {\n    audienceId: data.audience_id,\n    createdAt: unmarshalDate(data.created_at),\n    expiresAt: unmarshalDate(data.expires_at),\n    ip: data.ip,\n    issuerId: data.issuer_id,\n    jti: data.jti,\n    updatedAt: unmarshalDate(data.updated_at),\n    userAgent: data.user_agent\n  };\n};\nconst unmarshalPermissionSet = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PermissionSet' failed as data isn't a dictionary.`);\n  }\n  return {\n    categories: data.categories,\n    description: data.description,\n    id: data.id,\n    name: data.name,\n    scopeType: data.scope_type\n  };\n};\nconst unmarshalPolicy = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Policy' failed as data isn't a dictionary.`);\n  }\n  return {\n    applicationId: data.application_id,\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    editable: data.editable,\n    groupId: data.group_id,\n    id: data.id,\n    name: data.name,\n    nbPermissionSets: data.nb_permission_sets,\n    nbRules: data.nb_rules,\n    nbScopes: data.nb_scopes,\n    noPrincipal: data.no_principal,\n    organizationId: data.organization_id,\n    updatedAt: unmarshalDate(data.updated_at),\n    userId: data.user_id\n  };\n};\nconst unmarshalQuotum = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Quotum' failed as data isn't a dictionary.`);\n  }\n  return {\n    limit: data.limit,\n    name: data.name,\n    unlimited: data.unlimited\n  };\n};\nconst unmarshalRule = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Rule' failed as data isn't a dictionary.`);\n  }\n  return {\n    accountRootUserId: data.account_root_user_id,\n    id: data.id,\n    organizationId: data.organization_id,\n    permissionSetNames: data.permission_set_names,\n    permissionSetsScopeType: data.permission_sets_scope_type,\n    projectIds: data.project_ids\n  };\n};\nconst unmarshalSSHKey = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SSHKey' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    disabled: data.disabled,\n    fingerprint: data.fingerprint,\n    id: data.id,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    publicKey: data.public_key,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalUser$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'User' failed as data isn't a dictionary.`);\n  }\n  return {\n    accountRootUserId: data.account_root_user_id,\n    createdAt: unmarshalDate(data.created_at),\n    deletable: data.deletable,\n    email: data.email,\n    id: data.id,\n    lastLoginAt: unmarshalDate(data.last_login_at),\n    mfa: data.mfa,\n    organizationId: data.organization_id,\n    status: data.status,\n    twoFactorEnabled: data.two_factor_enabled,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalListAPIKeysResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListAPIKeysResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    apiKeys: unmarshalArrayOfObject(data.api_keys, unmarshalAPIKey),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListApplicationsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListApplicationsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    applications: unmarshalArrayOfObject(data.applications, unmarshalApplication),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListGroupsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListGroupsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    groups: unmarshalArrayOfObject(data.groups, unmarshalGroup),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListJWTsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListJWTsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    jwts: unmarshalArrayOfObject(data.jwts, unmarshalJWT),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPermissionSetsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPermissionSetsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    permissionSets: unmarshalArrayOfObject(data.permission_sets, unmarshalPermissionSet),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPoliciesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPoliciesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    policies: unmarshalArrayOfObject(data.policies, unmarshalPolicy),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListQuotaResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListQuotaResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    quota: unmarshalArrayOfObject(data.quota, unmarshalQuotum),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalRule),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSSHKeysResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSSHKeysResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    sshKeys: unmarshalArrayOfObject(data.ssh_keys, unmarshalSSHKey),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListUsersResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListUsersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    users: unmarshalArrayOfObject(data.users, unmarshalUser$1)\n  };\n};\nconst unmarshalSetRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalRule)\n  };\n};\nconst marshalRuleSpecs = (request, defaults) => ({\n  permission_set_names: request.permissionSetNames,\n  ...resolveOneOf([{\n    param: 'project_ids',\n    value: request.projectIds\n  }, {\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalAddGroupMemberRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'user_id',\n    value: request.userId\n  }, {\n    param: 'application_id',\n    value: request.applicationId\n  }])\n});\nconst marshalCreateAPIKeyRequest = (request, defaults) => ({\n  default_project_id: request.defaultProjectId,\n  description: request.description,\n  expires_at: request.expiresAt,\n  ...resolveOneOf([{\n    param: 'application_id',\n    value: request.applicationId\n  }, {\n    param: 'user_id',\n    value: request.userId\n  }])\n});\nconst marshalCreateApplicationRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name || randomName('app'),\n  organization_id: request.organizationId ?? defaults.defaultOrganizationId\n});\nconst marshalCreateGroupRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name || randomName('grp'),\n  organization_id: request.organizationId ?? defaults.defaultOrganizationId\n});\nconst marshalCreatePolicyRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name || randomName('pol'),\n  organization_id: request.organizationId ?? defaults.defaultOrganizationId,\n  rules: request.rules ? request.rules.map(elt => marshalRuleSpecs(elt)) : undefined,\n  ...resolveOneOf([{\n    param: 'user_id',\n    value: request.userId\n  }, {\n    param: 'group_id',\n    value: request.groupId\n  }, {\n    param: 'application_id',\n    value: request.applicationId\n  }, {\n    param: 'no_principal',\n    value: request.noPrincipal\n  }])\n});\nconst marshalCreateSSHKeyRequest = (request, defaults) => ({\n  name: request.name || randomName('key'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  public_key: request.publicKey\n});\nconst marshalRemoveGroupMemberRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'user_id',\n    value: request.userId\n  }, {\n    param: 'application_id',\n    value: request.applicationId\n  }])\n});\nconst marshalSetGroupMembersRequest = (request, defaults) => ({\n  application_ids: request.applicationIds,\n  user_ids: request.userIds\n});\nconst marshalSetRulesRequest = (request, defaults) => ({\n  policy_id: request.policyId,\n  rules: request.rules.map(elt => marshalRuleSpecs(elt))\n});\nconst marshalUpdateAPIKeyRequest = (request, defaults) => ({\n  default_project_id: request.defaultProjectId,\n  description: request.description\n});\nconst marshalUpdateApplicationRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name\n});\nconst marshalUpdateGroupRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name\n});\nconst marshalUpdatePolicyRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name,\n  ...resolveOneOf([{\n    param: 'user_id',\n    value: request.userId\n  }, {\n    param: 'group_id',\n    value: request.groupId\n  }, {\n    param: 'application_id',\n    value: request.applicationId\n  }, {\n    param: 'no_principal',\n    value: request.noPrincipal\n  }])\n});\nconst marshalUpdateSSHKeyRequest = (request, defaults) => ({\n  disabled: request.disabled,\n  name: request.name\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$e = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** IAM API. */\nlet API$g = class API extends API$q {\n  pageOfListSSHKeys = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/ssh-keys`,\n    urlParams: urlParams(['disabled', request.disabled], ['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListSSHKeysResponse);\n\n  /**\n   * List SSH keys. List SSH keys. By default, the SSH keys listed are ordered\n   * by creation date in ascending order. This can be modified via the\n   * `order_by` field. You can define additional parameters for your query such\n   * as `organization_id`, `name`, `project_id` and `disabled`.\n   *\n   * @param request - The request {@link ListSSHKeysRequest}\n   * @returns A Promise of ListSSHKeysResponse\n   */\n  listSSHKeys = (request = {}) => enrichForPagination('sshKeys', this.pageOfListSSHKeys, request);\n\n  /**\n   * Create an SSH key. Add a new SSH key to a Scaleway Project. You must\n   * specify the `name`, `public_key` and `project_id`.\n   *\n   * @param request - The request {@link CreateSSHKeyRequest}\n   * @returns A Promise of SSHKey\n   */\n  createSSHKey = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSSHKeyRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/ssh-keys`\n  }, unmarshalSSHKey);\n\n  /**\n   * Get an SSH key. Retrieve information about a given SSH key, specified by\n   * the `ssh_key_id` parameter. The SSH key's full details, including `id`,\n   * `name`, `public_key`, and `project_id` are returned in the response.\n   *\n   * @param request - The request {@link GetSSHKeyRequest}\n   * @returns A Promise of SSHKey\n   */\n  getSSHKey = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/ssh-keys/${validatePathParam('sshKeyId', request.sshKeyId)}`\n  }, unmarshalSSHKey);\n\n  /**\n   * Update an SSH key. Update the parameters of an SSH key, including `name`\n   * and `disable`.\n   *\n   * @param request - The request {@link UpdateSSHKeyRequest}\n   * @returns A Promise of SSHKey\n   */\n  updateSSHKey = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateSSHKeyRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'PATCH',\n    path: `/iam/v1alpha1/ssh-keys/${validatePathParam('sshKeyId', request.sshKeyId)}`\n  }, unmarshalSSHKey);\n\n  /**\n   * Delete an SSH key. Delete a given SSH key, specified by the `ssh_key_id`.\n   * Deleting an SSH is permanent, and cannot be undone. Note that you might\n   * need to update any configurations that used the SSH key.\n   *\n   * @param request - The request {@link DeleteSSHKeyRequest}\n   */\n  deleteSSHKey = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iam/v1alpha1/ssh-keys/${validatePathParam('sshKeyId', request.sshKeyId)}`\n  });\n  pageOfListUsers = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/users`,\n    urlParams: urlParams(['mfa', request.mfa], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['user_ids', request.userIds])\n  }, unmarshalListUsersResponse$1);\n\n  /**\n   * List users of an Organization. List the users of an Organization. By\n   * default, the users listed are ordered by creation date in ascending order.\n   * This can be modified via the `order_by` field. You must define the\n   * `organization_id` in the query path of your request. You can also define\n   * additional parameters for your query such as `user_ids`.\n   *\n   * @param request - The request {@link ListUsersRequest}\n   * @returns A Promise of ListUsersResponse\n   */\n  listUsers = (request = {}) => enrichForPagination('users', this.pageOfListUsers, request);\n\n  /**\n   * Get a given user. Retrieve information about a user, specified by the\n   * `user_id` parameter. The user's full details, including `id`, `email`,\n   * `organization_id`, `status` and `mfa` are returned in the response.\n   *\n   * @param request - The request {@link GetUserRequest}\n   * @returns A Promise of User\n   */\n  getUser = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/users/${validatePathParam('userId', request.userId)}`\n  }, unmarshalUser$1);\n\n  /**\n   * Delete a guest user from an Organization. Remove a user from an\n   * Organization in which they are a guest. You must define the `user_id` in\n   * your request. Note that removing a user from an Organization automatically\n   * deletes their API keys, and any policies directly attached to them become\n   * orphaned.\n   *\n   * @param request - The request {@link DeleteUserRequest}\n   */\n  deleteUser = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iam/v1alpha1/users/${validatePathParam('userId', request.userId)}`\n  });\n  pageOfListApplications = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/applications`,\n    urlParams: urlParams(['application_ids', request.applicationIds], ['editable', request.editable], ['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListApplicationsResponse);\n\n  /**\n   * List applications of an Organization. List the applications of an\n   * Organization. By default, the applications listed are ordered by creation\n   * date in ascending order. This can be modified via the `order_by` field. You\n   * must define the `organization_id` in the query path of your request. You\n   * can also define additional parameters for your query such as\n   * `application_ids`.\n   *\n   * @param request - The request {@link ListApplicationsRequest}\n   * @returns A Promise of ListApplicationsResponse\n   */\n  listApplications = (request = {}) => enrichForPagination('applications', this.pageOfListApplications, request);\n\n  /**\n   * Create a new application. Create a new application. You must define the\n   * `name` parameter in the request.\n   *\n   * @param request - The request {@link CreateApplicationRequest}\n   * @returns A Promise of Application\n   */\n  createApplication = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateApplicationRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/applications`\n  }, unmarshalApplication);\n\n  /**\n   * Get a given application. Retrieve information about an application,\n   * specified by the `application_id` parameter. The application's full\n   * details, including `id`, `email`, `organization_id`, `status` and\n   * `two_factor_enabled` are returned in the response.\n   *\n   * @param request - The request {@link GetApplicationRequest}\n   * @returns A Promise of Application\n   */\n  getApplication = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/applications/${validatePathParam('applicationId', request.applicationId)}`\n  }, unmarshalApplication);\n\n  /**\n   * Update an application. Update the parameters of an application, including\n   * `name` and `description`.\n   *\n   * @param request - The request {@link UpdateApplicationRequest}\n   * @returns A Promise of Application\n   */\n  updateApplication = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateApplicationRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'PATCH',\n    path: `/iam/v1alpha1/applications/${validatePathParam('applicationId', request.applicationId)}`\n  }, unmarshalApplication);\n\n  /**\n   * Delete an application. Delete an application. Note that this action is\n   * irreversible and will automatically delete the application's API keys.\n   * Policies attached to users and applications via this group will no longer\n   * apply.\n   *\n   * @param request - The request {@link DeleteApplicationRequest}\n   */\n  deleteApplication = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iam/v1alpha1/applications/${validatePathParam('applicationId', request.applicationId)}`\n  });\n  pageOfListGroups = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/groups`,\n    urlParams: urlParams(['application_ids', request.applicationIds], ['group_ids', request.groupIds], ['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['user_ids', request.userIds])\n  }, unmarshalListGroupsResponse);\n\n  /**\n   * List groups. List groups. By default, the groups listed are ordered by\n   * creation date in ascending order. This can be modified via the `order_by`\n   * field. You can define additional parameters to filter your query. Use\n   * `user_ids` or `application_ids` to list all groups certain users or\n   * applications belong to.\n   *\n   * @param request - The request {@link ListGroupsRequest}\n   * @returns A Promise of ListGroupsResponse\n   */\n  listGroups = (request = {}) => enrichForPagination('groups', this.pageOfListGroups, request);\n\n  /**\n   * Create a group. Create a new group. You must define the `name` and\n   * `organization_id` parameters in the request.\n   *\n   * @param request - The request {@link CreateGroupRequest}\n   * @returns A Promise of Group\n   */\n  createGroup = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateGroupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/groups`\n  }, unmarshalGroup);\n\n  /**\n   * Get a group. Retrive information about a given group, specified by the\n   * `group_id` parameter. The group's full details, including `user_ids` and\n   * `application_ids` are returned in the response.\n   *\n   * @param request - The request {@link GetGroupRequest}\n   * @returns A Promise of Group\n   */\n  getGroup = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/groups/${validatePathParam('groupId', request.groupId)}`\n  }, unmarshalGroup);\n\n  /**\n   * Update a group. Update the parameters of group, including `name` and\n   * `description`.\n   *\n   * @param request - The request {@link UpdateGroupRequest}\n   * @returns A Promise of Group\n   */\n  updateGroup = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateGroupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'PATCH',\n    path: `/iam/v1alpha1/groups/${validatePathParam('groupId', request.groupId)}`\n  }, unmarshalGroup);\n\n  /**\n   * Overwrite users and applications of a group. Overwrite users and\n   * applications configuration in a group. Any information that you add using\n   * this command will overwrite the previous configuration.\n   *\n   * @param request - The request {@link SetGroupMembersRequest}\n   * @returns A Promise of Group\n   */\n  setGroupMembers = request => this.client.fetch({\n    body: JSON.stringify(marshalSetGroupMembersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'PUT',\n    path: `/iam/v1alpha1/groups/${validatePathParam('groupId', request.groupId)}/members`\n  }, unmarshalGroup);\n\n  /**\n   * Add a user or an application to a group. Add a user or an application to a\n   * group. You can specify a `user_id` and and `application_id` in the body of\n   * your request. Note that you can only add one of each per request.\n   *\n   * @param request - The request {@link AddGroupMemberRequest}\n   * @returns A Promise of Group\n   */\n  addGroupMember = request => this.client.fetch({\n    body: JSON.stringify(marshalAddGroupMemberRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/groups/${validatePathParam('groupId', request.groupId)}/add-member`\n  }, unmarshalGroup);\n\n  /**\n   * Remove a user or an application from a group. Remove a user or an\n   * application from a group. You can specify a `user_id` and and\n   * `application_id` in the body of your request. Note that you can only remove\n   * one of each per request. Removing a user from a group means that any\n   * permissions given to them via the group (i.e. from an attached policy) will\n   * no longer apply. Be sure you want to remove these permissions from the user\n   * before proceeding.\n   *\n   * @param request - The request {@link RemoveGroupMemberRequest}\n   * @returns A Promise of Group\n   */\n  removeGroupMember = request => this.client.fetch({\n    body: JSON.stringify(marshalRemoveGroupMemberRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/groups/${validatePathParam('groupId', request.groupId)}/remove-member`\n  }, unmarshalGroup);\n\n  /**\n   * Delete a group. Delete a group. Note that this action is irreversible and\n   * could delete permissions for group members. Policies attached to users and\n   * applications via this group will no longer apply.\n   *\n   * @param request - The request {@link DeleteGroupRequest}\n   */\n  deleteGroup = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iam/v1alpha1/groups/${validatePathParam('groupId', request.groupId)}`\n  });\n  pageOfListPolicies = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/policies`,\n    urlParams: urlParams(['application_ids', request.applicationIds], ['editable', request.editable], ['group_ids', request.groupIds], ['no_principal', request.noPrincipal], ['order_by', request.orderBy ?? 'policy_name_asc'], ['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['policy_name', request.policyName], ['user_ids', request.userIds])\n  }, unmarshalListPoliciesResponse);\n\n  /**\n   * List policies of an Organization. List the policies of an Organization. By\n   * default, the policies listed are ordered by creation date in ascending\n   * order. This can be modified via the `order_by` field. You must define the\n   * `organization_id` in the query path of your request. You can also define\n   * additional parameters to filter your query, such as `user_ids`,\n   * `groups_ids`, `application_ids`, and `policy_name`.\n   *\n   * @param request - The request {@link ListPoliciesRequest}\n   * @returns A Promise of ListPoliciesResponse\n   */\n  listPolicies = (request = {}) => enrichForPagination('policies', this.pageOfListPolicies, request);\n\n  /**\n   * Create a new policy. Create a new application. You must define the `name`\n   * parameter in the request. You can specify parameters such as `user_id`,\n   * `groups_id`, `application_id`, `no_principal`, `rules` and its child\n   * attributes.\n   *\n   * @param request - The request {@link CreatePolicyRequest}\n   * @returns A Promise of Policy\n   */\n  createPolicy = request => this.client.fetch({\n    body: JSON.stringify(marshalCreatePolicyRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/policies`\n  }, unmarshalPolicy);\n\n  /**\n   * Get an existing policy. Retrieve information about a policy, speficified by\n   * the `policy_id` parameter. The policy's full details, including `id`,\n   * `name`, `organization_id`, `nb_rules` and `nb_scopes`, `nb_permission_sets`\n   * are returned in the response.\n   *\n   * @param request - The request {@link GetPolicyRequest}\n   * @returns A Promise of Policy\n   */\n  getPolicy = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/policies/${validatePathParam('policyId', request.policyId)}`\n  }, unmarshalPolicy);\n\n  /**\n   * Update an existing policy. Update the parameters of a policy, including\n   * `name`, `description`, `user_id`, `group_id`, `application_id` and\n   * `no_principal`.\n   *\n   * @param request - The request {@link UpdatePolicyRequest}\n   * @returns A Promise of Policy\n   */\n  updatePolicy = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdatePolicyRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'PATCH',\n    path: `/iam/v1alpha1/policies/${validatePathParam('policyId', request.policyId)}`\n  }, unmarshalPolicy);\n\n  /**\n   * Delete a policy. Delete a policy. You must define specify the `policy_id`\n   * parameter in your request. Note that when deleting a policy, all\n   * permissions it gives to its principal (user, group or application) will be\n   * revoked.\n   *\n   * @param request - The request {@link DeletePolicyRequest}\n   */\n  deletePolicy = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iam/v1alpha1/policies/${validatePathParam('policyId', request.policyId)}`\n  });\n\n  /**\n   * Clone a policy. Clone a policy. You must define specify the `policy_id`\n   * parameter in your request.\n   *\n   * @param request - The request {@link ClonePolicyRequest}\n   * @returns A Promise of Policy\n   */\n  clonePolicy = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/policies/${validatePathParam('policyId', request.policyId)}/clone`\n  }, unmarshalPolicy);\n\n  /**\n   * Set rules of a given policy. Overwrite the rules of a given policy. Any\n   * information that you add using this command will overwrite the previous\n   * configuration. If you include some of the rules you already had in your\n   * previous configuration in your new one, but you change their order, the new\n   * order of display will apply. While policy rules are ordered, they have no\n   * impact on the access logic of IAM because rules are allow-only.\n   *\n   * @param request - The request {@link SetRulesRequest}\n   * @returns A Promise of SetRulesResponse\n   */\n  setRules = request => this.client.fetch({\n    body: JSON.stringify(marshalSetRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'PUT',\n    path: `/iam/v1alpha1/rules`\n  }, unmarshalSetRulesResponse);\n  pageOfListRules = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/rules`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['policy_id', request.policyId])\n  }, unmarshalListRulesResponse);\n\n  /**\n   * List rules of a given policy. List the rules of a given policy. By default,\n   * the rules listed are ordered by creation date in ascending order. This can\n   * be modified via the `order_by` field. You must define the `policy_id` in\n   * the query path of your request.\n   *\n   * @param request - The request {@link ListRulesRequest}\n   * @returns A Promise of ListRulesResponse\n   */\n  listRules = request => enrichForPagination('rules', this.pageOfListRules, request);\n  pageOfListPermissionSets = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/permission-sets`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'name_asc'], ['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListPermissionSetsResponse);\n\n  /**\n   * List permission sets. List permission sets available for given\n   * Organization. You must define the `organization_id` in the query path of\n   * your request.\n   *\n   * @param request - The request {@link ListPermissionSetsRequest}\n   * @returns A Promise of ListPermissionSetsResponse\n   */\n  listPermissionSets = (request = {}) => enrichForPagination('permissionSets', this.pageOfListPermissionSets, request);\n  pageOfListAPIKeys = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/api-keys`,\n    urlParams: urlParams(['access_key', request.accessKey], ['bearer_id', request.bearerId], ['bearer_type', request.bearerType ?? 'unknown_bearer_type'], ['description', request.description], ['editable', request.editable], ['expired', request.expired], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ...Object.entries(resolveOneOf([{\n      param: 'application_id',\n      value: request.applicationId\n    }, {\n      param: 'user_id',\n      value: request.userId\n    }])))\n  }, unmarshalListAPIKeysResponse);\n\n  /**\n   * List API keys. List API keys. By default, the API keys listed are ordered\n   * by creation date in ascending order. This can be modified via the\n   * `order_by` field. You can define additional parameters for your query such\n   * as `editable`, `expired`, `access_key` and `bearer_id`.\n   *\n   * @param request - The request {@link ListAPIKeysRequest}\n   * @returns A Promise of ListAPIKeysResponse\n   */\n  listAPIKeys = (request = {}) => enrichForPagination('apiKeys', this.pageOfListAPIKeys, request);\n\n  /**\n   * Create an API key. Create an API key. You must specify the `application_id`\n   * or the `user_id` and the description. You can also specify the\n   * `default_project_id` which is the Project ID of your preferred Project, to\n   * use with Object Storage. The `access_key` and `secret_key` values are\n   * returned in the response. Note that he secret key is only showed once. Make\n   * sure that you copy and store both keys somewhere safe.\n   *\n   * @param request - The request {@link CreateAPIKeyRequest}\n   * @returns A Promise of APIKey\n   */\n  createAPIKey = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateAPIKeyRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'POST',\n    path: `/iam/v1alpha1/api-keys`\n  }, unmarshalAPIKey);\n\n  /**\n   * Get an API key. Retrive information about an API key, specified by the\n   * `access_key` parameter. The API key's details, including either the\n   * `user_id` or `application_id` of its bearer are returned in the response.\n   * Note that the string value for the `secret_key` is nullable, and therefore\n   * is not displayed in the response. The `secret_key` value is only displayed\n   * upon API key creation.\n   *\n   * @param request - The request {@link GetAPIKeyRequest}\n   * @returns A Promise of APIKey\n   */\n  getAPIKey = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/api-keys/${validatePathParam('accessKey', request.accessKey)}`\n  }, unmarshalAPIKey);\n\n  /**\n   * Update an API key. Update the parameters of an API key, including\n   * `default_project_id` and `description`.\n   *\n   * @param request - The request {@link UpdateAPIKeyRequest}\n   * @returns A Promise of APIKey\n   */\n  updateAPIKey = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateAPIKeyRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$e,\n    method: 'PATCH',\n    path: `/iam/v1alpha1/api-keys/${validatePathParam('accessKey', request.accessKey)}`\n  }, unmarshalAPIKey);\n\n  /**\n   * Delete an API key. Delete an API key. Note that this action is irreversible\n   * and cannot be undone. Make sure you update any configurations using the API\n   * keys you delete.\n   *\n   * @param request - The request {@link DeleteAPIKeyRequest}\n   */\n  deleteAPIKey = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iam/v1alpha1/api-keys/${validatePathParam('accessKey', request.accessKey)}`\n  });\n  pageOfListQuota = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/quota`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'name_asc'], ['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListQuotaResponse);\n\n  /**\n   * List all quotas in the Organization. List all product and features quota\n   * for an Organization, with their associated limits. By default, the quota\n   * listed are ordered by creation date in ascending order. This can be\n   * modified via the `order_by` field. You must define the `organization_id` in\n   * the query path of your request.\n   *\n   * @param request - The request {@link ListQuotaRequest}\n   * @returns A Promise of ListQuotaResponse\n   */\n  listQuota = (request = {}) => enrichForPagination('quota', this.pageOfListQuota, request);\n\n  /**\n   * Get a quota in the Organization. Retrieve information about a resource\n   * quota, speficified by the `quotum_name` parameter. The quota's `limit`, or\n   * whether it is unlimited, is returned in the response.\n   *\n   * @param request - The request {@link GetQuotumRequest}\n   * @returns A Promise of Quotum\n   */\n  getQuotum = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/quota/${validatePathParam('quotumName', request.quotumName)}`,\n    urlParams: urlParams(['organization_id', request.organizationId ?? this.client.settings.defaultOrganizationId])\n  }, unmarshalQuotum);\n  pageOfListJWTs = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/jwts`,\n    urlParams: urlParams(['audience_id', request.audienceId], ['expired', request.expired], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListJWTsResponse);\n\n  /**\n   * List JWTs.\n   *\n   * @param request - The request {@link ListJWTsRequest}\n   * @returns A Promise of ListJWTsResponse\n   */\n  listJWTs = request => enrichForPagination('jwts', this.pageOfListJWTs, request);\n\n  /**\n   * Get a JWT.\n   *\n   * @param request - The request {@link GetJWTRequest}\n   * @returns A Promise of JWT\n   */\n  getJWT = request => this.client.fetch({\n    method: 'GET',\n    path: `/iam/v1alpha1/jwts/${validatePathParam('jti', request.jti)}`\n  }, unmarshalJWT);\n\n  /**\n   * Delete a JWT.\n   *\n   * @param request - The request {@link DeleteJWTRequest}\n   */\n  deleteJWT = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iam/v1alpha1/jwts/${validatePathParam('jti', request.jti)}`\n  });\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nconst CreateAPIKeyRequest = {\n  description: {\n    ignoreEmpty: true,\n    maxLength: 200\n  }\n};\nconst CreateApplicationRequest = {\n  description: {\n    ignoreEmpty: true,\n    maxLength: 200\n  },\n  name: {\n    maxLength: 64,\n    minLength: 1,\n    pattern: /^[a-zA-Z0-9\\(\\)\\._\\- ]+$/\n  }\n};\nconst CreateGroupRequest = {\n  description: {\n    ignoreEmpty: true,\n    maxLength: 200\n  },\n  name: {\n    maxLength: 64,\n    minLength: 1,\n    pattern: /^[a-zA-Z0-9\\(\\)\\._\\- ]+$/\n  }\n};\nconst CreatePolicyRequest = {\n  description: {\n    ignoreEmpty: true,\n    maxLength: 200\n  },\n  name: {\n    maxLength: 64,\n    minLength: 1,\n    pattern: /^[a-zA-Z0-9\\(\\)\\._\\- ]+$/\n  }\n};\nconst CreateSSHKeyRequest = {\n  name: {\n    ignoreEmpty: true,\n    maxLength: 1000\n  },\n  publicKey: {\n    maxLength: 65000,\n    minLength: 1\n  }\n};\nconst GetQuotumRequest = {\n  quotumName: {\n    minLength: 1\n  }\n};\nconst ListAPIKeysRequest = {\n  description: {\n    maxLength: 200\n  },\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListApplicationsRequest = {\n  name: {\n    maxLength: 64,\n    minLength: 1,\n    pattern: /^[a-zA-Z0-9\\(\\)\\._\\- ]+$/\n  },\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListGroupsRequest = {\n  name: {\n    minLength: 1\n  },\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListJWTsRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListPermissionSetsRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListPoliciesRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  },\n  policyName: {\n    minLength: 1\n  }\n};\nconst ListQuotaRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListRulesRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListSSHKeysRequest = {\n  name: {\n    maxLength: 1000,\n    minLength: 1\n  },\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst ListUsersRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThanOrEqual: 1,\n    lessThanOrEqual: 100\n  }\n};\nconst UpdateAPIKeyRequest = {\n  description: {\n    maxLength: 200\n  }\n};\nconst UpdateApplicationRequest = {\n  description: {\n    maxLength: 200\n  },\n  name: {\n    maxLength: 64,\n    minLength: 1,\n    pattern: /^[a-zA-Z0-9\\(\\)\\._\\- ]+$/\n  }\n};\nconst UpdateGroupRequest = {\n  description: {\n    maxLength: 200\n  },\n  name: {\n    maxLength: 64,\n    minLength: 1,\n    pattern: /^[a-zA-Z0-9\\(\\)\\._\\- ]+$/\n  }\n};\nconst UpdatePolicyRequest = {\n  description: {\n    maxLength: 200\n  },\n  name: {\n    maxLength: 64,\n    minLength: 1,\n    pattern: /^[a-zA-Z0-9\\(\\)\\._\\- ]+$/\n  }\n};\nconst UpdateSSHKeyRequest = {\n  name: {\n    maxLength: 1000\n  }\n};\n\nvar validationRules_gen$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CreateAPIKeyRequest: CreateAPIKeyRequest,\n  CreateApplicationRequest: CreateApplicationRequest,\n  CreateGroupRequest: CreateGroupRequest,\n  CreatePolicyRequest: CreatePolicyRequest,\n  CreateSSHKeyRequest: CreateSSHKeyRequest,\n  GetQuotumRequest: GetQuotumRequest,\n  ListAPIKeysRequest: ListAPIKeysRequest,\n  ListApplicationsRequest: ListApplicationsRequest,\n  ListGroupsRequest: ListGroupsRequest,\n  ListJWTsRequest: ListJWTsRequest,\n  ListPermissionSetsRequest: ListPermissionSetsRequest,\n  ListPoliciesRequest: ListPoliciesRequest,\n  ListQuotaRequest: ListQuotaRequest,\n  ListRulesRequest: ListRulesRequest,\n  ListSSHKeysRequest: ListSSHKeysRequest,\n  ListUsersRequest: ListUsersRequest,\n  UpdateAPIKeyRequest: UpdateAPIKeyRequest,\n  UpdateApplicationRequest: UpdateApplicationRequest,\n  UpdateGroupRequest: UpdateGroupRequest,\n  UpdatePolicyRequest: UpdatePolicyRequest,\n  UpdateSSHKeyRequest: UpdateSSHKeyRequest\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$d = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$g,\n  ValidationRules: validationRules_gen$2\n});\n\nvar index$i = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1alpha1: index_gen$d\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalServerSummary = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerSummary' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name\n  };\n};\nconst unmarshalBootscript = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Bootscript' failed as data isn't a dictionary.`);\n  }\n  return {\n    arch: data.arch,\n    bootcmdargs: data.bootcmdargs,\n    default: data.default,\n    dtb: data.dtb,\n    id: data.id,\n    initrd: data.initrd,\n    kernel: data.kernel,\n    organization: data.organization,\n    project: data.project,\n    public: data.public,\n    title: data.title,\n    zone: data.zone\n  };\n};\nconst unmarshalServerTypeNetworkInterface = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeNetworkInterface' failed as data isn't a dictionary.`);\n  }\n  return {\n    internalBandwidth: data.internal_bandwidth,\n    internetBandwidth: data.internet_bandwidth\n  };\n};\nconst unmarshalServerTypeVolumeConstraintSizes = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeVolumeConstraintSizes' failed as data isn't a dictionary.`);\n  }\n  return {\n    maxSize: data.max_size,\n    minSize: data.min_size\n  };\n};\nconst unmarshalVolume$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Volume' failed as data isn't a dictionary.`);\n  }\n  return {\n    creationDate: unmarshalDate(data.creation_date),\n    exportUri: data.export_uri,\n    id: data.id,\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name,\n    organization: data.organization,\n    project: data.project,\n    server: data.server ? unmarshalServerSummary(data.server) : undefined,\n    size: data.size,\n    state: data.state,\n    tags: data.tags,\n    volumeType: data.volume_type,\n    zone: data.zone\n  };\n};\nconst unmarshalVolumeSummary = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'VolumeSummary' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name,\n    size: data.size,\n    volumeType: data.volume_type\n  };\n};\nconst unmarshalImage$3 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Image' failed as data isn't a dictionary.`);\n  }\n  return {\n    arch: data.arch,\n    creationDate: unmarshalDate(data.creation_date),\n    defaultBootscript: data.default_bootscript ? unmarshalBootscript(data.default_bootscript) : undefined,\n    extraVolumes: unmarshalMapOfObject(data.extra_volumes, unmarshalVolume$1),\n    fromServer: data.from_server,\n    id: data.id,\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name,\n    organization: data.organization,\n    project: data.project,\n    public: data.public,\n    rootVolume: data.root_volume ? unmarshalVolumeSummary(data.root_volume) : undefined,\n    state: data.state,\n    tags: data.tags,\n    zone: data.zone\n  };\n};\nconst unmarshalPlacementGroup = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PlacementGroup' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name,\n    organization: data.organization,\n    policyMode: data.policy_mode,\n    policyRespected: data.policy_respected,\n    policyType: data.policy_type,\n    project: data.project,\n    tags: data.tags,\n    zone: data.zone\n  };\n};\nconst unmarshalPrivateNIC = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrivateNIC' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    macAddress: data.mac_address,\n    privateNetworkId: data.private_network_id,\n    serverId: data.server_id,\n    state: data.state,\n    tags: data.tags\n  };\n};\nconst unmarshalSecurityGroupSummary = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SecurityGroupSummary' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name\n  };\n};\nconst unmarshalServerIp = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerIp' failed as data isn't a dictionary.`);\n  }\n  return {\n    address: data.address,\n    dynamic: data.dynamic,\n    id: data.id\n  };\n};\nconst unmarshalServerIpv6 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerIpv6' failed as data isn't a dictionary.`);\n  }\n  return {\n    address: data.address,\n    gateway: data.gateway,\n    netmask: data.netmask\n  };\n};\nconst unmarshalServerLocation = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerLocation' failed as data isn't a dictionary.`);\n  }\n  return {\n    clusterId: data.cluster_id,\n    hypervisorId: data.hypervisor_id,\n    nodeId: data.node_id,\n    platformId: data.platform_id,\n    zoneId: data.zone_id\n  };\n};\nconst unmarshalServerMaintenance = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerMaintenance' failed as data isn't a dictionary.`);\n  }\n  return {\n    reason: data.reason\n  };\n};\nconst unmarshalServerTypeCapabilities = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeCapabilities' failed as data isn't a dictionary.`);\n  }\n  return {\n    blockStorage: data.block_storage,\n    bootTypes: data.boot_types\n  };\n};\nconst unmarshalServerTypeNetwork = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeNetwork' failed as data isn't a dictionary.`);\n  }\n  return {\n    interfaces: unmarshalArrayOfObject(data.interfaces, unmarshalServerTypeNetworkInterface),\n    ipv6Support: data.ipv6_support,\n    sumInternalBandwidth: data.sum_internal_bandwidth,\n    sumInternetBandwidth: data.sum_internet_bandwidth\n  };\n};\nconst unmarshalServerTypeVolumeConstraintsByType = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerTypeVolumeConstraintsByType' failed as data isn't a dictionary.`);\n  }\n  return {\n    lSsd: data.l_ssd ? unmarshalServerTypeVolumeConstraintSizes(data.l_ssd) : undefined\n  };\n};\nconst unmarshalSnapshotBaseVolume = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SnapshotBaseVolume' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name\n  };\n};\nconst unmarshalVolumeServer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'VolumeServer' failed as data isn't a dictionary.`);\n  }\n  return {\n    boot: data.boot,\n    creationDate: unmarshalDate(data.creation_date),\n    exportUri: data.export_uri,\n    id: data.id,\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name,\n    organization: data.organization,\n    project: data.project,\n    server: data.server ? unmarshalServerSummary(data.server) : undefined,\n    size: data.size,\n    state: data.state,\n    volumeType: data.volume_type,\n    zone: data.zone\n  };\n};\nconst unmarshalVolumeTypeCapabilities = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'VolumeTypeCapabilities' failed as data isn't a dictionary.`);\n  }\n  return {\n    snapshot: data.snapshot\n  };\n};\nconst unmarshalVolumeTypeConstraints = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'VolumeTypeConstraints' failed as data isn't a dictionary.`);\n  }\n  return {\n    max: data.max,\n    min: data.min\n  };\n};\nconst unmarshalDashboard = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Dashboard' failed as data isn't a dictionary.`);\n  }\n  return {\n    imagesCount: data.images_count,\n    ipsCount: data.ips_count,\n    ipsUnused: data.ips_unused,\n    placementGroupsCount: data.placement_groups_count,\n    privateNicsCount: data.private_nics_count,\n    runningServersCount: data.running_servers_count,\n    securityGroupsCount: data.security_groups_count,\n    serversByTypes: data.servers_by_types,\n    serversCount: data.servers_count,\n    snapshotsCount: data.snapshots_count,\n    volumesBSsdCount: data.volumes_b_ssd_count,\n    volumesBSsdTotalSize: data.volumes_b_ssd_total_size,\n    volumesCount: data.volumes_count,\n    volumesLSsdCount: data.volumes_l_ssd_count,\n    volumesLSsdTotalSize: data.volumes_l_ssd_total_size\n  };\n};\nconst unmarshalGetServerTypesAvailabilityResponseAvailability = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetServerTypesAvailabilityResponseAvailability' failed as data isn't a dictionary.`);\n  }\n  return {\n    availability: data.availability\n  };\n};\nconst unmarshalIp$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Ip' failed as data isn't a dictionary.`);\n  }\n  return {\n    address: data.address,\n    id: data.id,\n    organization: data.organization,\n    project: data.project,\n    reverse: data.reverse,\n    server: data.server ? unmarshalServerSummary(data.server) : undefined,\n    tags: data.tags,\n    zone: data.zone\n  };\n};\nconst unmarshalPlacementGroupServer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PlacementGroupServer' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name,\n    policyRespected: data.policy_respected\n  };\n};\nconst unmarshalSecurityGroup = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SecurityGroup' failed as data isn't a dictionary.`);\n  }\n  return {\n    creationDate: unmarshalDate(data.creation_date),\n    description: data.description,\n    enableDefaultSecurity: data.enable_default_security,\n    id: data.id,\n    inboundDefaultPolicy: data.inbound_default_policy,\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name,\n    organization: data.organization,\n    organizationDefault: data.organization_default,\n    outboundDefaultPolicy: data.outbound_default_policy,\n    project: data.project,\n    projectDefault: data.project_default,\n    servers: unmarshalArrayOfObject(data.servers, unmarshalServerSummary),\n    state: data.state,\n    stateful: data.stateful,\n    tags: data.tags,\n    zone: data.zone\n  };\n};\nconst unmarshalSecurityGroupRule = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SecurityGroupRule' failed as data isn't a dictionary.`);\n  }\n  return {\n    action: data.action,\n    destPortFrom: data.dest_port_from,\n    destPortTo: data.dest_port_to,\n    direction: data.direction,\n    editable: data.editable,\n    id: data.id,\n    ipRange: data.ip_range,\n    position: data.position,\n    protocol: data.protocol,\n    zone: data.zone\n  };\n};\nconst unmarshalServer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Server' failed as data isn't a dictionary.`);\n  }\n  return {\n    allowedActions: data.allowed_actions,\n    arch: data.arch,\n    bootscript: data.bootscript ? unmarshalBootscript(data.bootscript) : undefined,\n    bootType: data.boot_type,\n    commercialType: data.commercial_type,\n    creationDate: unmarshalDate(data.creation_date),\n    dynamicIpRequired: data.dynamic_ip_required,\n    enableIpv6: data.enable_ipv6,\n    hostname: data.hostname,\n    id: data.id,\n    image: data.image ? unmarshalImage$3(data.image) : undefined,\n    ipv6: data.ipv6 ? unmarshalServerIpv6(data.ipv6) : undefined,\n    location: data.location ? unmarshalServerLocation(data.location) : undefined,\n    maintenances: unmarshalArrayOfObject(data.maintenances, unmarshalServerMaintenance),\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name,\n    organization: data.organization,\n    placementGroup: data.placement_group ? unmarshalPlacementGroup(data.placement_group) : undefined,\n    privateIp: data.private_ip,\n    privateNics: unmarshalArrayOfObject(data.private_nics, unmarshalPrivateNIC),\n    project: data.project,\n    protected: data.protected,\n    publicIp: data.public_ip ? unmarshalServerIp(data.public_ip) : undefined,\n    securityGroup: data.security_group ? unmarshalSecurityGroupSummary(data.security_group) : undefined,\n    state: data.state,\n    stateDetail: data.state_detail,\n    tags: data.tags,\n    volumes: unmarshalMapOfObject(data.volumes, unmarshalVolumeServer),\n    zone: data.zone\n  };\n};\nconst unmarshalServerType = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerType' failed as data isn't a dictionary.`);\n  }\n  return {\n    altNames: data.alt_names,\n    arch: data.arch,\n    baremetal: data.baremetal,\n    capabilities: data.capabilities ? unmarshalServerTypeCapabilities(data.capabilities) : undefined,\n    gpu: data.gpu,\n    hourlyPrice: data.hourly_price,\n    monthlyPrice: data.monthly_price,\n    ncpus: data.ncpus,\n    network: data.network ? unmarshalServerTypeNetwork(data.network) : undefined,\n    perVolumeConstraint: data.per_volume_constraint ? unmarshalServerTypeVolumeConstraintsByType(data.per_volume_constraint) : undefined,\n    ram: data.ram,\n    volumesConstraint: data.volumes_constraint ? unmarshalServerTypeVolumeConstraintSizes(data.volumes_constraint) : undefined\n  };\n};\nconst unmarshalSnapshot$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Snapshot' failed as data isn't a dictionary.`);\n  }\n  return {\n    baseVolume: data.base_volume ? unmarshalSnapshotBaseVolume(data.base_volume) : undefined,\n    creationDate: unmarshalDate(data.creation_date),\n    errorReason: data.error_reason,\n    id: data.id,\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name,\n    organization: data.organization,\n    project: data.project,\n    size: data.size,\n    state: data.state,\n    tags: data.tags,\n    volumeType: data.volume_type,\n    zone: data.zone\n  };\n};\nconst unmarshalTask = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Task' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    hrefFrom: data.href_from,\n    hrefResult: data.href_result,\n    id: data.id,\n    progress: data.progress,\n    startedAt: unmarshalDate(data.started_at),\n    status: data.status,\n    terminatedAt: unmarshalDate(data.terminated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalVolumeType = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'VolumeType' failed as data isn't a dictionary.`);\n  }\n  return {\n    capabilities: data.capabilities ? unmarshalVolumeTypeCapabilities(data.capabilities) : undefined,\n    constraints: data.constraints ? unmarshalVolumeTypeConstraints(data.constraints) : undefined,\n    displayName: data.display_name\n  };\n};\nconst unmarshalCreateImageResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateImageResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    image: data.image ? unmarshalImage$3(data.image) : undefined\n  };\n};\nconst unmarshalCreateIpResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateIpResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ip: data.ip ? unmarshalIp$1(data.ip) : undefined\n  };\n};\nconst unmarshalCreatePlacementGroupResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreatePlacementGroupResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    placementGroup: data.placement_group ? unmarshalPlacementGroup(data.placement_group) : undefined\n  };\n};\nconst unmarshalCreatePrivateNICResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreatePrivateNICResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    privateNic: data.private_nic ? unmarshalPrivateNIC(data.private_nic) : undefined\n  };\n};\nconst unmarshalCreateSecurityGroupResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateSecurityGroupResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    securityGroup: data.security_group ? unmarshalSecurityGroup(data.security_group) : undefined\n  };\n};\nconst unmarshalCreateSecurityGroupRuleResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateSecurityGroupRuleResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rule: data.rule ? unmarshalSecurityGroupRule(data.rule) : undefined\n  };\n};\nconst unmarshalCreateServerResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateServerResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    server: data.server ? unmarshalServer(data.server) : undefined\n  };\n};\nconst unmarshalCreateSnapshotResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateSnapshotResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    snapshot: data.snapshot ? unmarshalSnapshot$1(data.snapshot) : undefined,\n    task: data.task ? unmarshalTask(data.task) : undefined\n  };\n};\nconst unmarshalCreateVolumeResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateVolumeResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    volume: data.volume ? unmarshalVolume$1(data.volume) : undefined\n  };\n};\nconst unmarshalExportSnapshotResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ExportSnapshotResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    task: data.task ? unmarshalTask(data.task) : undefined\n  };\n};\nconst unmarshalGetBootscriptResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetBootscriptResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    bootscript: data.bootscript ? unmarshalBootscript(data.bootscript) : undefined\n  };\n};\nconst unmarshalGetDashboardResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetDashboardResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    dashboard: data.dashboard ? unmarshalDashboard(data.dashboard) : undefined\n  };\n};\nconst unmarshalGetImageResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetImageResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    image: data.image ? unmarshalImage$3(data.image) : undefined\n  };\n};\nconst unmarshalGetIpResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetIpResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ip: data.ip ? unmarshalIp$1(data.ip) : undefined\n  };\n};\nconst unmarshalGetPlacementGroupResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetPlacementGroupResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    placementGroup: data.placement_group ? unmarshalPlacementGroup(data.placement_group) : undefined\n  };\n};\nconst unmarshalGetPlacementGroupServersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetPlacementGroupServersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalArrayOfObject(data.servers, unmarshalPlacementGroupServer)\n  };\n};\nconst unmarshalGetPrivateNICResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetPrivateNICResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    privateNic: data.private_nic ? unmarshalPrivateNIC(data.private_nic) : undefined\n  };\n};\nconst unmarshalGetSecurityGroupResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetSecurityGroupResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    securityGroup: data.security_group ? unmarshalSecurityGroup(data.security_group) : undefined\n  };\n};\nconst unmarshalGetSecurityGroupRuleResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetSecurityGroupRuleResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rule: data.rule ? unmarshalSecurityGroupRule(data.rule) : undefined\n  };\n};\nconst unmarshalGetServerResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetServerResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    server: data.server ? unmarshalServer(data.server) : undefined\n  };\n};\nconst unmarshalGetServerTypesAvailabilityResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetServerTypesAvailabilityResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalMapOfObject(data.servers, unmarshalGetServerTypesAvailabilityResponseAvailability)\n  };\n};\nconst unmarshalGetSnapshotResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetSnapshotResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    snapshot: data.snapshot ? unmarshalSnapshot$1(data.snapshot) : undefined\n  };\n};\nconst unmarshalGetVolumeResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetVolumeResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    volume: data.volume ? unmarshalVolume$1(data.volume) : undefined\n  };\n};\nconst unmarshalListBootscriptsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListBootscriptsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    bootscripts: unmarshalArrayOfObject(data.bootscripts, unmarshalBootscript),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListImagesResponse$3 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    images: unmarshalArrayOfObject(data.images, unmarshalImage$3),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListIpsResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListIpsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ips: unmarshalArrayOfObject(data.ips, unmarshalIp$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPlacementGroupsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPlacementGroupsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    placementGroups: unmarshalArrayOfObject(data.placement_groups, unmarshalPlacementGroup),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPrivateNICsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPrivateNICsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    privateNics: unmarshalArrayOfObject(data.private_nics, unmarshalPrivateNIC),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSecurityGroupRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSecurityGroupRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalSecurityGroupRule),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSecurityGroupsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSecurityGroupsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    securityGroups: unmarshalArrayOfObject(data.security_groups, unmarshalSecurityGroup),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListServerActionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServerActionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    actions: data.actions\n  };\n};\nconst unmarshalListServerUserDataResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServerUserDataResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    userData: data.user_data\n  };\n};\nconst unmarshalListServersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalArrayOfObject(data.servers, unmarshalServer),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListServersTypesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListServersTypesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalMapOfObject(data.servers, unmarshalServerType),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSnapshotsResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSnapshotsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    snapshots: unmarshalArrayOfObject(data.snapshots, unmarshalSnapshot$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListVolumesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListVolumesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    volumes: unmarshalArrayOfObject(data.volumes, unmarshalVolume$1)\n  };\n};\nconst unmarshalListVolumesTypesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListVolumesTypesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    volumes: unmarshalMapOfObject(data.volumes, unmarshalVolumeType)\n  };\n};\nconst unmarshalServerActionResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ServerActionResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    task: data.task ? unmarshalTask(data.task) : undefined\n  };\n};\nconst unmarshalSetImageResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetImageResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    image: data.image ? unmarshalImage$3(data.image) : undefined\n  };\n};\nconst unmarshalSetPlacementGroupResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetPlacementGroupResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    placementGroup: data.placement_group ? unmarshalPlacementGroup(data.placement_group) : undefined\n  };\n};\nconst unmarshalSetPlacementGroupServersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetPlacementGroupServersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalArrayOfObject(data.servers, unmarshalPlacementGroupServer)\n  };\n};\nconst unmarshalSetSecurityGroupResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetSecurityGroupResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    securityGroup: data.security_group ? unmarshalSecurityGroup(data.security_group) : undefined\n  };\n};\nconst unmarshalSetSecurityGroupRuleResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetSecurityGroupRuleResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rule: data.rule ? unmarshalSecurityGroupRule(data.rule) : undefined\n  };\n};\nconst unmarshalSetSecurityGroupRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetSecurityGroupRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalSecurityGroupRule)\n  };\n};\nconst unmarshalSetServerResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetServerResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    server: data.server ? unmarshalServer(data.server) : undefined\n  };\n};\nconst unmarshalSetSnapshotResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetSnapshotResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    snapshot: data.snapshot ? unmarshalSnapshot$1(data.snapshot) : undefined\n  };\n};\nconst unmarshalUpdateIpResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpdateIpResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ip: data.ip ? unmarshalIp$1(data.ip) : undefined\n  };\n};\nconst unmarshalUpdatePlacementGroupResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpdatePlacementGroupResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    placementGroup: data.placement_group ? unmarshalPlacementGroup(data.placement_group) : undefined\n  };\n};\nconst unmarshalUpdatePlacementGroupServersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpdatePlacementGroupServersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    servers: unmarshalArrayOfObject(data.servers, unmarshalPlacementGroupServer)\n  };\n};\nconst unmarshalUpdateServerResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpdateServerResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    server: data.server ? unmarshalServer(data.server) : undefined\n  };\n};\nconst unmarshalUpdateVolumeResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpdateVolumeResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    volume: data.volume ? unmarshalVolume$1(data.volume) : undefined\n  };\n};\nconst marshalServerSummary$1 = (request, defaults) => ({\n  id: request.id,\n  name: request.name\n});\nconst marshalBootscript$1 = (request, defaults) => ({\n  arch: request.arch,\n  bootcmdargs: request.bootcmdargs,\n  default: request.default,\n  dtb: request.dtb,\n  id: request.id,\n  initrd: request.initrd,\n  kernel: request.kernel,\n  organization: request.organization,\n  project: request.project,\n  public: request.public,\n  title: request.title,\n  zone: request.zone\n});\nconst marshalVolume$1 = (request, defaults) => ({\n  creation_date: request.creationDate,\n  export_uri: request.exportUri,\n  id: request.id,\n  modification_date: request.modificationDate,\n  name: request.name,\n  organization: request.organization,\n  project: request.project,\n  server: request.server ? marshalServerSummary$1(request.server) : undefined,\n  size: request.size,\n  state: request.state,\n  tags: request.tags,\n  volume_type: request.volumeType,\n  zone: request.zone\n});\nconst marshalVolumeSummary$1 = (request, defaults) => ({\n  id: request.id,\n  name: request.name,\n  size: request.size,\n  volume_type: request.volumeType\n});\nconst marshalImage = (request, defaults) => ({\n  arch: request.arch,\n  creation_date: request.creationDate,\n  default_bootscript: request.defaultBootscript ? marshalBootscript$1(request.defaultBootscript) : undefined,\n  extra_volumes: Object.entries(request.extraVolumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalVolume$1(value)\n  }), {}),\n  from_server: request.fromServer,\n  id: request.id,\n  modification_date: request.modificationDate,\n  name: request.name,\n  organization: request.organization,\n  project: request.project,\n  public: request.public,\n  root_volume: request.rootVolume ? marshalVolumeSummary$1(request.rootVolume) : undefined,\n  state: request.state,\n  tags: request.tags,\n  zone: request.zone\n});\nconst marshalPlacementGroup = (request, defaults) => ({\n  id: request.id,\n  name: request.name,\n  organization: request.organization,\n  policy_mode: request.policyMode,\n  policy_respected: request.policyRespected,\n  policy_type: request.policyType,\n  project: request.project,\n  tags: request.tags,\n  zone: request.zone\n});\nconst marshalPrivateNIC = (request, defaults) => ({\n  id: request.id,\n  mac_address: request.macAddress,\n  private_network_id: request.privateNetworkId,\n  server_id: request.serverId,\n  state: request.state,\n  tags: request.tags\n});\nconst marshalSecurityGroupSummary = (request, defaults) => ({\n  id: request.id,\n  name: request.name\n});\nconst marshalSecurityGroupTemplate = (request, defaults) => ({\n  id: request.id,\n  name: request.name\n});\nconst marshalServerActionRequestVolumeBackupTemplate = (request, defaults) => ({\n  volume_type: request.volumeType\n});\nconst marshalServerIp = (request, defaults) => ({\n  address: request.address,\n  dynamic: request.dynamic,\n  id: request.id\n});\nconst marshalServerIpv6 = (request, defaults) => ({\n  address: request.address,\n  gateway: request.gateway,\n  netmask: request.netmask\n});\nconst marshalServerLocation = (request, defaults) => ({\n  cluster_id: request.clusterId,\n  hypervisor_id: request.hypervisorId,\n  node_id: request.nodeId,\n  platform_id: request.platformId,\n  zone_id: request.zoneId\n});\nconst marshalServerMaintenance = (request, defaults) => ({\n  reason: request.reason\n});\nconst marshalSetSecurityGroupRulesRequestRule = (request, defaults) => ({\n  action: request.action,\n  dest_port_from: request.destPortFrom,\n  dest_port_to: request.destPortTo,\n  direction: request.direction,\n  editable: request.editable,\n  id: request.id,\n  ip_range: request.ipRange,\n  position: request.position,\n  protocol: request.protocol,\n  zone: request.zone\n});\nconst marshalSnapshotBaseVolume = (request, defaults) => ({\n  id: request.id,\n  name: request.name\n});\nconst marshalVolumeServerTemplate = (request, defaults) => ({\n  base_snapshot: request.baseSnapshot,\n  boot: request.boot,\n  id: request.id,\n  name: request.name,\n  organization: request.organization,\n  project: request.project,\n  size: request.size,\n  volume_type: request.volumeType\n});\nconst marshalVolumeTemplate = (request, defaults) => ({\n  id: request.id,\n  name: request.name,\n  size: request.size,\n  volume_type: request.volumeType,\n  ...resolveOneOf([{\n    param: 'project',\n    value: request.project\n  }, {\n    param: 'organization',\n    value: request.organization\n  }])\n});\nconst marshalCreateImageRequest = (request, defaults) => ({\n  arch: request.arch,\n  default_bootscript: request.defaultBootscript,\n  extra_volumes: request.extraVolumes ? Object.entries(request.extraVolumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalVolumeTemplate(value)\n  }), {}) : undefined,\n  name: request.name || randomName('img'),\n  public: request.public,\n  root_volume: request.rootVolume,\n  tags: request.tags,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project',\n    value: request.project\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization',\n    value: request.organization\n  }])\n});\nconst marshalCreateIpRequest$1 = (request, defaults) => ({\n  server: request.server,\n  tags: request.tags,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project',\n    value: request.project\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization',\n    value: request.organization\n  }])\n});\nconst marshalCreatePlacementGroupRequest = (request, defaults) => ({\n  name: request.name || randomName('pg'),\n  policy_mode: request.policyMode ?? 'optional',\n  policy_type: request.policyType ?? 'max_availability',\n  tags: request.tags,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project',\n    value: request.project\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization',\n    value: request.organization\n  }])\n});\nconst marshalCreatePrivateNICRequest = (request, defaults) => ({\n  private_network_id: request.privateNetworkId,\n  tags: request.tags\n});\nconst marshalCreateSecurityGroupRequest = (request, defaults) => ({\n  description: request.description,\n  enable_default_security: request.enableDefaultSecurity,\n  inbound_default_policy: request.inboundDefaultPolicy ?? 'accept',\n  name: request.name || randomName('sg'),\n  outbound_default_policy: request.outboundDefaultPolicy ?? 'accept',\n  stateful: request.stateful,\n  tags: request.tags,\n  ...resolveOneOf([{\n    param: 'organization_default',\n    value: request.organizationDefault\n  }, {\n    param: 'project_default',\n    value: request.projectDefault\n  }]),\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project',\n    value: request.project\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization',\n    value: request.organization\n  }])\n});\nconst marshalCreateSecurityGroupRuleRequest = (request, defaults) => ({\n  action: request.action,\n  dest_port_from: request.destPortFrom,\n  dest_port_to: request.destPortTo,\n  direction: request.direction,\n  editable: request.editable,\n  ip_range: request.ipRange,\n  position: request.position,\n  protocol: request.protocol\n});\nconst marshalCreateServerRequest = (request, defaults) => ({\n  boot_type: request.bootType,\n  bootscript: request.bootscript,\n  commercial_type: request.commercialType,\n  dynamic_ip_required: request.dynamicIpRequired,\n  enable_ipv6: request.enableIpv6,\n  image: request.image,\n  name: request.name || randomName('srv'),\n  placement_group: request.placementGroup,\n  public_ip: request.publicIp,\n  security_group: request.securityGroup,\n  tags: request.tags,\n  volumes: request.volumes ? Object.entries(request.volumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalVolumeServerTemplate(value)\n  }), {}) : undefined,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project',\n    value: request.project\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization',\n    value: request.organization\n  }])\n});\nconst marshalCreateSnapshotRequest$1 = (request, defaults) => ({\n  bucket: request.bucket,\n  key: request.key,\n  name: request.name || randomName('snp'),\n  size: request.size,\n  tags: request.tags,\n  volume_id: request.volumeId,\n  volume_type: request.volumeType ?? 'unknown_volume_type',\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project',\n    value: request.project\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization',\n    value: request.organization\n  }])\n});\nconst marshalCreateVolumeRequest = (request, defaults) => ({\n  name: request.name || randomName('vol'),\n  tags: request.tags,\n  volume_type: request.volumeType ?? 'l_ssd',\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project',\n    value: request.project\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization',\n    value: request.organization\n  }]),\n  ...resolveOneOf([{\n    param: 'size',\n    value: request.size\n  }, {\n    param: 'base_volume',\n    value: request.baseVolume\n  }, {\n    param: 'base_snapshot',\n    value: request.baseSnapshot\n  }])\n});\nconst marshalExportSnapshotRequest = (request, defaults) => ({\n  bucket: request.bucket,\n  key: request.key\n});\nconst marshalServerActionRequest = (request, defaults) => ({\n  action: request.action ?? 'poweron',\n  name: request.name,\n  volumes: request.volumes ? Object.entries(request.volumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalServerActionRequestVolumeBackupTemplate(value)\n  }), {}) : undefined\n});\nconst marshalSetImageRequest = (request, defaults) => ({\n  arch: request.arch,\n  creation_date: request.creationDate,\n  default_bootscript: request.defaultBootscript ? marshalBootscript$1(request.defaultBootscript) : undefined,\n  extra_volumes: request.extraVolumes ? Object.entries(request.extraVolumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalVolume$1(value)\n  }), {}) : undefined,\n  from_server: request.fromServer,\n  modification_date: request.modificationDate,\n  name: request.name,\n  organization: request.organization,\n  project: request.project,\n  public: request.public,\n  root_volume: request.rootVolume ? marshalVolumeSummary$1(request.rootVolume) : undefined,\n  state: request.state,\n  tags: request.tags\n});\nconst marshalSetPlacementGroupRequest = (request, defaults) => ({\n  name: request.name,\n  organization: request.organization,\n  policy_mode: request.policyMode,\n  policy_type: request.policyType,\n  project: request.project,\n  tags: request.tags\n});\nconst marshalSetPlacementGroupServersRequest = (request, defaults) => ({\n  servers: request.servers\n});\nconst marshalSetSecurityGroupRequest = (request, defaults) => ({\n  creation_date: request.creationDate,\n  description: request.description,\n  enable_default_security: request.enableDefaultSecurity,\n  inbound_default_policy: request.inboundDefaultPolicy,\n  modification_date: request.modificationDate,\n  name: request.name,\n  organization: request.organization,\n  organization_default: request.organizationDefault,\n  outbound_default_policy: request.outboundDefaultPolicy,\n  project: request.project,\n  project_default: request.projectDefault,\n  servers: request.servers ? request.servers.map(elt => marshalServerSummary$1(elt)) : undefined,\n  stateful: request.stateful,\n  tags: request.tags\n});\nconst marshalSetSecurityGroupRuleRequest = (request, defaults) => ({\n  action: request.action,\n  dest_port_from: request.destPortFrom,\n  dest_port_to: request.destPortTo,\n  direction: request.direction,\n  editable: request.editable,\n  id: request.id,\n  ip_range: request.ipRange,\n  position: request.position,\n  protocol: request.protocol\n});\nconst marshalSetSecurityGroupRulesRequest = (request, defaults) => ({\n  rules: request.rules ? request.rules.map(elt => marshalSetSecurityGroupRulesRequestRule(elt)) : undefined\n});\nconst marshalSetServerRequest = (request, defaults) => ({\n  allowed_actions: request.allowedActions,\n  arch: request.arch,\n  boot_type: request.bootType,\n  bootscript: request.bootscript ? marshalBootscript$1(request.bootscript) : undefined,\n  commercial_type: request.commercialType,\n  creation_date: request.creationDate,\n  dynamic_ip_required: request.dynamicIpRequired,\n  enable_ipv6: request.enableIpv6,\n  hostname: request.hostname,\n  image: request.image ? marshalImage(request.image) : undefined,\n  ipv6: request.ipv6 ? marshalServerIpv6(request.ipv6) : undefined,\n  location: request.location ? marshalServerLocation(request.location) : undefined,\n  maintenances: request.maintenances ? request.maintenances.map(elt => marshalServerMaintenance(elt)) : undefined,\n  modification_date: request.modificationDate,\n  name: request.name,\n  organization: request.organization,\n  placement_group: request.placementGroup ? marshalPlacementGroup(request.placementGroup) : undefined,\n  private_ip: request.privateIp,\n  private_nics: request.privateNics ? request.privateNics.map(elt => marshalPrivateNIC(elt)) : undefined,\n  project: request.project,\n  protected: request.protected,\n  public_ip: request.publicIp ? marshalServerIp(request.publicIp) : undefined,\n  security_group: request.securityGroup ? marshalSecurityGroupSummary(request.securityGroup) : undefined,\n  state: request.state,\n  state_detail: request.stateDetail,\n  tags: request.tags,\n  volumes: request.volumes ? Object.entries(request.volumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalVolume$1(value)\n  }), {}) : undefined\n});\nconst marshalSetSnapshotRequest = (request, defaults) => ({\n  base_volume: request.baseVolume ? marshalSnapshotBaseVolume(request.baseVolume) : undefined,\n  creation_date: request.creationDate,\n  id: request.id,\n  modification_date: request.modificationDate,\n  name: request.name,\n  organization: request.organization,\n  project: request.project,\n  size: request.size,\n  state: request.state,\n  tags: request.tags,\n  volume_type: request.volumeType\n});\nconst marshalUpdateIpRequest$1 = (request, defaults) => ({\n  reverse: request.reverse,\n  server: request.server,\n  tags: request.tags\n});\nconst marshalUpdatePlacementGroupRequest = (request, defaults) => ({\n  name: request.name,\n  policy_mode: request.policyMode,\n  policy_type: request.policyType,\n  tags: request.tags\n});\nconst marshalUpdatePlacementGroupServersRequest = (request, defaults) => ({\n  servers: request.servers\n});\nconst marshalUpdatePrivateNICRequest = (request, defaults) => ({\n  tags: request.tags\n});\nconst marshalUpdateServerRequest = (request, defaults) => ({\n  boot_type: request.bootType,\n  bootscript: request.bootscript,\n  dynamic_ip_required: request.dynamicIpRequired,\n  enable_ipv6: request.enableIpv6,\n  name: request.name,\n  placement_group: request.placementGroup,\n  private_nics: request.privateNics ? request.privateNics.map(elt => marshalPrivateNIC(elt)) : undefined,\n  protected: request.protected,\n  security_group: request.securityGroup ? marshalSecurityGroupTemplate(request.securityGroup) : undefined,\n  tags: request.tags,\n  volumes: request.volumes ? Object.entries(request.volumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalVolumeServerTemplate(value)\n  }), {}) : undefined\n});\nconst marshalUpdateVolumeRequest = (request, defaults) => ({\n  name: request.name,\n  size: request.size,\n  tags: request.tags\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$d = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Instance API. */\nlet API$f = class API extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-1', 'fr-par-2', 'fr-par-3', 'nl-ams-1', 'nl-ams-2', 'pl-waw-1', 'pl-waw-2'];\n\n  /**\n   * Get availability. Get availability for all Instance types.\n   *\n   * @param request - The request {@link GetServerTypesAvailabilityRequest}\n   * @returns A Promise of GetServerTypesAvailabilityResponse\n   */\n  getServerTypesAvailability = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/products/servers/availability`,\n    urlParams: urlParams(['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize])\n  }, unmarshalGetServerTypesAvailabilityResponse);\n\n  /**\n   * List Instance types. List available Instance types and their technical\n   * details.\n   *\n   * @param request - The request {@link ListServersTypesRequest}\n   * @returns A Promise of ListServersTypesResponse\n   */\n  listServersTypes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/products/servers`,\n    urlParams: urlParams(['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize])\n  }, unmarshalListServersTypesResponse);\n\n  /**\n   * List volume types. List all volume types and their technical details.\n   *\n   * @param request - The request {@link ListVolumesTypesRequest}\n   * @returns A Promise of ListVolumesTypesResponse\n   */\n  listVolumesTypes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/products/volumes`,\n    urlParams: urlParams(['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize])\n  }, unmarshalListVolumesTypesResponse);\n  pageOfListServers = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers`,\n    urlParams: urlParams(['commercial_type', request.commercialType], ['name', request.name], ['order', request.order], ['organization', request.organization], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['private_ip', request.privateIp], ['private_network', request.privateNetwork], ['project', request.project], ['state', request.state], ['tags', request.tags && request.tags.length > 0 ? request.tags.join(',') : undefined], ['without_ip', request.withoutIp])\n  }, unmarshalListServersResponse);\n\n  /**\n   * List all Instances. List all Instances in a specified Availability Zone,\n   * e.g. `fr-par-1`.\n   *\n   * @param request - The request {@link ListServersRequest}\n   * @returns A Promise of ListServersResponse\n   */\n  listServers = (request = {}) => enrichForPagination('servers', this.pageOfListServers, request);\n  _createServer = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateServerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers`\n  }, unmarshalCreateServerResponse);\n\n  /**\n   * Delete an Instance. Delete the Instance with the specified ID.\n   *\n   * @param request - The request {@link DeleteServerRequest}\n   */\n  deleteServer = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  });\n\n  /**\n   * Get an Instance. Get the details of a specified Instance.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @returns A Promise of GetServerResponse\n   */\n  getServer = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  }, unmarshalGetServerResponse);\n  _setServer = request => this.client.fetch({\n    body: JSON.stringify(marshalSetServerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('id', request.id)}`\n  }, unmarshalSetServerResponse);\n  _updateServer = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateServerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PATCH',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}`\n  }, unmarshalUpdateServerResponse);\n\n  /**\n   * List Instance actions. List all actions (e.g. power on, power off, reboot)\n   * that can currently be performed on an Instance.\n   *\n   * @param request - The request {@link ListServerActionsRequest}\n   * @returns A Promise of ListServerActionsResponse\n   */\n  listServerActions = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/action`\n  }, unmarshalListServerActionsResponse);\n\n  /**\n   * Perform action. Perform an action on an Instance. Available actions are:\n   * `poweron`: Start a stopped Instance. `poweroff`: Fully stop the Instance\n   * and release the hypervisor slot. `stop_in_place`: Stop the Instance, but\n   * keep the slot on the hypervisor. `reboot`: Stop the instance and restart\n   * it. `backup`: Create an image with all the volumes of an Instance.\n   * `terminate`: Delete the Instance along with all attached volumes.\n   *\n   * Keep in mind that terminating an Instance will result in the deletion of\n   * all attached volumes, including local and block storage. If you want to\n   * preserve your local volumes, you should use the `archive` action instead of\n   * `terminate`. Similarly, if you want to keep your block storage volumes, you\n   * must first detach them before issuing the `terminate` command. For more\n   * information, read the [Volumes](#path-volumes-list-volumes) documentation.\n   *\n   * @param request - The request {@link ServerActionRequest}\n   * @returns A Promise of ServerActionResponse\n   */\n  serverAction = request => this.client.fetch({\n    body: JSON.stringify(marshalServerActionRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/action`\n  }, unmarshalServerActionResponse);\n\n  /**\n   * List user data. List all user data keys registered on a specified Instance.\n   *\n   * @param request - The request {@link ListServerUserDataRequest}\n   * @returns A Promise of ListServerUserDataResponse\n   */\n  listServerUserData = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/user_data`\n  }, unmarshalListServerUserDataResponse);\n\n  /**\n   * Delete user data. Delete the specified key from an Instance's user data.\n   *\n   * @param request - The request {@link DeleteServerUserDataRequest}\n   */\n  deleteServerUserData = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/user_data/${validatePathParam('key', request.key)}`\n  });\n  pageOfListImages = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/images`,\n    urlParams: urlParams(['arch', request.arch], ['name', request.name], ['organization', request.organization], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['project', request.project], ['public', request.public], ['tags', request.tags])\n  }, unmarshalListImagesResponse$3);\n\n  /**\n   * List Instance images. List all existing Instance images.\n   *\n   * @param request - The request {@link ListImagesRequest}\n   * @returns A Promise of ListImagesResponse\n   */\n  listImages = (request = {}) => enrichForPagination('images', this.pageOfListImages, request);\n\n  /**\n   * Get an Instance image. Get details of an image with the specified ID.\n   *\n   * @param request - The request {@link GetImageRequest}\n   * @returns A Promise of GetImageResponse\n   */\n  getImage = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/images/${validatePathParam('imageId', request.imageId)}`\n  }, unmarshalGetImageResponse$1);\n\n  /**\n   * Create an Instance image. Create an Instance image from the specified\n   * snapshot ID.\n   *\n   * @param request - The request {@link CreateImageRequest}\n   * @returns A Promise of CreateImageResponse\n   */\n  createImage = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateImageRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/images`\n  }, unmarshalCreateImageResponse);\n  _setImage = request => this.client.fetch({\n    body: JSON.stringify(marshalSetImageRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/images/${validatePathParam('id', request.id)}`\n  }, unmarshalSetImageResponse);\n\n  /**\n   * Delete an Instance image. Delete the image with the specified ID.\n   *\n   * @param request - The request {@link DeleteImageRequest}\n   */\n  deleteImage = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/images/${validatePathParam('imageId', request.imageId)}`\n  });\n  pageOfListSnapshots = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/snapshots`,\n    urlParams: urlParams(['name', request.name], ['organization', request.organization], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['project', request.project], ['tags', request.tags])\n  }, unmarshalListSnapshotsResponse$1);\n\n  /**\n   * List snapshots. List all snapshots of an Organization in a specified\n   * Availability Zone.\n   *\n   * @param request - The request {@link ListSnapshotsRequest}\n   * @returns A Promise of ListSnapshotsResponse\n   */\n  listSnapshots = (request = {}) => enrichForPagination('snapshots', this.pageOfListSnapshots, request);\n\n  /**\n   * Create a snapshot from a specified volume or from a QCOW2 file. Create a\n   * snapshot from a specified volume or from a QCOW2 file in a specified\n   * Availability Zone.\n   *\n   * @param request - The request {@link CreateSnapshotRequest}\n   * @returns A Promise of CreateSnapshotResponse\n   */\n  createSnapshot = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateSnapshotRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/snapshots`\n  }, unmarshalCreateSnapshotResponse);\n\n  /**\n   * Get a snapshot. Get details of a snapshot with the specified ID.\n   *\n   * @param request - The request {@link GetSnapshotRequest}\n   * @returns A Promise of GetSnapshotResponse\n   */\n  getSnapshot = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}`\n  }, unmarshalGetSnapshotResponse);\n  _setSnapshot = request => this.client.fetch({\n    body: JSON.stringify(marshalSetSnapshotRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}`\n  }, unmarshalSetSnapshotResponse);\n\n  /**\n   * Delete a snapshot. Delete the snapshot with the specified ID.\n   *\n   * @param request - The request {@link DeleteSnapshotRequest}\n   */\n  deleteSnapshot = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}`\n  });\n\n  /**\n   * Export a snapshot. Export a snapshot to a specified S3 bucket in the same\n   * region.\n   *\n   * @param request - The request {@link ExportSnapshotRequest}\n   * @returns A Promise of ExportSnapshotResponse\n   */\n  exportSnapshot = request => this.client.fetch({\n    body: JSON.stringify(marshalExportSnapshotRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}/export`\n  }, unmarshalExportSnapshotResponse);\n  pageOfListVolumes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/volumes`,\n    urlParams: urlParams(['name', request.name], ['organization', request.organization], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['project', request.project], ['tags', request.tags && request.tags.length > 0 ? request.tags.join(',') : undefined], ['volume_type', request.volumeType])\n  }, unmarshalListVolumesResponse);\n\n  /**\n   * List volumes. List volumes in the specified Availability Zone. You can\n   * filter the output by volume type.\n   *\n   * @param request - The request {@link ListVolumesRequest}\n   * @returns A Promise of ListVolumesResponse\n   */\n  listVolumes = (request = {}) => enrichForPagination('volumes', this.pageOfListVolumes, request);\n\n  /**\n   * Create a volume. Create a volume of a specified type in an Availability\n   * Zone.\n   *\n   * @param request - The request {@link CreateVolumeRequest}\n   * @returns A Promise of CreateVolumeResponse\n   */\n  createVolume = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateVolumeRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/volumes`\n  }, unmarshalCreateVolumeResponse);\n\n  /**\n   * Get a volume. Get details of a volume with the specified ID.\n   *\n   * @param request - The request {@link GetVolumeRequest}\n   * @returns A Promise of GetVolumeResponse\n   */\n  getVolume = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/volumes/${validatePathParam('volumeId', request.volumeId)}`\n  }, unmarshalGetVolumeResponse);\n\n  /**\n   * Update a volume. Replace the name and/or size properties of a volume\n   * specified by its ID, with the specified value(s). Any volume name can be\n   * changed, however only `b_ssd` volumes can currently be increased in size.\n   *\n   * @param request - The request {@link UpdateVolumeRequest}\n   * @returns A Promise of UpdateVolumeResponse\n   */\n  updateVolume = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateVolumeRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PATCH',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/volumes/${validatePathParam('volumeId', request.volumeId)}`\n  }, unmarshalUpdateVolumeResponse);\n\n  /**\n   * Delete a volume. Delete the volume with the specified ID.\n   *\n   * @param request - The request {@link DeleteVolumeRequest}\n   */\n  deleteVolume = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/volumes/${validatePathParam('volumeId', request.volumeId)}`\n  });\n  pageOfListSecurityGroups = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups`,\n    urlParams: urlParams(['name', request.name], ['organization', request.organization], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['project', request.project], ['project_default', request.projectDefault], ['tags', request.tags && request.tags.length > 0 ? request.tags.join(',') : undefined])\n  }, unmarshalListSecurityGroupsResponse);\n\n  /**\n   * List security groups. List all existing security groups.\n   *\n   * @param request - The request {@link ListSecurityGroupsRequest}\n   * @returns A Promise of ListSecurityGroupsResponse\n   */\n  listSecurityGroups = (request = {}) => enrichForPagination('securityGroups', this.pageOfListSecurityGroups, request);\n\n  /**\n   * Create a security group. Create a security group with a specified name and\n   * description.\n   *\n   * @param request - The request {@link CreateSecurityGroupRequest}\n   * @returns A Promise of CreateSecurityGroupResponse\n   */\n  createSecurityGroup = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSecurityGroupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups`\n  }, unmarshalCreateSecurityGroupResponse);\n\n  /**\n   * Get a security group. Get the details of a security group with the\n   * specified ID.\n   *\n   * @param request - The request {@link GetSecurityGroupRequest}\n   * @returns A Promise of GetSecurityGroupResponse\n   */\n  getSecurityGroup = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}`\n  }, unmarshalGetSecurityGroupResponse);\n\n  /**\n   * Delete a security group. Delete a security group with the specified ID.\n   *\n   * @param request - The request {@link DeleteSecurityGroupRequest}\n   */\n  deleteSecurityGroup = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}`\n  });\n  _setSecurityGroup = request => this.client.fetch({\n    body: JSON.stringify(marshalSetSecurityGroupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('id', request.id)}`\n  }, unmarshalSetSecurityGroupResponse);\n\n  /**\n   * Get default rules. Lists the default rules applied to all the security\n   * groups.\n   *\n   * @param request - The request {@link ListDefaultSecurityGroupRulesRequest}\n   * @returns A Promise of ListSecurityGroupRulesResponse\n   */\n  listDefaultSecurityGroupRules = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/default/rules`\n  }, unmarshalListSecurityGroupRulesResponse);\n  pageOfListSecurityGroupRules = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}/rules`,\n    urlParams: urlParams(['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize])\n  }, unmarshalListSecurityGroupRulesResponse);\n\n  /**\n   * List rules. List the rules of the a specified security group ID.\n   *\n   * @param request - The request {@link ListSecurityGroupRulesRequest}\n   * @returns A Promise of ListSecurityGroupRulesResponse\n   */\n  listSecurityGroupRules = request => enrichForPagination('rules', this.pageOfListSecurityGroupRules, request);\n\n  /**\n   * Create rule. Create a rule in the specified security group ID.\n   *\n   * @param request - The request {@link CreateSecurityGroupRuleRequest}\n   * @returns A Promise of CreateSecurityGroupRuleResponse\n   */\n  createSecurityGroupRule = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSecurityGroupRuleRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}/rules`\n  }, unmarshalCreateSecurityGroupRuleResponse);\n\n  /**\n   * Update all the rules of a security group. Replaces the existing rules of\n   * the security group with the rules provided. This endpoint supports the\n   * update of existing rules, creation of new rules and deletion of existing\n   * rules when they are not passed in the request.\n   *\n   * @param request - The request {@link SetSecurityGroupRulesRequest}\n   * @returns A Promise of SetSecurityGroupRulesResponse\n   */\n  setSecurityGroupRules = request => this.client.fetch({\n    body: JSON.stringify(marshalSetSecurityGroupRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}/rules`\n  }, unmarshalSetSecurityGroupRulesResponse);\n\n  /**\n   * Delete rule. Delete a security group rule with the specified ID.\n   *\n   * @param request - The request {@link DeleteSecurityGroupRuleRequest}\n   */\n  deleteSecurityGroupRule = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}/rules/${validatePathParam('securityGroupRuleId', request.securityGroupRuleId)}`\n  });\n\n  /**\n   * Get rule. Get details of a security group rule with the specified ID.\n   *\n   * @param request - The request {@link GetSecurityGroupRuleRequest}\n   * @returns A Promise of GetSecurityGroupRuleResponse\n   */\n  getSecurityGroupRule = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}/rules/${validatePathParam('securityGroupRuleId', request.securityGroupRuleId)}`\n  }, unmarshalGetSecurityGroupRuleResponse);\n  _setSecurityGroupRule = request => this.client.fetch({\n    body: JSON.stringify(marshalSetSecurityGroupRuleRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/security_groups/${validatePathParam('securityGroupId', request.securityGroupId)}/rules/${validatePathParam('securityGroupRuleId', request.securityGroupRuleId)}`\n  }, unmarshalSetSecurityGroupRuleResponse);\n  pageOfListPlacementGroups = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups`,\n    urlParams: urlParams(['name', request.name], ['organization', request.organization], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['project', request.project], ['tags', request.tags && request.tags.length > 0 ? request.tags.join(',') : undefined])\n  }, unmarshalListPlacementGroupsResponse);\n\n  /**\n   * List placement groups. List all placement groups in a specified\n   * Availability Zone.\n   *\n   * @param request - The request {@link ListPlacementGroupsRequest}\n   * @returns A Promise of ListPlacementGroupsResponse\n   */\n  listPlacementGroups = (request = {}) => enrichForPagination('placementGroups', this.pageOfListPlacementGroups, request);\n\n  /**\n   * Create a placement group. Create a new placement group in a specified\n   * Availability Zone.\n   *\n   * @param request - The request {@link CreatePlacementGroupRequest}\n   * @returns A Promise of CreatePlacementGroupResponse\n   */\n  createPlacementGroup = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreatePlacementGroupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups`\n  }, unmarshalCreatePlacementGroupResponse);\n\n  /**\n   * Get a placement group. Get the specified placement group.\n   *\n   * @param request - The request {@link GetPlacementGroupRequest}\n   * @returns A Promise of GetPlacementGroupResponse\n   */\n  getPlacementGroup = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups/${validatePathParam('placementGroupId', request.placementGroupId)}`\n  }, unmarshalGetPlacementGroupResponse);\n\n  /**\n   * Set placement group. Set all parameters of the specified placement group.\n   *\n   * @param request - The request {@link SetPlacementGroupRequest}\n   * @returns A Promise of SetPlacementGroupResponse\n   */\n  setPlacementGroup = request => this.client.fetch({\n    body: JSON.stringify(marshalSetPlacementGroupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups/${validatePathParam('placementGroupId', request.placementGroupId)}`\n  }, unmarshalSetPlacementGroupResponse);\n\n  /**\n   * Update a placement group. Update one or more parameter of the specified\n   * placement group.\n   *\n   * @param request - The request {@link UpdatePlacementGroupRequest}\n   * @returns A Promise of UpdatePlacementGroupResponse\n   */\n  updatePlacementGroup = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdatePlacementGroupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PATCH',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups/${validatePathParam('placementGroupId', request.placementGroupId)}`\n  }, unmarshalUpdatePlacementGroupResponse);\n\n  /**\n   * Delete the specified placement group.\n   *\n   * @param request - The request {@link DeletePlacementGroupRequest}\n   */\n  deletePlacementGroup = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups/${validatePathParam('placementGroupId', request.placementGroupId)}`\n  });\n\n  /**\n   * Get placement group servers. Get all Instances belonging to the specified\n   * placement group.\n   *\n   * @param request - The request {@link GetPlacementGroupServersRequest}\n   * @returns A Promise of GetPlacementGroupServersResponse\n   */\n  getPlacementGroupServers = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups/${validatePathParam('placementGroupId', request.placementGroupId)}/servers`\n  }, unmarshalGetPlacementGroupServersResponse);\n\n  /**\n   * Set placement group servers. Set all Instances belonging to the specified\n   * placement group.\n   *\n   * @param request - The request {@link SetPlacementGroupServersRequest}\n   * @returns A Promise of SetPlacementGroupServersResponse\n   */\n  setPlacementGroupServers = request => this.client.fetch({\n    body: JSON.stringify(marshalSetPlacementGroupServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups/${validatePathParam('placementGroupId', request.placementGroupId)}/servers`\n  }, unmarshalSetPlacementGroupServersResponse);\n\n  /**\n   * Update placement group servers. Update all Instances belonging to the\n   * specified placement group.\n   *\n   * @param request - The request {@link UpdatePlacementGroupServersRequest}\n   * @returns A Promise of UpdatePlacementGroupServersResponse\n   */\n  updatePlacementGroupServers = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdatePlacementGroupServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PATCH',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/placement_groups/${validatePathParam('placementGroupId', request.placementGroupId)}/servers`\n  }, unmarshalUpdatePlacementGroupServersResponse);\n  pageOfListIps = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips`,\n    urlParams: urlParams(['name', request.name], ['organization', request.organization], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['project', request.project], ['tags', request.tags && request.tags.length > 0 ? request.tags.join(',') : undefined])\n  }, unmarshalListIpsResponse$1);\n\n  /**\n   * List all flexible IPs. List all flexible IPs in a specified zone.\n   *\n   * @param request - The request {@link ListIpsRequest}\n   * @returns A Promise of ListIpsResponse\n   */\n  listIps = (request = {}) => enrichForPagination('ips', this.pageOfListIps, request);\n\n  /**\n   * Reserve a flexible IP. Reserve a flexible IP and attach it to the specified\n   * Instance.\n   *\n   * @param request - The request {@link CreateIpRequest}\n   * @returns A Promise of CreateIpResponse\n   */\n  createIp = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateIpRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips`\n  }, unmarshalCreateIpResponse);\n\n  /**\n   * Get a flexible IP. Get details of an IP with the specified ID or address.\n   *\n   * @param request - The request {@link GetIpRequest}\n   * @returns A Promise of GetIpResponse\n   */\n  getIp = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ip', request.ip)}`\n  }, unmarshalGetIpResponse);\n\n  /**\n   * Update a flexible IP. Update a flexible IP in the specified zone with the\n   * specified ID.\n   *\n   * @param request - The request {@link UpdateIpRequest}\n   * @returns A Promise of UpdateIpResponse\n   */\n  updateIp = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateIpRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PATCH',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ip', request.ip)}`\n  }, unmarshalUpdateIpResponse);\n\n  /**\n   * Delete a flexible IP. Delete the IP with the specified ID.\n   *\n   * @param request - The request {@link DeleteIpRequest}\n   */\n  deleteIp = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ip', request.ip)}`\n  });\n  pageOfListPrivateNICs = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private_nics`,\n    urlParams: urlParams(['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['tags', request.tags && request.tags.length > 0 ? request.tags.join(',') : undefined])\n  }, unmarshalListPrivateNICsResponse);\n\n  /**\n   * List all private NICs. List all private NICs of a specified Instance.\n   *\n   * @param request - The request {@link ListPrivateNICsRequest}\n   * @returns A Promise of ListPrivateNICsResponse\n   */\n  listPrivateNICs = request => enrichForPagination('privateNics', this.pageOfListPrivateNICs, request);\n\n  /**\n   * Create a private NIC connecting an Instance to a Private Network.\n   *\n   * @param request - The request {@link CreatePrivateNICRequest}\n   * @returns A Promise of CreatePrivateNICResponse\n   */\n  createPrivateNIC = request => this.client.fetch({\n    body: JSON.stringify(marshalCreatePrivateNICRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'POST',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private_nics`\n  }, unmarshalCreatePrivateNICResponse);\n\n  /**\n   * Get a private NIC. Get private NIC properties.\n   *\n   * @param request - The request {@link GetPrivateNICRequest}\n   * @returns A Promise of GetPrivateNICResponse\n   */\n  getPrivateNIC = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private_nics/${validatePathParam('privateNicId', request.privateNicId)}`\n  }, unmarshalGetPrivateNICResponse);\n\n  /**\n   * Update a private NIC. Update one or more parameter(s) of a specified\n   * private NIC.\n   *\n   * @param request - The request {@link UpdatePrivateNICRequest}\n   * @returns A Promise of PrivateNIC\n   */\n  updatePrivateNIC = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdatePrivateNICRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$d,\n    method: 'PATCH',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private_nics/${validatePathParam('privateNicId', request.privateNicId)}`\n  }, unmarshalPrivateNIC);\n\n  /**\n   * Delete a private NIC.\n   *\n   * @param request - The request {@link DeletePrivateNICRequest}\n   */\n  deletePrivateNIC = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/private_nics/${validatePathParam('privateNicId', request.privateNicId)}`\n  });\n  pageOfListBootscripts = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/bootscripts`,\n    urlParams: urlParams(['arch', request.arch], ['default', request.default], ['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize], ['public', request.public], ['title', request.title])\n  }, unmarshalListBootscriptsResponse);\n\n  /**\n   * List bootscripts.\n   *\n   * @deprecated\n   * @param request - The request {@link ListBootscriptsRequest}\n   * @returns A Promise of ListBootscriptsResponse\n   */\n  listBootscripts = (request = {}) => enrichForPagination('bootscripts', this.pageOfListBootscripts, request);\n\n  /**\n   * Get bootscripts. Get details of a bootscript with the specified ID.\n   *\n   * @deprecated\n   * @param request - The request {@link GetBootscriptRequest}\n   * @returns A Promise of GetBootscriptResponse\n   */\n  getBootscript = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/bootscripts/${validatePathParam('bootscriptId', request.bootscriptId)}`\n  }, unmarshalGetBootscriptResponse);\n  getDashboard = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dashboard`,\n    urlParams: urlParams(['organization', request.organization], ['project', request.project])\n  }, unmarshalGetDashboardResponse);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link ImageState}. */\nconst IMAGE_TRANSIENT_STATUSES$1 = ['creating'];\n\n/** Lists transient statutes of the enum {@link PrivateNICState}. */\nconst PRIVATE_NIC_TRANSIENT_STATUSES = ['syncing'];\n\n/** Lists transient statutes of the enum {@link SecurityGroupState}. */\nconst SECURITY_GROUP_TRANSIENT_STATUSES = ['syncing'];\n\n/** Lists transient statutes of the enum {@link ServerState}. */\nconst SERVER_TRANSIENT_STATUSES = ['starting', 'stopping'];\n\n/** Lists transient statutes of the enum {@link SnapshotState}. */\nconst SNAPSHOT_TRANSIENT_STATUSES$1 = ['snapshotting', 'importing', 'exporting'];\n\n/** Lists transient statutes of the enum {@link TaskStatus}. */\nconst TASK_TRANSIENT_STATUSES = ['pending', 'started', 'retry'];\n\n/** Lists transient statutes of the enum {@link VolumeServerState}. */\nconst VOLUME_SERVER_TRANSIENT_STATUSES = ['snapshotting', 'fetching', 'resizing', 'saving', 'hotsyncing'];\n\n/** Lists transient statutes of the enum {@link VolumeState}. */\nconst VOLUME_TRANSIENT_STATUSES = ['snapshotting', 'fetching', 'resizing', 'saving', 'hotsyncing'];\n\nconst marshalVolumeSummary = (request, defaults) => ({\n  id: request.id,\n  name: request.name,\n  size: request.size,\n  volume_type: request.volumeType\n});\nconst marshalServerSummary = (request, defaults) => ({\n  id: request.id,\n  name: request.name\n});\nconst marshalBootscript = (request, defaults) => ({\n  arch: request.arch,\n  bootcmdargs: request.bootcmdargs,\n  default: request.default,\n  dtb: request.dtb,\n  id: request.id,\n  initrd: request.initrd,\n  kernel: request.kernel,\n  organization: request.organization,\n  project: request.project,\n  public: request.public,\n  title: request.title,\n  zone: request.zone\n});\nconst marshalVolume = (request, defaults) => ({\n  creation_date: request.creationDate,\n  export_uri: request.exportUri,\n  id: request.id,\n  modification_date: request.modificationDate,\n  name: request.name,\n  organization: request.organization,\n  project: request.project,\n  server: request.server ? marshalServerSummary(request.server) : undefined,\n  size: request.size,\n  state: request.state,\n  tags: request.tags,\n  volume_type: request.volumeType,\n  zone: request.zone\n});\nconst marshalSetImageRequestWithID = (request, defaults) => ({\n  arch: request.arch,\n  creation_date: request.creationDate,\n  default_bootscript: request.defaultBootscript ? marshalBootscript(request.defaultBootscript) : undefined,\n  extra_volumes: request.extraVolumes ? Object.entries(request.extraVolumes).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: marshalVolume(value)\n  }), {}) : undefined,\n  from_server: request.fromServer,\n  modification_date: request.modificationDate,\n  id: request.id,\n  name: request.name,\n  organization: request.organization,\n  project: request.project,\n  public: request.public,\n  root_volume: request.rootVolume ? marshalVolumeSummary(request.rootVolume) : undefined,\n  state: request.state,\n  tags: request.tags\n});\n\nconst validateNotUndefined = obj => {\n  if (obj === undefined) throw new TypeError(`object was found undefined`);\n  return obj;\n};\nclass InstanceV1UtilsAPI extends API$f {\n  /**\n   * Waits for {@link Image} to be in a final state.\n   *\n   * @param request - The request {@link GetImageRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Image\n   */\n  waitForImage = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getImage(request).then(res => res.image);\n    return {\n      done: !IMAGE_TRANSIENT_STATUSES$1.includes(value.state),\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n\n  /**\n   * Waits for {@link PrivateNIC} to be in a final state.\n   *\n   * @param request - The request {@link GetPrivateNICRequest}\n   * @param options - The waiting options\n   * @returns A Promise of PrivateNIC\n   */\n  waitForPrivateNIC = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getPrivateNIC(request).then(res => res.privateNic);\n    return {\n      done: !PRIVATE_NIC_TRANSIENT_STATUSES.includes(value.state),\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n\n  /**\n   * Waits for {@link Server} to be in a final state.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Server\n   */\n  waitForServer = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getServer(request).then(res => res.server);\n    return {\n      done: !SERVER_TRANSIENT_STATUSES.includes(value.state),\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n\n  /**\n   * Waits for {@link Server} to be in a final state.\n   *\n   * @param request - The request {@link GetServerRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Server\n   */\n  waitForSnapshot = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getSnapshot(request).then(res => res.snapshot);\n    return {\n      done: !SNAPSHOT_TRANSIENT_STATUSES$1.includes(value.state),\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n\n  /**\n   * Waits for {@link Volume} to be in a final state.\n   *\n   * @param request - The request {@link GetVolumeRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Volume\n   */\n  waitForVolume = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getVolume(request).then(res => res.volume);\n    return {\n      done: !VOLUME_TRANSIENT_STATUSES.includes(value.state),\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n\n  /**\n   * Updates a snapshot.\n   *\n   * @param request - The request {@link UpdateSnapshotRequest}\n   * @returns A Promise of UpdateSnapshotResponse\n   */\n  updateSnapshot = request => this.getSnapshot(request).then(res => validateNotUndefined(res.snapshot)).then(snapshot => this._setSnapshot({\n    ...snapshot,\n    name: request.name ?? snapshot.name,\n    snapshotId: snapshot.id\n  })).then(res => ({\n    snapshot: res.snapshot\n  }));\n\n  /**\n   * Updates a security group.\n   *\n   * @param request - The request {@link UpdateSecurityGroupRequest}\n   * @returns A Promise of UpdateSecurityGroupResponse\n   */\n  updateSecurityGroup = request => this.getSecurityGroup({\n    securityGroupId: request.securityGroupId,\n    zone: request.zone\n  }).then(res => validateNotUndefined(res.securityGroup)).then(securityGroup => this._setSecurityGroup({\n    creationDate: securityGroup.creationDate,\n    description: request.description ?? securityGroup.description,\n    enableDefaultSecurity: request.enableDefaultSecurity ?? securityGroup.enableDefaultSecurity,\n    id: securityGroup.id,\n    inboundDefaultPolicy: request.inboundDefaultPolicy ?? securityGroup.inboundDefaultPolicy,\n    modificationDate: securityGroup.modificationDate,\n    name: request.name ?? securityGroup.name,\n    organization: securityGroup.organization,\n    organizationDefault: request.organizationDefault ?? securityGroup.organizationDefault,\n    outboundDefaultPolicy: request.outboundDefaultPolicy ?? securityGroup.outboundDefaultPolicy,\n    project: securityGroup.project,\n    projectDefault: request.projectDefault ?? securityGroup.projectDefault,\n    servers: securityGroup.servers,\n    stateful: request.stateful ?? securityGroup.stateful,\n    zone: request.zone\n  })).then(res => ({\n    securityGroup: res.securityGroup\n  }));\n\n  /**\n   * Updates a security group rule.\n   *\n   * @param request - The request {@link UpdateSecurityGroupRuleRequest}\n   * @returns A Promise of UpdateSecurityGroupRuleResponse\n   */\n  updateSecurityGroupRule = request => this.getSecurityGroupRule({\n    securityGroupId: request.securityGroupId,\n    securityGroupRuleId: request.securityGroupRuleId,\n    zone: request.zone\n  }).then(res => validateNotUndefined(res.rule)).then(rule => {\n    let sReq = {\n      action: request.action ?? rule.action,\n      destPortFrom: rule.destPortFrom,\n      destPortTo: rule.destPortTo,\n      direction: request.direction ?? rule.direction,\n      editable: rule.editable,\n      id: request.securityGroupRuleId,\n      ipRange: request.ipRange ?? rule.ipRange,\n      position: request.position ?? rule.position,\n      protocol: request.protocol ?? rule.protocol,\n      securityGroupId: request.securityGroupId,\n      securityGroupRuleId: request.securityGroupRuleId\n    };\n    if (request.destPortFrom) {\n      sReq = {\n        ...sReq,\n        destPortFrom: request.destPortFrom > 0 ? request.destPortFrom : undefined\n      };\n    }\n    if (request.destPortTo) {\n      sReq = {\n        ...sReq,\n        destPortTo: request.destPortTo > 0 ? request.destPortTo : undefined\n      };\n    }\n    if (sReq.destPortFrom && sReq.destPortTo && sReq.destPortFrom === sReq.destPortTo) {\n      sReq = {\n        ...sReq,\n        destPortTo: undefined\n      };\n    }\n    // When we use ICMP protocol portFrom and portTo should be set to nil\n    if (request.protocol === 'ICMP') {\n      sReq = {\n        ...sReq,\n        destPortFrom: undefined,\n        destPortTo: undefined\n      };\n    }\n    return this._setSecurityGroupRule(sReq);\n  }).then(res => ({\n    rule: res.rule\n  }));\n\n  /**\n   * Updates a server.\n   *\n   * @param request - The request {@link UpdateServerRequest}\n   * @returns A Promise of UpdateServerResponse\n   */\n  updateServer = request => this._updateServer(request);\n\n  /**\n   * Creates a server.\n   *\n   * @param request - The request {@link CreateServerRequest}\n   * @returns A Promise of CreateServerResponse\n   */\n  createServer = request => this._createServer(request);\n\n  /**\n   * Starts an action and wait for the server to be in the correct \"terminal\n   * state\" expected by this action.\n   *\n   * @param request - The request {@link ServerActionRequest}\n   * @returns A Promise of Server\n   */\n  serverActionAndWait = async (request, options) => {\n    const finalServer = await this.serverAction(request).then(() => this.waitForServer({\n      serverId: request.serverId,\n      zone: request.zone\n    }, options));\n\n    // Check the action was properly executed.\n    let expectedState;\n    switch (request.action) {\n      case 'poweron':\n      case 'reboot':\n        expectedState = 'running';\n        break;\n      case 'poweroff':\n        expectedState = 'stopped';\n        break;\n      case 'stop_in_place':\n        expectedState = 'stopped in place';\n        break;\n    }\n    if (expectedState && finalServer.state !== expectedState) {\n      throw new Error(`expected state ${expectedState} but found ${finalServer.state}: ${finalServer.stateDetail}`);\n    }\n    return finalServer;\n  };\n\n  /**\n   * Attaches a volume to a server.\n   *\n   * @param request - The request {@link AttachVolumeRequest}\n   * @returns A Promise of AttachVolumeResponse\n   */\n  attachVolume = async request => {\n    const volumes = await this.getServer({\n      serverId: request.serverId,\n      zone: request.zone\n    }).then(res => validateNotUndefined(res.server?.volumes));\n    const newVolumes = {};\n    for (const [key, server] of Object.entries(volumes)) {\n      newVolumes[key] = {\n        id: server.id,\n        name: server.name\n      };\n    }\n\n    // We loop through all the possible volume keys (0 to len(volumes))\n    // to find a non existing key and assign it to the requested volume.\n    // A key should always be found. However we return an error if no keys were found.\n    let found = false;\n    const volumesLength = Object.keys(volumes).length;\n    for (let index = 0; index <= volumesLength; index += 1) {\n      const key = index.toString();\n      if (!(key in newVolumes)) {\n        newVolumes[key] = {\n          id: request.volumeId,\n          name: request.volumeId // name is ignored on this PATCH\n        };\n\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      throw new Error(`could not find key to attach volume ${request.volumeId}`);\n    }\n\n    // Update server\n    return this.updateServer({\n      serverId: request.serverId,\n      volumes: newVolumes,\n      zone: request.zone\n    }).then(obj => obj);\n  };\n\n  /**\n   * Detaches a volume from a server.\n   *\n   * @param request - The request {@link DetachVolumeRequest}\n   * @returns A Promise of DetachVolumeResponse\n   */\n  detachVolume = async request => {\n    // Get server and related volumes.\n    const server = await this.getVolume({\n      volumeId: request.volumeId,\n      zone: request.zone\n    }).then(res => validateNotUndefined(res.volume?.server?.id)).then(serverId => this.getServer({\n      serverId,\n      zone: request.zone\n    })).then(res => validateNotUndefined(res.server));\n\n    // Remove volume.\n    const newVolumes = {};\n    for (const [key, volume] of Object.entries(server.volumes)) {\n      if (volume.id !== request.volumeId) {\n        newVolumes[key] = {\n          id: volume.id,\n          name: volume.name\n        };\n      }\n    }\n\n    // Update server.\n    return this.updateServer({\n      serverId: server.id,\n      volumes: newVolumes,\n      zone: request.zone\n    }).then(obj => obj);\n  };\n\n  /**\n   * Updates an image.\n   *\n   * @param request - The request {@link UpdateImageRequest}\n   * @returns A Promise of UpdateImageResponse\n   */\n  updateImage = request => this.getImage({\n    zone: request.zone,\n    imageId: request.imageId\n  }).then(res => validateNotUndefined(res.image)).then(image => ({\n    ...image,\n    name: request.name ?? image.name,\n    tags: request.tags ?? image.tags,\n    id: image.id\n  })).then(imageReq => this.client.fetch({\n    body: JSON.stringify(marshalSetImageRequestWithID(imageReq, this.client.settings)),\n    headers: {\n      'Content-Type': 'application/json; charset=utf-8'\n    },\n    method: 'PUT',\n    path: `/instance/v1/zones/${validatePathParam('zone', imageReq.zone)}/images/${validatePathParam('id', imageReq.id)}`\n  }, unmarshalSetImageResponse)).then(res => ({\n    image: res.image\n  }));\n\n  /**\n   * Get the content of a user data on a server for the given key.\n   *\n   * @param request - The request {@link GetServerUserDataRequest}\n   * @returns The content of the key\n   */\n  getServerUserData = request => this.client.fetch({\n    method: 'GET',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/user_data/${validatePathParam('key', request.key)}`\n  });\n\n  /**\n   * Sets the content of a user data on a server for the given key.\n   *\n   * @param request - The request {@link SetServerUserDataRequest}\n   */\n  setServerUserData = request => this.client.fetch({\n    body: request.content,\n    headers: {\n      'Content-Type': 'text/plain'\n    },\n    method: 'PATCH',\n    path: `/instance/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/servers/${validatePathParam('serverId', request.serverId)}/user_data/${validatePathParam('key', request.key)}`\n  });\n}\n\nvar index$h = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: InstanceV1UtilsAPI,\n  IMAGE_TRANSIENT_STATUSES: IMAGE_TRANSIENT_STATUSES$1,\n  PRIVATE_NIC_TRANSIENT_STATUSES: PRIVATE_NIC_TRANSIENT_STATUSES,\n  SECURITY_GROUP_TRANSIENT_STATUSES: SECURITY_GROUP_TRANSIENT_STATUSES,\n  SERVER_TRANSIENT_STATUSES: SERVER_TRANSIENT_STATUSES,\n  SNAPSHOT_TRANSIENT_STATUSES: SNAPSHOT_TRANSIENT_STATUSES$1,\n  TASK_TRANSIENT_STATUSES: TASK_TRANSIENT_STATUSES,\n  VOLUME_SERVER_TRANSIENT_STATUSES: VOLUME_SERVER_TRANSIENT_STATUSES,\n  VOLUME_TRANSIENT_STATUSES: VOLUME_TRANSIENT_STATUSES\n});\n\nvar index$g = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index$h\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link HubStatus}. */\nconst HUB_TRANSIENT_STATUSES = ['enabling', 'disabling'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalDeviceMessageFiltersRule = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DeviceMessageFiltersRule' failed as data isn't a dictionary.`);\n  }\n  return {\n    policy: data.policy,\n    topics: data.topics\n  };\n};\nconst unmarshalDeviceMessageFilters = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DeviceMessageFilters' failed as data isn't a dictionary.`);\n  }\n  return {\n    publish: data.publish ? unmarshalDeviceMessageFiltersRule(data.publish) : undefined,\n    subscribe: data.subscribe ? unmarshalDeviceMessageFiltersRule(data.subscribe) : undefined\n  };\n};\nconst unmarshalHubTwinsGraphiteConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HubTwinsGraphiteConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    pushUri: data.push_uri\n  };\n};\nconst unmarshalCertificate$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Certificate' failed as data isn't a dictionary.`);\n  }\n  return {\n    crt: data.crt,\n    key: data.key\n  };\n};\nconst unmarshalDevice = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Device' failed as data isn't a dictionary.`);\n  }\n  return {\n    allowInsecure: data.allow_insecure,\n    allowMultipleConnections: data.allow_multiple_connections,\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    hasCustomCertificate: data.has_custom_certificate,\n    hubId: data.hub_id,\n    id: data.id,\n    isConnected: data.is_connected,\n    lastActivityAt: unmarshalDate(data.last_activity_at),\n    messageFilters: data.message_filters ? unmarshalDeviceMessageFilters(data.message_filters) : undefined,\n    name: data.name,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalHub = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Hub' failed as data isn't a dictionary.`);\n  }\n  return {\n    connectedDeviceCount: data.connected_device_count,\n    createdAt: unmarshalDate(data.created_at),\n    deviceCount: data.device_count,\n    disableEvents: data.disable_events,\n    enabled: data.enabled,\n    enableDeviceAutoProvisioning: data.enable_device_auto_provisioning,\n    endpoint: data.endpoint,\n    eventsTopicPrefix: data.events_topic_prefix,\n    hasCustomCa: data.has_custom_ca,\n    id: data.id,\n    name: data.name,\n    organizationId: data.organization_id,\n    productPlan: data.product_plan,\n    projectId: data.project_id,\n    region: data.region,\n    status: data.status,\n    twinsGraphiteConfig: data.twins_graphite_config ? unmarshalHubTwinsGraphiteConfig(data.twins_graphite_config) : undefined,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalListTwinDocumentsResponseDocumentSummary = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTwinDocumentsResponseDocumentSummary' failed as data isn't a dictionary.`);\n  }\n  return {\n    documentName: data.document_name\n  };\n};\nconst unmarshalNetwork = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Network' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    endpoint: data.endpoint,\n    hubId: data.hub_id,\n    id: data.id,\n    name: data.name,\n    topicPrefix: data.topic_prefix,\n    type: data.type\n  };\n};\nconst unmarshalRouteDatabaseConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RouteDatabaseConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    dbname: data.dbname,\n    engine: data.engine,\n    host: data.host,\n    password: data.password,\n    port: data.port,\n    query: data.query,\n    username: data.username\n  };\n};\nconst unmarshalRouteRestConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RouteRestConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    headers: data.headers,\n    uri: data.uri,\n    verb: data.verb\n  };\n};\nconst unmarshalRouteS3Config = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RouteS3Config' failed as data isn't a dictionary.`);\n  }\n  return {\n    bucketName: data.bucket_name,\n    bucketRegion: data.bucket_region,\n    objectPrefix: data.object_prefix,\n    strategy: data.strategy\n  };\n};\nconst unmarshalRouteSummary = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RouteSummary' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    hubId: data.hub_id,\n    id: data.id,\n    name: data.name,\n    topic: data.topic,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalCreateDeviceResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateDeviceResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    certificate: data.certificate ? unmarshalCertificate$1(data.certificate) : undefined,\n    device: data.device ? unmarshalDevice(data.device) : undefined\n  };\n};\nconst unmarshalCreateNetworkResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateNetworkResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    network: data.network ? unmarshalNetwork(data.network) : undefined,\n    secret: data.secret\n  };\n};\nconst unmarshalGetDeviceCertificateResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetDeviceCertificateResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    certificatePem: data.certificate_pem,\n    device: data.device ? unmarshalDevice(data.device) : undefined\n  };\n};\nconst unmarshalGetDeviceMetricsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetDeviceMetricsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    metrics: unmarshalArrayOfObject(data.metrics, unmarshalTimeSeries)\n  };\n};\nconst unmarshalGetHubCAResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetHubCAResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    caCertPem: data.ca_cert_pem\n  };\n};\nconst unmarshalGetHubMetricsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetHubMetricsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    metrics: unmarshalArrayOfObject(data.metrics, unmarshalTimeSeries)\n  };\n};\nconst unmarshalListDevicesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDevicesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    devices: unmarshalArrayOfObject(data.devices, unmarshalDevice),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListHubsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListHubsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    hubs: unmarshalArrayOfObject(data.hubs, unmarshalHub),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNetworksResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNetworksResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    networks: unmarshalArrayOfObject(data.networks, unmarshalNetwork),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListRoutesResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListRoutesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    routes: unmarshalArrayOfObject(data.routes, unmarshalRouteSummary),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListTwinDocumentsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTwinDocumentsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    documents: unmarshalArrayOfObject(data.documents, unmarshalListTwinDocumentsResponseDocumentSummary)\n  };\n};\nconst unmarshalRenewDeviceCertificateResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RenewDeviceCertificateResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    certificate: data.certificate ? unmarshalCertificate$1(data.certificate) : undefined,\n    device: data.device ? unmarshalDevice(data.device) : undefined\n  };\n};\nconst unmarshalRoute$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Route' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    dbConfig: data.db_config ? unmarshalRouteDatabaseConfig(data.db_config) : undefined,\n    hubId: data.hub_id,\n    id: data.id,\n    name: data.name,\n    restConfig: data.rest_config ? unmarshalRouteRestConfig(data.rest_config) : undefined,\n    s3Config: data.s3_config ? unmarshalRouteS3Config(data.s3_config) : undefined,\n    topic: data.topic,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalSetDeviceCertificateResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetDeviceCertificateResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    certificatePem: data.certificate_pem,\n    device: data.device ? unmarshalDevice(data.device) : undefined\n  };\n};\nconst unmarshalTwinDocument = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'TwinDocument' failed as data isn't a dictionary.`);\n  }\n  return {\n    data: data.data,\n    documentName: data.document_name,\n    twinId: data.twin_id,\n    version: data.version\n  };\n};\nconst marshalDeviceMessageFiltersRule = (request, defaults) => ({\n  policy: request.policy,\n  topics: request.topics\n});\nconst marshalCreateRouteRequestDatabaseConfig = (request, defaults) => ({\n  dbname: request.dbname,\n  engine: request.engine,\n  host: request.host,\n  password: request.password,\n  port: request.port,\n  query: request.query,\n  username: request.username\n});\nconst marshalCreateRouteRequestRestConfig = (request, defaults) => ({\n  headers: request.headers,\n  uri: request.uri,\n  verb: request.verb\n});\nconst marshalCreateRouteRequestS3Config = (request, defaults) => ({\n  bucket_name: request.bucketName,\n  bucket_region: request.bucketRegion,\n  object_prefix: request.objectPrefix,\n  strategy: request.strategy\n});\nconst marshalDeviceMessageFilters = (request, defaults) => ({\n  publish: request.publish ? marshalDeviceMessageFiltersRule(request.publish) : undefined,\n  subscribe: request.subscribe ? marshalDeviceMessageFiltersRule(request.subscribe) : undefined\n});\nconst marshalHubTwinsGraphiteConfig = (request, defaults) => ({\n  push_uri: request.pushUri\n});\nconst marshalUpdateRouteRequestDatabaseConfig = (request, defaults) => ({\n  dbname: request.dbname,\n  engine: request.engine,\n  host: request.host,\n  password: request.password,\n  port: request.port,\n  query: request.query,\n  username: request.username\n});\nconst marshalUpdateRouteRequestRestConfig = (request, defaults) => ({\n  headers: request.headers,\n  uri: request.uri,\n  verb: request.verb\n});\nconst marshalUpdateRouteRequestS3Config = (request, defaults) => ({\n  bucket_name: request.bucketName,\n  bucket_region: request.bucketRegion,\n  object_prefix: request.objectPrefix,\n  strategy: request.strategy\n});\nconst marshalCreateDeviceRequest = (request, defaults) => ({\n  allow_insecure: request.allowInsecure,\n  allow_multiple_connections: request.allowMultipleConnections,\n  description: request.description,\n  hub_id: request.hubId,\n  message_filters: request.messageFilters ? marshalDeviceMessageFilters(request.messageFilters) : undefined,\n  name: request.name || randomName('device')\n});\nconst marshalCreateHubRequest = (request, defaults) => ({\n  disable_events: request.disableEvents,\n  events_topic_prefix: request.eventsTopicPrefix,\n  name: request.name || randomName('hub'),\n  product_plan: request.productPlan,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  ...resolveOneOf([{\n    param: 'twins_graphite_config',\n    value: request.twinsGraphiteConfig ? marshalHubTwinsGraphiteConfig(request.twinsGraphiteConfig) : undefined\n  }])\n});\nconst marshalCreateNetworkRequest = (request, defaults) => ({\n  hub_id: request.hubId,\n  name: request.name || randomName('network'),\n  topic_prefix: request.topicPrefix,\n  type: request.type\n});\nconst marshalCreateRouteRequest$1 = (request, defaults) => ({\n  hub_id: request.hubId,\n  name: request.name || randomName('route'),\n  topic: request.topic,\n  ...resolveOneOf([{\n    param: 's3_config',\n    value: request.s3Config ? marshalCreateRouteRequestS3Config(request.s3Config) : undefined\n  }, {\n    param: 'db_config',\n    value: request.dbConfig ? marshalCreateRouteRequestDatabaseConfig(request.dbConfig) : undefined\n  }, {\n    param: 'rest_config',\n    value: request.restConfig ? marshalCreateRouteRequestRestConfig(request.restConfig) : undefined\n  }])\n});\nconst marshalPatchTwinDocumentRequest = (request, defaults) => ({\n  data: request.data,\n  version: request.version\n});\nconst marshalPutTwinDocumentRequest = (request, defaults) => ({\n  data: request.data,\n  version: request.version\n});\nconst marshalSetDeviceCertificateRequest = (request, defaults) => ({\n  certificate_pem: request.certificatePem\n});\nconst marshalSetHubCARequest = (request, defaults) => ({\n  ca_cert_pem: request.caCertPem,\n  challenge_cert_pem: request.challengeCertPem\n});\nconst marshalUpdateDeviceRequest = (request, defaults) => ({\n  allow_insecure: request.allowInsecure,\n  allow_multiple_connections: request.allowMultipleConnections,\n  description: request.description,\n  hub_id: request.hubId,\n  message_filters: request.messageFilters ? marshalDeviceMessageFilters(request.messageFilters) : undefined\n});\nconst marshalUpdateHubRequest = (request, defaults) => ({\n  disable_events: request.disableEvents,\n  enable_device_auto_provisioning: request.enableDeviceAutoProvisioning,\n  events_topic_prefix: request.eventsTopicPrefix,\n  name: request.name,\n  product_plan: request.productPlan ?? 'plan_unknown',\n  ...resolveOneOf([{\n    param: 'twins_graphite_config',\n    value: request.twinsGraphiteConfig ? marshalHubTwinsGraphiteConfig(request.twinsGraphiteConfig) : undefined\n  }])\n});\nconst marshalUpdateRouteRequest$1 = (request, defaults) => ({\n  name: request.name,\n  topic: request.topic,\n  ...resolveOneOf([{\n    param: 's3_config',\n    value: request.s3Config ? marshalUpdateRouteRequestS3Config(request.s3Config) : undefined\n  }, {\n    param: 'db_config',\n    value: request.dbConfig ? marshalUpdateRouteRequestDatabaseConfig(request.dbConfig) : undefined\n  }, {\n    param: 'rest_config',\n    value: request.restConfig ? marshalUpdateRouteRequestRestConfig(request.restConfig) : undefined\n  }])\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$c = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * IoT Hub API.\n *\n * This API allows you to manage IoT hubs and devices. IoT Hub API.\n */\nlet API$e = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par'];\n  pageOfListHubs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListHubsResponse);\n\n  /**\n   * List hubs. List all Hubs in the specified zone. By default, returned Hubs\n   * are ordered by creation date in ascending order, though this can be\n   * modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListHubsRequest}\n   * @returns A Promise of ListHubsResponse\n   */\n  listHubs = (request = {}) => enrichForPagination('hubs', this.pageOfListHubs, request);\n\n  /**\n   * Create a hub. Create a new Hub in the targeted region, specifying its\n   * configuration including name and product plan.\n   *\n   * @param request - The request {@link CreateHubRequest}\n   * @returns A Promise of Hub\n   */\n  createHub = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateHubRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs`\n  }, unmarshalHub);\n\n  /**\n   * Get a hub. Retrieve information about an existing IoT Hub, specified by its\n   * Hub ID. Its full details, including name, status and endpoint, are returned\n   * in the response object.\n   *\n   * @param request - The request {@link GetHubRequest}\n   * @returns A Promise of Hub\n   */\n  getHub = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}`\n  }, unmarshalHub);\n\n  /**\n   * Waits for {@link Hub} to be in a final state.\n   *\n   * @param request - The request {@link GetHubRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Hub\n   */\n  waitForHub = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!HUB_TRANSIENT_STATUSES.includes(res.status))), this.getHub, request, options);\n\n  /**\n   * Update a hub. Update the parameters of an existing IoT Hub, specified by\n   * its Hub ID.\n   *\n   * @param request - The request {@link UpdateHubRequest}\n   * @returns A Promise of Hub\n   */\n  updateHub = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateHubRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'PATCH',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}`\n  }, unmarshalHub);\n\n  /**\n   * Enable a hub. Enable an existing IoT Hub, specified by its Hub ID.\n   *\n   * @param request - The request {@link EnableHubRequest}\n   * @returns A Promise of Hub\n   */\n  enableHub = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}/enable`\n  }, unmarshalHub);\n\n  /**\n   * Disable a hub. Disable an existing IoT Hub, specified by its Hub ID.\n   *\n   * @param request - The request {@link DisableHubRequest}\n   * @returns A Promise of Hub\n   */\n  disableHub = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}/disable`\n  }, unmarshalHub);\n\n  /**\n   * Delete a hub. Delete an existing IoT Hub, specified by its Hub ID. Deleting\n   * a Hub is permanent, and cannot be undone.\n   *\n   * @param request - The request {@link DeleteHubRequest}\n   */\n  deleteHub = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}`,\n    urlParams: urlParams(['delete_devices', request.deleteDevices])\n  });\n\n  /**\n   * Get a hub's metrics. Get the metrics of an existing IoT Hub, specified by\n   * its Hub ID.\n   *\n   * @deprecated\n   * @param request - The request {@link GetHubMetricsRequest}\n   * @returns A Promise of GetHubMetricsResponse\n   */\n  getHubMetrics = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}/metrics`,\n    urlParams: urlParams(['start_date', request.startDate])\n  }, unmarshalGetHubMetricsResponse);\n\n  /**\n   * Set the certificate authority of a hub. Set a particular PEM-encoded\n   * certificate, specified by the Hub ID.\n   *\n   * @param request - The request {@link SetHubCARequest}\n   * @returns A Promise of Hub\n   */\n  setHubCA = request => this.client.fetch({\n    body: JSON.stringify(marshalSetHubCARequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}/ca`\n  }, unmarshalHub);\n\n  /**\n   * Get the certificate authority of a hub. Get information for a particular\n   * PEM-encoded certificate, specified by the Hub ID.\n   *\n   * @param request - The request {@link GetHubCARequest}\n   * @returns A Promise of GetHubCAResponse\n   */\n  getHubCA = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hubs/${validatePathParam('hubId', request.hubId)}/ca`\n  }, unmarshalGetHubCAResponse);\n  pageOfListDevices = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices`,\n    urlParams: urlParams(['allow_insecure', request.allowInsecure], ['hub_id', request.hubId], ['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['status', request.status ?? 'unknown'])\n  }, unmarshalListDevicesResponse);\n\n  /**\n   * List devices. List all devices in the specified region. By default,\n   * returned devices are ordered by creation date in ascending order, though\n   * this can be modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListDevicesRequest}\n   * @returns A Promise of ListDevicesResponse\n   */\n  listDevices = (request = {}) => enrichForPagination('devices', this.pageOfListDevices, request);\n\n  /**\n   * Add a device. Attach a device to a given Hub.\n   *\n   * @param request - The request {@link CreateDeviceRequest}\n   * @returns A Promise of CreateDeviceResponse\n   */\n  createDevice = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDeviceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices`\n  }, unmarshalCreateDeviceResponse);\n\n  /**\n   * Get a device. Retrieve information about an existing device, specified by\n   * its device ID. Its full details, including name, status and ID, are\n   * returned in the response object.\n   *\n   * @param request - The request {@link GetDeviceRequest}\n   * @returns A Promise of Device\n   */\n  getDevice = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}`\n  }, unmarshalDevice);\n\n  /**\n   * Update a device. Update the parameters of an existing device, specified by\n   * its device ID.\n   *\n   * @param request - The request {@link UpdateDeviceRequest}\n   * @returns A Promise of Device\n   */\n  updateDevice = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateDeviceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'PATCH',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}`\n  }, unmarshalDevice);\n\n  /**\n   * Enable a device. Enable a specific device, specified by its device ID.\n   *\n   * @param request - The request {@link EnableDeviceRequest}\n   * @returns A Promise of Device\n   */\n  enableDevice = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}/enable`\n  }, unmarshalDevice);\n\n  /**\n   * Disable a device. Disable an existing device, specified by its device ID.\n   *\n   * @param request - The request {@link DisableDeviceRequest}\n   * @returns A Promise of Device\n   */\n  disableDevice = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}/disable`\n  }, unmarshalDevice);\n\n  /**\n   * Renew a device certificate. Renew the certificate of an existing device,\n   * specified by its device ID.\n   *\n   * @param request - The request {@link RenewDeviceCertificateRequest}\n   * @returns A Promise of RenewDeviceCertificateResponse\n   */\n  renewDeviceCertificate = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}/renew-certificate`\n  }, unmarshalRenewDeviceCertificateResponse);\n\n  /**\n   * Set a custom certificate on a device. Switch the existing certificate of a\n   * given device with an EM-encoded custom certificate.\n   *\n   * @param request - The request {@link SetDeviceCertificateRequest}\n   * @returns A Promise of SetDeviceCertificateResponse\n   */\n  setDeviceCertificate = request => this.client.fetch({\n    body: JSON.stringify(marshalSetDeviceCertificateRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'PUT',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}/certificate`\n  }, unmarshalSetDeviceCertificateResponse);\n\n  /**\n   * Get a device's certificate. Get information for a particular PEM-encoded\n   * certificate, specified by the device ID. The response returns full details\n   * of the device, including its type of certificate.\n   *\n   * @param request - The request {@link GetDeviceCertificateRequest}\n   * @returns A Promise of GetDeviceCertificateResponse\n   */\n  getDeviceCertificate = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}/certificate`\n  }, unmarshalGetDeviceCertificateResponse);\n\n  /**\n   * Remove a device. Remove a specific device from the specific Hub it is\n   * attached to.\n   *\n   * @param request - The request {@link DeleteDeviceRequest}\n   */\n  deleteDevice = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}`\n  });\n\n  /**\n   * Get a device's metrics. Get the metrics of an existing device, specified by\n   * its device ID.\n   *\n   * @deprecated\n   * @param request - The request {@link GetDeviceMetricsRequest}\n   * @returns A Promise of GetDeviceMetricsResponse\n   */\n  getDeviceMetrics = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/devices/${validatePathParam('deviceId', request.deviceId)}/metrics`,\n    urlParams: urlParams(['start_date', request.startDate])\n  }, unmarshalGetDeviceMetricsResponse);\n  pageOfListRoutes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes`,\n    urlParams: urlParams(['hub_id', request.hubId], ['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListRoutesResponse$1);\n\n  /**\n   * List routes. List all routes in the specified region. By default, returned\n   * routes are ordered by creation date in ascending order, though this can be\n   * modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListRoutesRequest}\n   * @returns A Promise of ListRoutesResponse\n   */\n  listRoutes = (request = {}) => enrichForPagination('routes', this.pageOfListRoutes, request);\n\n  /**\n   * Create a route. Multiple kinds of routes can be created, such as:\n   *\n   * - Database Route Create a route that will record subscribed MQTT messages\n   *   into your database. <b>You need to manage the database by yourself</b>.\n   * - REST Route. Create a route that will call a REST API on received subscribed\n   *   MQTT messages.\n   * - S3 Routes. Create a route that will put subscribed MQTT messages into an S3\n   *   bucket. You need to create the bucket yourself and grant write access.\n   *   Granting can be done with s3cmd (`s3cmd setacl s3://&lt;my-bucket&gt;\n   *   --acl-grant=write:555c69c3-87d0-4bf8-80f1-99a2f757d031:555c69c3-87d0-4bf8-80f1-99a2f757d031`).\n   *\n   * @param request - The request {@link CreateRouteRequest}\n   * @returns A Promise of Route\n   */\n  createRoute = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateRouteRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes`\n  }, unmarshalRoute$1);\n\n  /**\n   * Update a route. Update the parameters of an existing route, specified by\n   * its route ID.\n   *\n   * @param request - The request {@link UpdateRouteRequest}\n   * @returns A Promise of Route\n   */\n  updateRoute = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateRouteRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'PATCH',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes/${validatePathParam('routeId', request.routeId)}`\n  }, unmarshalRoute$1);\n\n  /**\n   * Get a route. Get information for a particular route, specified by the route\n   * ID. The response returns full details of the route, including its type, the\n   * topic it subscribes to and its configuration.\n   *\n   * @param request - The request {@link GetRouteRequest}\n   * @returns A Promise of Route\n   */\n  getRoute = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes/${validatePathParam('routeId', request.routeId)}`\n  }, unmarshalRoute$1);\n\n  /**\n   * Delete a route. Delete an existing route, specified by its route ID.\n   * Deleting a route is permanent, and cannot be undone.\n   *\n   * @param request - The request {@link DeleteRouteRequest}\n   */\n  deleteRoute = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes/${validatePathParam('routeId', request.routeId)}`\n  });\n  pageOfListNetworks = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/networks`,\n    urlParams: urlParams(['hub_id', request.hubId], ['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['topic_prefix', request.topicPrefix])\n  }, unmarshalListNetworksResponse);\n\n  /**\n   * List the networks.\n   *\n   * @param request - The request {@link ListNetworksRequest}\n   * @returns A Promise of ListNetworksResponse\n   */\n  listNetworks = (request = {}) => enrichForPagination('networks', this.pageOfListNetworks, request);\n\n  /**\n   * Create a new network. Create a new network for an existing hub. Beside the\n   * default network, you can add networks for different data providers.\n   * Possible network types are Sigfox and REST.\n   *\n   * @param request - The request {@link CreateNetworkRequest}\n   * @returns A Promise of CreateNetworkResponse\n   */\n  createNetwork = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'POST',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/networks`\n  }, unmarshalCreateNetworkResponse);\n\n  /**\n   * Retrieve a specific network. Retrieve an existing network, specified by its\n   * network ID. The response returns full details of the network, including its\n   * type, the topic prefix and its endpoint.\n   *\n   * @param request - The request {@link GetNetworkRequest}\n   * @returns A Promise of Network\n   */\n  getNetwork = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/networks/${validatePathParam('networkId', request.networkId)}`\n  }, unmarshalNetwork);\n\n  /**\n   * Delete a Network. Delete an existing network, specified by its network ID.\n   * Deleting a network is permanent, and cannot be undone.\n   *\n   * @param request - The request {@link DeleteNetworkRequest}\n   */\n  deleteNetwork = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/networks/${validatePathParam('networkId', request.networkId)}`\n  });\n\n  /**\n   * BETA - Get a Cloud Twin Document.\n   *\n   * @param request - The request {@link GetTwinDocumentRequest}\n   * @returns A Promise of TwinDocument\n   */\n  getTwinDocument = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/twins/${validatePathParam('twinId', request.twinId)}/documents/${validatePathParam('documentName', request.documentName)}`\n  }, unmarshalTwinDocument);\n\n  /**\n   * BETA - Update a Cloud Twin Document.\n   *\n   * @param request - The request {@link PutTwinDocumentRequest}\n   * @returns A Promise of TwinDocument\n   */\n  putTwinDocument = request => this.client.fetch({\n    body: JSON.stringify(marshalPutTwinDocumentRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'PUT',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/twins/${validatePathParam('twinId', request.twinId)}/documents/${validatePathParam('documentName', request.documentName)}`\n  }, unmarshalTwinDocument);\n\n  /**\n   * BETA - Patch a Cloud Twin Document.\n   *\n   * @param request - The request {@link PatchTwinDocumentRequest}\n   * @returns A Promise of TwinDocument\n   */\n  patchTwinDocument = request => this.client.fetch({\n    body: JSON.stringify(marshalPatchTwinDocumentRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$c,\n    method: 'PATCH',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/twins/${validatePathParam('twinId', request.twinId)}/documents/${validatePathParam('documentName', request.documentName)}`\n  }, unmarshalTwinDocument);\n\n  /**\n   * BETA - Delete a Cloud Twin Document.\n   *\n   * @param request - The request {@link DeleteTwinDocumentRequest}\n   */\n  deleteTwinDocument = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/twins/${validatePathParam('twinId', request.twinId)}/documents/${validatePathParam('documentName', request.documentName)}`\n  });\n\n  /**\n   * BETA - List the documents of a Cloud Twin.\n   *\n   * @param request - The request {@link ListTwinDocumentsRequest}\n   * @returns A Promise of ListTwinDocumentsResponse\n   */\n  listTwinDocuments = request => this.client.fetch({\n    method: 'GET',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/twins/${validatePathParam('twinId', request.twinId)}`\n  }, unmarshalListTwinDocumentsResponse);\n\n  /**\n   * BETA - Delete all the documents of a Cloud Twin.\n   *\n   * @param request - The request {@link DeleteTwinDocumentsRequest}\n   */\n  deleteTwinDocuments = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/iot/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/twins/${validatePathParam('twinId', request.twinId)}`\n  });\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$c = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$e,\n  HUB_TRANSIENT_STATUSES: HUB_TRANSIENT_STATUSES\n});\n\nvar index$f = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$c\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link ClusterStatus}. */\nconst CLUSTER_TRANSIENT_STATUSES$1 = ['creating', 'deleting', 'updating'];\n\n/** Lists transient statutes of the enum {@link NodeStatus}. */\nconst NODE_TRANSIENT_STATUSES = ['creating', 'deleting', 'rebooting', 'upgrading', 'starting', 'registering'];\n\n/** Lists transient statutes of the enum {@link PoolStatus}. */\nconst POOL_TRANSIENT_STATUSES = ['deleting', 'scaling', 'upgrading'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalMaintenanceWindow = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'MaintenanceWindow' failed as data isn't a dictionary.`);\n  }\n  return {\n    day: data.day,\n    startHour: data.start_hour\n  };\n};\nconst unmarshalClusterAutoUpgrade = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClusterAutoUpgrade' failed as data isn't a dictionary.`);\n  }\n  return {\n    enabled: data.enabled,\n    maintenanceWindow: data.maintenance_window ? unmarshalMaintenanceWindow(data.maintenance_window) : undefined\n  };\n};\nconst unmarshalClusterAutoscalerConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClusterAutoscalerConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    balanceSimilarNodeGroups: data.balance_similar_node_groups,\n    estimator: data.estimator,\n    expander: data.expander,\n    expendablePodsPriorityCutoff: data.expendable_pods_priority_cutoff,\n    ignoreDaemonsetsUtilization: data.ignore_daemonsets_utilization,\n    maxGracefulTerminationSec: data.max_graceful_termination_sec,\n    scaleDownDelayAfterAdd: data.scale_down_delay_after_add,\n    scaleDownDisabled: data.scale_down_disabled,\n    scaleDownUnneededTime: data.scale_down_unneeded_time,\n    scaleDownUtilizationThreshold: data.scale_down_utilization_threshold\n  };\n};\nconst unmarshalClusterOpenIDConnectConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClusterOpenIDConnectConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    clientId: data.client_id,\n    groupsClaim: data.groups_claim,\n    groupsPrefix: data.groups_prefix,\n    issuerUrl: data.issuer_url,\n    requiredClaim: data.required_claim,\n    usernameClaim: data.username_claim,\n    usernamePrefix: data.username_prefix\n  };\n};\nconst unmarshalPoolUpgradePolicy = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PoolUpgradePolicy' failed as data isn't a dictionary.`);\n  }\n  return {\n    maxSurge: data.max_surge,\n    maxUnavailable: data.max_unavailable\n  };\n};\nconst unmarshalCluster$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Cluster' failed as data isn't a dictionary.`);\n  }\n  return {\n    admissionPlugins: data.admission_plugins,\n    apiserverCertSans: data.apiserver_cert_sans,\n    autoscalerConfig: data.autoscaler_config ? unmarshalClusterAutoscalerConfig(data.autoscaler_config) : undefined,\n    autoUpgrade: data.auto_upgrade ? unmarshalClusterAutoUpgrade(data.auto_upgrade) : undefined,\n    clusterUrl: data.cluster_url,\n    cni: data.cni,\n    createdAt: unmarshalDate(data.created_at),\n    dashboardEnabled: data.dashboard_enabled,\n    description: data.description,\n    dnsWildcard: data.dns_wildcard,\n    featureGates: data.feature_gates,\n    id: data.id,\n    ingress: data.ingress,\n    name: data.name,\n    openIdConnectConfig: data.open_id_connect_config ? unmarshalClusterOpenIDConnectConfig(data.open_id_connect_config) : undefined,\n    organizationId: data.organization_id,\n    privateNetworkId: data.private_network_id,\n    projectId: data.project_id,\n    region: data.region,\n    status: data.status,\n    tags: data.tags,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at),\n    upgradeAvailable: data.upgrade_available,\n    version: data.version\n  };\n};\nconst unmarshalNode = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Node' failed as data isn't a dictionary.`);\n  }\n  return {\n    clusterId: data.cluster_id,\n    conditions: data.conditions,\n    createdAt: unmarshalDate(data.created_at),\n    errorMessage: data.error_message,\n    id: data.id,\n    name: data.name,\n    poolId: data.pool_id,\n    providerId: data.provider_id,\n    publicIpV4: data.public_ip_v4,\n    publicIpV6: data.public_ip_v6,\n    region: data.region,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalPool = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Pool' failed as data isn't a dictionary.`);\n  }\n  return {\n    autohealing: data.autohealing,\n    autoscaling: data.autoscaling,\n    clusterId: data.cluster_id,\n    containerRuntime: data.container_runtime,\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    kubeletArgs: data.kubelet_args,\n    maxSize: data.max_size,\n    minSize: data.min_size,\n    name: data.name,\n    nodeType: data.node_type,\n    placementGroupId: data.placement_group_id,\n    region: data.region,\n    rootVolumeSize: data.root_volume_size,\n    rootVolumeType: data.root_volume_type,\n    size: data.size,\n    status: data.status,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    upgradePolicy: data.upgrade_policy ? unmarshalPoolUpgradePolicy(data.upgrade_policy) : undefined,\n    version: data.version,\n    zone: data.zone\n  };\n};\nconst unmarshalVersion$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Version' failed as data isn't a dictionary.`);\n  }\n  return {\n    availableAdmissionPlugins: data.available_admission_plugins,\n    availableCnis: data.available_cnis,\n    availableContainerRuntimes: data.available_container_runtimes,\n    availableFeatureGates: data.available_feature_gates,\n    availableIngresses: data.available_ingresses,\n    availableKubeletArgs: data.available_kubelet_args,\n    label: data.label,\n    name: data.name,\n    region: data.region\n  };\n};\nconst unmarshalExternalNode = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ExternalNode' failed as data isn't a dictionary.`);\n  }\n  return {\n    clusterCa: data.cluster_ca,\n    clusterUrl: data.cluster_url,\n    clusterVersion: data.cluster_version,\n    id: data.id,\n    kubeletConfig: data.kubelet_config,\n    kubeToken: data.kube_token,\n    name: data.name\n  };\n};\nconst unmarshalListClusterAvailableVersionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListClusterAvailableVersionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    versions: unmarshalArrayOfObject(data.versions, unmarshalVersion$2)\n  };\n};\nconst unmarshalListClustersResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListClustersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    clusters: unmarshalArrayOfObject(data.clusters, unmarshalCluster$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNodesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNodesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    nodes: unmarshalArrayOfObject(data.nodes, unmarshalNode),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPoolsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPoolsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    pools: unmarshalArrayOfObject(data.pools, unmarshalPool),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListVersionsResponse$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    versions: unmarshalArrayOfObject(data.versions, unmarshalVersion$2)\n  };\n};\nconst marshalCreateClusterRequestPoolConfigUpgradePolicy = (request, defaults) => ({\n  max_surge: request.maxSurge,\n  max_unavailable: request.maxUnavailable\n});\nconst marshalMaintenanceWindow = (request, defaults) => ({\n  day: request.day,\n  start_hour: request.startHour\n});\nconst marshalCreateClusterRequestAutoUpgrade = (request, defaults) => ({\n  enable: request.enable,\n  maintenance_window: request.maintenanceWindow ? marshalMaintenanceWindow(request.maintenanceWindow) : undefined\n});\nconst marshalCreateClusterRequestAutoscalerConfig = (request, defaults) => ({\n  balance_similar_node_groups: request.balanceSimilarNodeGroups,\n  estimator: request.estimator,\n  expander: request.expander,\n  expendable_pods_priority_cutoff: request.expendablePodsPriorityCutoff,\n  ignore_daemonsets_utilization: request.ignoreDaemonsetsUtilization,\n  max_graceful_termination_sec: request.maxGracefulTerminationSec,\n  scale_down_delay_after_add: request.scaleDownDelayAfterAdd,\n  scale_down_disabled: request.scaleDownDisabled,\n  scale_down_unneeded_time: request.scaleDownUnneededTime,\n  scale_down_utilization_threshold: request.scaleDownUtilizationThreshold\n});\nconst marshalCreateClusterRequestOpenIDConnectConfig = (request, defaults) => ({\n  client_id: request.clientId,\n  groups_claim: request.groupsClaim,\n  groups_prefix: request.groupsPrefix,\n  issuer_url: request.issuerUrl,\n  required_claim: request.requiredClaim,\n  username_claim: request.usernameClaim,\n  username_prefix: request.usernamePrefix\n});\nconst marshalCreateClusterRequestPoolConfig = (request, defaults) => ({\n  autohealing: request.autohealing,\n  autoscaling: request.autoscaling,\n  container_runtime: request.containerRuntime,\n  kubelet_args: request.kubeletArgs,\n  max_size: request.maxSize,\n  min_size: request.minSize,\n  name: request.name,\n  node_type: request.nodeType,\n  placement_group_id: request.placementGroupId,\n  root_volume_size: request.rootVolumeSize,\n  root_volume_type: request.rootVolumeType,\n  size: request.size,\n  tags: request.tags,\n  upgrade_policy: request.upgradePolicy ? marshalCreateClusterRequestPoolConfigUpgradePolicy(request.upgradePolicy) : undefined,\n  zone: request.zone\n});\nconst marshalCreatePoolRequestUpgradePolicy = (request, defaults) => ({\n  max_surge: request.maxSurge,\n  max_unavailable: request.maxUnavailable\n});\nconst marshalUpdateClusterRequestAutoUpgrade = (request, defaults) => ({\n  enable: request.enable,\n  maintenance_window: request.maintenanceWindow ? marshalMaintenanceWindow(request.maintenanceWindow) : undefined\n});\nconst marshalUpdateClusterRequestAutoscalerConfig = (request, defaults) => ({\n  balance_similar_node_groups: request.balanceSimilarNodeGroups,\n  estimator: request.estimator,\n  expander: request.expander,\n  expendable_pods_priority_cutoff: request.expendablePodsPriorityCutoff,\n  ignore_daemonsets_utilization: request.ignoreDaemonsetsUtilization,\n  max_graceful_termination_sec: request.maxGracefulTerminationSec,\n  scale_down_delay_after_add: request.scaleDownDelayAfterAdd,\n  scale_down_disabled: request.scaleDownDisabled,\n  scale_down_unneeded_time: request.scaleDownUnneededTime,\n  scale_down_utilization_threshold: request.scaleDownUtilizationThreshold\n});\nconst marshalUpdateClusterRequestOpenIDConnectConfig = (request, defaults) => ({\n  client_id: request.clientId,\n  groups_claim: request.groupsClaim,\n  groups_prefix: request.groupsPrefix,\n  issuer_url: request.issuerUrl,\n  required_claim: request.requiredClaim,\n  username_claim: request.usernameClaim,\n  username_prefix: request.usernamePrefix\n});\nconst marshalUpdatePoolRequestUpgradePolicy = (request, defaults) => ({\n  max_surge: request.maxSurge,\n  max_unavailable: request.maxUnavailable\n});\nconst marshalCreateClusterRequest$1 = (request, defaults) => ({\n  admission_plugins: request.admissionPlugins,\n  apiserver_cert_sans: request.apiserverCertSans,\n  auto_upgrade: request.autoUpgrade ? marshalCreateClusterRequestAutoUpgrade(request.autoUpgrade) : undefined,\n  autoscaler_config: request.autoscalerConfig ? marshalCreateClusterRequestAutoscalerConfig(request.autoscalerConfig) : undefined,\n  cni: request.cni,\n  description: request.description,\n  enable_dashboard: request.enableDashboard,\n  feature_gates: request.featureGates,\n  ingress: request.ingress,\n  name: request.name || randomName('k8s'),\n  open_id_connect_config: request.openIdConnectConfig ? marshalCreateClusterRequestOpenIDConnectConfig(request.openIdConnectConfig) : undefined,\n  pools: request.pools ? request.pools.map(elt => marshalCreateClusterRequestPoolConfig(elt)) : undefined,\n  private_network_id: request.privateNetworkId,\n  tags: request.tags,\n  type: request.type,\n  version: request.version,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalCreatePoolRequest = (request, defaults) => ({\n  autohealing: request.autohealing,\n  autoscaling: request.autoscaling,\n  container_runtime: request.containerRuntime ?? 'unknown_runtime',\n  kubelet_args: request.kubeletArgs,\n  max_size: request.maxSize,\n  min_size: request.minSize,\n  name: request.name || randomName('pool'),\n  node_type: request.nodeType,\n  placement_group_id: request.placementGroupId,\n  root_volume_size: request.rootVolumeSize,\n  root_volume_type: request.rootVolumeType ?? 'default_volume_type',\n  size: request.size,\n  tags: request.tags,\n  upgrade_policy: request.upgradePolicy ? marshalCreatePoolRequestUpgradePolicy(request.upgradePolicy) : undefined,\n  zone: request.zone ?? defaults.defaultZone\n});\nconst marshalSetClusterTypeRequest = (request, defaults) => ({\n  type: request.type\n});\nconst marshalUpdateClusterRequest$1 = (request, defaults) => ({\n  admission_plugins: request.admissionPlugins,\n  apiserver_cert_sans: request.apiserverCertSans,\n  auto_upgrade: request.autoUpgrade ? marshalUpdateClusterRequestAutoUpgrade(request.autoUpgrade) : undefined,\n  autoscaler_config: request.autoscalerConfig ? marshalUpdateClusterRequestAutoscalerConfig(request.autoscalerConfig) : undefined,\n  description: request.description,\n  enable_dashboard: request.enableDashboard,\n  feature_gates: request.featureGates,\n  ingress: request.ingress,\n  name: request.name,\n  open_id_connect_config: request.openIdConnectConfig ? marshalUpdateClusterRequestOpenIDConnectConfig(request.openIdConnectConfig) : undefined,\n  tags: request.tags\n});\nconst marshalUpdatePoolRequest = (request, defaults) => ({\n  autohealing: request.autohealing,\n  autoscaling: request.autoscaling,\n  kubelet_args: request.kubeletArgs,\n  max_size: request.maxSize,\n  min_size: request.minSize,\n  size: request.size,\n  tags: request.tags,\n  upgrade_policy: request.upgradePolicy ? marshalUpdatePoolRequestUpgradePolicy(request.upgradePolicy) : undefined\n});\nconst marshalUpgradeClusterRequest = (request, defaults) => ({\n  upgrade_pools: request.upgradePools,\n  version: request.version\n});\nconst marshalUpgradePoolRequest = (request, defaults) => ({\n  version: request.version\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$b = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Kubernetes API. */\nlet API$d = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par', 'nl-ams', 'pl-waw'];\n  pageOfListClusters = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['status', request.status ?? 'unknown'], ['type', request.type])\n  }, unmarshalListClustersResponse$1);\n\n  /**\n   * List Clusters. List all existing Kubernetes clusters in a specific region.\n   *\n   * @param request - The request {@link ListClustersRequest}\n   * @returns A Promise of ListClustersResponse\n   */\n  listClusters = (request = {}) => enrichForPagination('clusters', this.pageOfListClusters, request);\n\n  /**\n   * Create a new Cluster. Create a new Kubernetes cluster in a Scaleway region.\n   *\n   * @param request - The request {@link CreateClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  createCluster = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateClusterRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters`\n  }, unmarshalCluster$1);\n\n  /**\n   * Get a Cluster. Retrieve information about a specific Kubernetes cluster.\n   *\n   * @param request - The request {@link GetClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  getCluster = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}`\n  }, unmarshalCluster$1);\n\n  /**\n   * Waits for {@link Cluster} to be in a final state.\n   *\n   * @param request - The request {@link GetClusterRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Cluster\n   */\n  waitForCluster = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!CLUSTER_TRANSIENT_STATUSES$1.includes(res.status))), this.getCluster, request, options);\n\n  /**\n   * Update a Cluster. Update information on a specific Kubernetes cluster. You\n   * can update details such as its name, description, tags and configuration.\n   * To upgrade a cluster, you will need to use the dedicated endpoint.\n   *\n   * @param request - The request {@link UpdateClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  updateCluster = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateClusterRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$b,\n    method: 'PATCH',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}`\n  }, unmarshalCluster$1);\n\n  /**\n   * Delete a Cluster. Delete a specific Kubernetes cluster and all its\n   * associated pools and nodes. Note that this method will not delete any Load\n   * Balancer or Block Volume that are associated with the cluster.\n   *\n   * @param request - The request {@link DeleteClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  deleteCluster = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}`,\n    urlParams: urlParams(['with_additional_resources', request.withAdditionalResources])\n  }, unmarshalCluster$1);\n\n  /**\n   * Upgrade a Cluster. Upgrade a specific Kubernetes cluster and possibly its\n   * associated pools to a specific and supported Kubernetes version.\n   *\n   * @param request - The request {@link UpgradeClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  upgradeCluster = request => this.client.fetch({\n    body: JSON.stringify(marshalUpgradeClusterRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/upgrade`\n  }, unmarshalCluster$1);\n\n  /**\n   * Change the Cluster type. Change the type of a specific Kubernetes cluster.\n   *\n   * @param request - The request {@link SetClusterTypeRequest}\n   * @returns A Promise of Cluster\n   */\n  setClusterType = request => this.client.fetch({\n    body: JSON.stringify(marshalSetClusterTypeRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/set-type`\n  }, unmarshalCluster$1);\n\n  /**\n   * List available versions for a Cluster. List the versions that a specific\n   * Kubernetes cluster is allowed to upgrade to. Results will include every\n   * patch version greater than the current patch, as well as one minor version\n   * ahead of the current version. Any upgrade skipping a minor version will not\n   * work.\n   *\n   * @param request - The request {@link ListClusterAvailableVersionsRequest}\n   * @returns A Promise of ListClusterAvailableVersionsResponse\n   */\n  listClusterAvailableVersions = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/available-versions`\n  }, unmarshalListClusterAvailableVersionsResponse);\n  _getClusterKubeConfig = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/kubeconfig`,\n    urlParams: urlParams(['dl', 1]),\n    responseType: 'blob'\n  });\n\n  /**\n   * Reset the admin token of a Cluster. Reset the admin token for a specific\n   * Kubernetes cluster. This will revoke the old admin token (which will not be\n   * usable afterwards) and create a new one. Note that you will need to\n   * download kubeconfig again to keep interacting with the cluster.\n   *\n   * @param request - The request {@link ResetClusterAdminTokenRequest}\n   */\n  resetClusterAdminToken = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/reset-admin-token`\n  });\n  pageOfListPools = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/pools`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['status', request.status ?? 'unknown'])\n  }, unmarshalListPoolsResponse);\n\n  /**\n   * List Pools in a Cluster. List all the existing pools for a specific\n   * Kubernetes cluster.\n   *\n   * @param request - The request {@link ListPoolsRequest}\n   * @returns A Promise of ListPoolsResponse\n   */\n  listPools = request => enrichForPagination('pools', this.pageOfListPools, request);\n\n  /**\n   * Create a new Pool in a Cluster. Create a new pool in a specific Kubernetes\n   * cluster.\n   *\n   * @param request - The request {@link CreatePoolRequest}\n   * @returns A Promise of Pool\n   */\n  createPool = request => this.client.fetch({\n    body: JSON.stringify(marshalCreatePoolRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/pools`\n  }, unmarshalPool);\n\n  /**\n   * Get a Pool in a Cluster. Retrieve details about a specific pool in a\n   * Kubernetes cluster.\n   *\n   * @param request - The request {@link GetPoolRequest}\n   * @returns A Promise of Pool\n   */\n  getPool = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/pools/${validatePathParam('poolId', request.poolId)}`\n  }, unmarshalPool);\n\n  /**\n   * Waits for {@link Pool} to be in a final state.\n   *\n   * @param request - The request {@link GetPoolRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Pool\n   */\n  waitForPool = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!POOL_TRANSIENT_STATUSES.includes(res.status))), this.getPool, request, options);\n\n  /**\n   * Upgrade a Pool in a Cluster. Upgrade the Kubernetes version of a specific\n   * pool. Note that it only works if the targeted version matches the cluster's\n   * version.\n   *\n   * @param request - The request {@link UpgradePoolRequest}\n   * @returns A Promise of Pool\n   */\n  upgradePool = request => this.client.fetch({\n    body: JSON.stringify(marshalUpgradePoolRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/pools/${validatePathParam('poolId', request.poolId)}/upgrade`\n  }, unmarshalPool);\n\n  /**\n   * Update a Pool in a Cluster. Update the attributes of a specific pool, such\n   * as its desired size, autoscaling settings, and tags.\n   *\n   * @param request - The request {@link UpdatePoolRequest}\n   * @returns A Promise of Pool\n   */\n  updatePool = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdatePoolRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$b,\n    method: 'PATCH',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/pools/${validatePathParam('poolId', request.poolId)}`\n  }, unmarshalPool);\n\n  /**\n   * Delete a Pool in a Cluster. Delete a specific pool from a cluster. Note\n   * that all the pool's nodes will also be deleted.\n   *\n   * @param request - The request {@link DeletePoolRequest}\n   * @returns A Promise of Pool\n   */\n  deletePool = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/pools/${validatePathParam('poolId', request.poolId)}`\n  }, unmarshalPool);\n\n  /**\n   * Create a Kosmos node. Retrieve metadata for a Kosmos node. This method is\n   * not intended to be called by end users but rather programmatically by the\n   * kapsule-node-agent.\n   *\n   * @param request - The request {@link CreateExternalNodeRequest}\n   * @returns A Promise of ExternalNode\n   */\n  createExternalNode = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/pools/${validatePathParam('poolId', request.poolId)}/external-nodes`\n  }, unmarshalExternalNode);\n  pageOfListNodes = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/clusters/${validatePathParam('clusterId', request.clusterId)}/nodes`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['pool_id', request.poolId], ['status', request.status ?? 'unknown'])\n  }, unmarshalListNodesResponse);\n\n  /**\n   * List Nodes in a Cluster. List all the existing nodes for a specific\n   * Kubernetes cluster.\n   *\n   * @param request - The request {@link ListNodesRequest}\n   * @returns A Promise of ListNodesResponse\n   */\n  listNodes = request => enrichForPagination('nodes', this.pageOfListNodes, request);\n\n  /**\n   * Get a Node in a Cluster. Retrieve details about a specific Kubernetes Node.\n   *\n   * @param request - The request {@link GetNodeRequest}\n   * @returns A Promise of Node\n   */\n  getNode = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/nodes/${validatePathParam('nodeId', request.nodeId)}`\n  }, unmarshalNode);\n\n  /**\n   * Waits for {@link Node} to be in a final state.\n   *\n   * @param request - The request {@link GetNodeRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Node\n   */\n  waitForNode = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!NODE_TRANSIENT_STATUSES.includes(res.status))), this.getNode, request, options);\n\n  /**\n   * Replace a Node in a Cluster. Replace a specific Node. The node will first\n   * be cordoned (scheduling will be disabled on it). The existing pods on the\n   * node will then be drained and rescheduled onto another schedulable node.\n   * Note that when there is not enough space to reschedule all the pods (such\n   * as in a one-node cluster), disruption of your applications can be\n   * expected.\n   *\n   * @deprecated\n   * @param request - The request {@link ReplaceNodeRequest}\n   * @returns A Promise of Node\n   */\n  replaceNode = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/nodes/${validatePathParam('nodeId', request.nodeId)}/replace`\n  }, unmarshalNode);\n\n  /**\n   * Reboot a Node in a Cluster. Reboot a specific Node. The node will first be\n   * cordoned (scheduling will be disabled on it). The existing pods on the node\n   * will then be drained and rescheduled onto another schedulable node. Note\n   * that when there is not enough space to reschedule all the pods (such as in\n   * a one-node cluster), disruption of your applications can be expected.\n   *\n   * @param request - The request {@link RebootNodeRequest}\n   * @returns A Promise of Node\n   */\n  rebootNode = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$b,\n    method: 'POST',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/nodes/${validatePathParam('nodeId', request.nodeId)}/reboot`\n  }, unmarshalNode);\n\n  /**\n   * Delete a Node in a Cluster. Delete a specific Node. Note that when there is\n   * not enough space to reschedule all the pods (such as in a one-node\n   * cluster), disruption of your applications can be expected.\n   *\n   * @param request - The request {@link DeleteNodeRequest}\n   * @returns A Promise of Node\n   */\n  deleteNode = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/nodes/${validatePathParam('nodeId', request.nodeId)}`,\n    urlParams: urlParams(['replace', request.replace], ['skip_drain', request.skipDrain])\n  }, unmarshalNode);\n\n  /**\n   * List all available Versions. List all available versions for the creation\n   * of a new Kubernetes cluster.\n   *\n   * @param request - The request {@link ListVersionsRequest}\n   * @returns A Promise of ListVersionsResponse\n   */\n  listVersions = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/versions`\n  }, unmarshalListVersionsResponse$2);\n\n  /**\n   * Get a Version. Retrieve a specific Kubernetes version and its details.\n   *\n   * @param request - The request {@link GetVersionRequest}\n   * @returns A Promise of Version\n   */\n  getVersion = request => this.client.fetch({\n    method: 'GET',\n    path: `/k8s/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/versions/${validatePathParam('versionName', request.versionName)}`\n  }, unmarshalVersion$2);\n};\n\nclass K8SUtilsAPI extends API$d {\n  /**\n   * Get configuration of a kube cluster.\n   *\n   * @param request - The request {@link GetClusterKubeConfigRequest}\n   * @returns A Promise of Blob\n   */\n  getClusterKubeConfig = request => this._getClusterKubeConfig(request);\n}\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nconst CreateClusterRequest = {\n  name: {\n    minLength: 1\n  }\n};\nconst CreateClusterRequestAutoscalerConfig = {\n  scaleDownUtilizationThreshold: {\n    greaterThan: 0,\n    lessThan: 1\n  }\n};\nconst CreateClusterRequestOpenIDConnectConfig = {\n  clientId: {\n    minLength: 1\n  },\n  groupsPrefix: {\n    minLength: 1\n  },\n  usernameClaim: {\n    minLength: 1\n  },\n  usernamePrefix: {\n    minLength: 1\n  }\n};\nconst CreateClusterRequestPoolConfig = {\n  name: {\n    minLength: 1\n  }\n};\nconst CreatePoolRequest = {\n  name: {\n    minLength: 1\n  }\n};\nconst ListClustersRequest = {\n  name: {\n    minLength: 1\n  },\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst ListNodesRequest = {\n  name: {\n    minLength: 1\n  },\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst ListPoolsRequest = {\n  name: {\n    minLength: 1\n  },\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\nconst MaintenanceWindow = {\n  startHour: {\n    lessThanOrEqual: 23\n  }\n};\nconst UpdateClusterRequest = {\n  name: {\n    minLength: 1\n  }\n};\nconst UpdateClusterRequestAutoscalerConfig = {\n  scaleDownUtilizationThreshold: {\n    greaterThan: 0,\n    lessThan: 1\n  }\n};\n\nvar validationRules_gen$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CreateClusterRequest: CreateClusterRequest,\n  CreateClusterRequestAutoscalerConfig: CreateClusterRequestAutoscalerConfig,\n  CreateClusterRequestOpenIDConnectConfig: CreateClusterRequestOpenIDConnectConfig,\n  CreateClusterRequestPoolConfig: CreateClusterRequestPoolConfig,\n  CreatePoolRequest: CreatePoolRequest,\n  ListClustersRequest: ListClustersRequest,\n  ListNodesRequest: ListNodesRequest,\n  ListPoolsRequest: ListPoolsRequest,\n  MaintenanceWindow: MaintenanceWindow,\n  UpdateClusterRequest: UpdateClusterRequest,\n  UpdateClusterRequestAutoscalerConfig: UpdateClusterRequestAutoscalerConfig\n});\n\nvar index$e = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: K8SUtilsAPI,\n  CLUSTER_TRANSIENT_STATUSES: CLUSTER_TRANSIENT_STATUSES$1,\n  NODE_TRANSIENT_STATUSES: NODE_TRANSIENT_STATUSES,\n  POOL_TRANSIENT_STATUSES: POOL_TRANSIENT_STATUSES,\n  ValidationRules: validationRules_gen$1\n});\n\nvar index$d = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index$e\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link CertificateStatus}. */\nconst CERTIFICATE_TRANSIENT_STATUSES = ['pending'];\n\n/** Lists transient statutes of the enum {@link InstanceStatus}. */\nconst INSTANCE_TRANSIENT_STATUSES$1 = ['pending', 'migrating'];\n\n/** Lists transient statutes of the enum {@link LbStatus}. */\nconst LB_TRANSIENT_STATUSES = ['pending', 'migrating', 'to_create', 'creating', 'to_delete', 'deleting'];\n\n/** Lists transient statutes of the enum {@link PrivateNetworkStatus}. */\nconst PRIVATE_NETWORK_TRANSIENT_STATUSES = ['pending'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalSubscriberEmailConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SubscriberEmailConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    email: data.email\n  };\n};\nconst unmarshalSubscriberWebhookConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SubscriberWebhookConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    uri: data.uri\n  };\n};\nconst unmarshalHealthCheckHttpConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheckHttpConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    code: data.code,\n    hostHeader: data.host_header,\n    method: data.method,\n    uri: data.uri\n  };\n};\nconst unmarshalHealthCheckHttpsConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheckHttpsConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    code: data.code,\n    hostHeader: data.host_header,\n    method: data.method,\n    sni: data.sni,\n    uri: data.uri\n  };\n};\nconst unmarshalHealthCheckLdapConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheckLdapConfig' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalHealthCheckMysqlConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheckMysqlConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    user: data.user\n  };\n};\nconst unmarshalHealthCheckPgsqlConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheckPgsqlConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    user: data.user\n  };\n};\nconst unmarshalHealthCheckRedisConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheckRedisConfig' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalHealthCheckTcpConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheckTcpConfig' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalInstance$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Instance' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    ipAddress: data.ip_address,\n    region: data.region,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalIp = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Ip' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    ipAddress: data.ip_address,\n    lbId: data.lb_id,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    region: data.region,\n    reverse: data.reverse,\n    zone: data.zone\n  };\n};\nconst unmarshalSubscriber = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Subscriber' failed as data isn't a dictionary.`);\n  }\n  return {\n    emailConfig: data.email_config ? unmarshalSubscriberEmailConfig(data.email_config) : undefined,\n    id: data.id,\n    name: data.name,\n    webhookConfig: data.webhook_config ? unmarshalSubscriberWebhookConfig(data.webhook_config) : undefined\n  };\n};\nconst unmarshalHealthCheck = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HealthCheck' failed as data isn't a dictionary.`);\n  }\n  return {\n    checkDelay: data.check_delay,\n    checkMaxRetries: data.check_max_retries,\n    checkSendProxy: data.check_send_proxy,\n    checkTimeout: data.check_timeout,\n    httpConfig: data.http_config ? unmarshalHealthCheckHttpConfig(data.http_config) : undefined,\n    httpsConfig: data.https_config ? unmarshalHealthCheckHttpsConfig(data.https_config) : undefined,\n    ldapConfig: data.ldap_config ? unmarshalHealthCheckLdapConfig(data.ldap_config) : undefined,\n    mysqlConfig: data.mysql_config ? unmarshalHealthCheckMysqlConfig(data.mysql_config) : undefined,\n    pgsqlConfig: data.pgsql_config ? unmarshalHealthCheckPgsqlConfig(data.pgsql_config) : undefined,\n    port: data.port,\n    redisConfig: data.redis_config ? unmarshalHealthCheckRedisConfig(data.redis_config) : undefined,\n    tcpConfig: data.tcp_config ? unmarshalHealthCheckTcpConfig(data.tcp_config) : undefined,\n    transientCheckDelay: data.transient_check_delay\n  };\n};\nconst unmarshalLb = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Lb' failed as data isn't a dictionary.`);\n  }\n  return {\n    backendCount: data.backend_count,\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    frontendCount: data.frontend_count,\n    id: data.id,\n    instances: unmarshalArrayOfObject(data.instances, unmarshalInstance$1),\n    ip: unmarshalArrayOfObject(data.ip, unmarshalIp),\n    name: data.name,\n    organizationId: data.organization_id,\n    privateNetworkCount: data.private_network_count,\n    projectId: data.project_id,\n    region: data.region,\n    routeCount: data.route_count,\n    sslCompatibilityLevel: data.ssl_compatibility_level,\n    status: data.status,\n    subscriber: data.subscriber ? unmarshalSubscriber(data.subscriber) : undefined,\n    tags: data.tags,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalAclActionRedirect = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AclActionRedirect' failed as data isn't a dictionary.`);\n  }\n  return {\n    code: data.code,\n    target: data.target,\n    type: data.type\n  };\n};\nconst unmarshalBackend = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Backend' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    failoverHost: data.failover_host,\n    forwardPort: data.forward_port,\n    forwardPortAlgorithm: data.forward_port_algorithm,\n    forwardProtocol: data.forward_protocol,\n    healthCheck: data.health_check ? unmarshalHealthCheck(data.health_check) : undefined,\n    id: data.id,\n    ignoreSslServerVerify: data.ignore_ssl_server_verify,\n    lb: data.lb ? unmarshalLb(data.lb) : undefined,\n    maxConnections: data.max_connections,\n    maxRetries: data.max_retries,\n    name: data.name,\n    onMarkedDownAction: data.on_marked_down_action,\n    pool: data.pool,\n    proxyProtocol: data.proxy_protocol,\n    redispatchAttemptCount: data.redispatch_attempt_count,\n    sendProxyV2: data.send_proxy_v2,\n    sslBridging: data.ssl_bridging,\n    stickySessions: data.sticky_sessions,\n    stickySessionsCookieName: data.sticky_sessions_cookie_name,\n    timeoutConnect: data.timeout_connect,\n    timeoutQueue: data.timeout_queue,\n    timeoutServer: data.timeout_server,\n    timeoutTunnel: data.timeout_tunnel,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalCertificate = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Certificate' failed as data isn't a dictionary.`);\n  }\n  return {\n    commonName: data.common_name,\n    createdAt: unmarshalDate(data.created_at),\n    fingerprint: data.fingerprint,\n    id: data.id,\n    lb: data.lb ? unmarshalLb(data.lb) : undefined,\n    name: data.name,\n    notValidAfter: unmarshalDate(data.not_valid_after),\n    notValidBefore: unmarshalDate(data.not_valid_before),\n    status: data.status,\n    statusDetails: data.status_details,\n    subjectAlternativeName: data.subject_alternative_name,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalAclAction = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AclAction' failed as data isn't a dictionary.`);\n  }\n  return {\n    redirect: data.redirect ? unmarshalAclActionRedirect(data.redirect) : undefined,\n    type: data.type\n  };\n};\nconst unmarshalAclMatch = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AclMatch' failed as data isn't a dictionary.`);\n  }\n  return {\n    httpFilter: data.http_filter,\n    httpFilterOption: data.http_filter_option,\n    httpFilterValue: data.http_filter_value,\n    invert: data.invert,\n    ipSubnet: data.ip_subnet\n  };\n};\nconst unmarshalFrontend = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Frontend' failed as data isn't a dictionary.`);\n  }\n  return {\n    backend: data.backend ? unmarshalBackend(data.backend) : undefined,\n    certificate: data.certificate ? unmarshalCertificate(data.certificate) : undefined,\n    certificateIds: data.certificate_ids,\n    createdAt: unmarshalDate(data.created_at),\n    enableHttp3: data.enable_http3,\n    id: data.id,\n    inboundPort: data.inbound_port,\n    lb: data.lb ? unmarshalLb(data.lb) : undefined,\n    name: data.name,\n    timeoutClient: data.timeout_client,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalPrivateNetworkDHCPConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrivateNetworkDHCPConfig' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalPrivateNetworkIpamConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrivateNetworkIpamConfig' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalPrivateNetworkStaticConfig = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrivateNetworkStaticConfig' failed as data isn't a dictionary.`);\n  }\n  return {\n    ipAddress: data.ip_address\n  };\n};\nconst unmarshalRouteMatch = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RouteMatch' failed as data isn't a dictionary.`);\n  }\n  return {\n    hostHeader: data.host_header,\n    sni: data.sni\n  };\n};\nconst unmarshalAcl = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Acl' failed as data isn't a dictionary.`);\n  }\n  return {\n    action: data.action ? unmarshalAclAction(data.action) : undefined,\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    frontend: data.frontend ? unmarshalFrontend(data.frontend) : undefined,\n    id: data.id,\n    index: data.index,\n    match: data.match ? unmarshalAclMatch(data.match) : undefined,\n    name: data.name,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalBackendServerStats = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'BackendServerStats' failed as data isn't a dictionary.`);\n  }\n  return {\n    backendId: data.backend_id,\n    instanceId: data.instance_id,\n    ip: data.ip,\n    lastHealthCheckStatus: data.last_health_check_status,\n    serverState: data.server_state,\n    serverStateChangedAt: unmarshalDate(data.server_state_changed_at)\n  };\n};\nconst unmarshalLbType = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'LbType' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    name: data.name,\n    region: data.region,\n    stockStatus: data.stock_status,\n    zone: data.zone\n  };\n};\nconst unmarshalPrivateNetwork$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrivateNetwork' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    dhcpConfig: data.dhcp_config ? unmarshalPrivateNetworkDHCPConfig(data.dhcp_config) : undefined,\n    ipamConfig: data.ipam_config ? unmarshalPrivateNetworkIpamConfig(data.ipam_config) : undefined,\n    lb: data.lb ? unmarshalLb(data.lb) : undefined,\n    privateNetworkId: data.private_network_id,\n    staticConfig: data.static_config ? unmarshalPrivateNetworkStaticConfig(data.static_config) : undefined,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalRoute = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Route' failed as data isn't a dictionary.`);\n  }\n  return {\n    backendId: data.backend_id,\n    createdAt: unmarshalDate(data.created_at),\n    frontendId: data.frontend_id,\n    id: data.id,\n    match: data.match ? unmarshalRouteMatch(data.match) : undefined,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalLbStats = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'LbStats' failed as data isn't a dictionary.`);\n  }\n  return {\n    backendServersStats: unmarshalArrayOfObject(data.backend_servers_stats, unmarshalBackendServerStats)\n  };\n};\nconst unmarshalListAclResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListAclResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    acls: unmarshalArrayOfObject(data.acls, unmarshalAcl),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListBackendStatsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListBackendStatsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    backendServersStats: unmarshalArrayOfObject(data.backend_servers_stats, unmarshalBackendServerStats),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListBackendsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListBackendsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    backends: unmarshalArrayOfObject(data.backends, unmarshalBackend),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListCertificatesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListCertificatesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    certificates: unmarshalArrayOfObject(data.certificates, unmarshalCertificate),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListFrontendsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListFrontendsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    frontends: unmarshalArrayOfObject(data.frontends, unmarshalFrontend),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListIpsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListIpsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ips: unmarshalArrayOfObject(data.ips, unmarshalIp),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListLbPrivateNetworksResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListLbPrivateNetworksResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    privateNetwork: unmarshalArrayOfObject(data.private_network, unmarshalPrivateNetwork$2),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListLbTypesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListLbTypesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    lbTypes: unmarshalArrayOfObject(data.lb_types, unmarshalLbType),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListLbsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListLbsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    lbs: unmarshalArrayOfObject(data.lbs, unmarshalLb),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListRoutesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListRoutesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    routes: unmarshalArrayOfObject(data.routes, unmarshalRoute),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSubscriberResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSubscriberResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    subscribers: unmarshalArrayOfObject(data.subscribers, unmarshalSubscriber),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalSetAclsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetAclsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    acls: unmarshalArrayOfObject(data.acls, unmarshalAcl),\n    totalCount: data.total_count\n  };\n};\nconst marshalAclActionRedirect = (request, defaults) => ({\n  code: request.code,\n  target: request.target,\n  type: request.type\n});\nconst marshalAclAction = (request, defaults) => ({\n  redirect: request.redirect ? marshalAclActionRedirect(request.redirect) : undefined,\n  type: request.type\n});\nconst marshalAclMatch = (request, defaults) => ({\n  http_filter: request.httpFilter,\n  http_filter_option: request.httpFilterOption,\n  http_filter_value: request.httpFilterValue,\n  invert: request.invert,\n  ip_subnet: request.ipSubnet\n});\nconst marshalHealthCheckHttpConfig = (request, defaults) => ({\n  code: request.code,\n  host_header: request.hostHeader,\n  method: request.method,\n  uri: request.uri\n});\nconst marshalHealthCheckHttpsConfig = (request, defaults) => ({\n  code: request.code,\n  host_header: request.hostHeader,\n  method: request.method,\n  sni: request.sni,\n  uri: request.uri\n});\nconst marshalHealthCheckLdapConfig = (request, defaults) => ({});\nconst marshalHealthCheckMysqlConfig = (request, defaults) => ({\n  user: request.user\n});\nconst marshalHealthCheckPgsqlConfig = (request, defaults) => ({\n  user: request.user\n});\nconst marshalHealthCheckRedisConfig = (request, defaults) => ({});\nconst marshalHealthCheckTcpConfig = (request, defaults) => ({});\nconst marshalAclSpec = (request, defaults) => ({\n  action: marshalAclAction(request.action),\n  description: request.description,\n  index: request.index,\n  match: request.match ? marshalAclMatch(request.match) : undefined,\n  name: request.name\n});\nconst marshalCreateCertificateRequestCustomCertificate = (request, defaults) => ({\n  certificate_chain: request.certificateChain\n});\nconst marshalCreateCertificateRequestLetsencryptConfig = (request, defaults) => ({\n  common_name: request.commonName,\n  subject_alternative_name: request.subjectAlternativeName\n});\nconst marshalHealthCheck = (request, defaults) => ({\n  check_delay: request.checkDelay,\n  check_max_retries: request.checkMaxRetries,\n  check_send_proxy: request.checkSendProxy,\n  check_timeout: request.checkTimeout,\n  port: request.port,\n  transient_check_delay: request.transientCheckDelay,\n  ...resolveOneOf([{\n    param: 'tcp_config',\n    value: request.tcpConfig ? marshalHealthCheckTcpConfig(request.tcpConfig) : undefined\n  }, {\n    param: 'mysql_config',\n    value: request.mysqlConfig ? marshalHealthCheckMysqlConfig(request.mysqlConfig) : undefined\n  }, {\n    param: 'pgsql_config',\n    value: request.pgsqlConfig ? marshalHealthCheckPgsqlConfig(request.pgsqlConfig) : undefined\n  }, {\n    param: 'ldap_config',\n    value: request.ldapConfig ? marshalHealthCheckLdapConfig(request.ldapConfig) : undefined\n  }, {\n    param: 'redis_config',\n    value: request.redisConfig ? marshalHealthCheckRedisConfig(request.redisConfig) : undefined\n  }, {\n    param: 'http_config',\n    value: request.httpConfig ? marshalHealthCheckHttpConfig(request.httpConfig) : undefined\n  }, {\n    param: 'https_config',\n    value: request.httpsConfig ? marshalHealthCheckHttpsConfig(request.httpsConfig) : undefined\n  }])\n});\nconst marshalPrivateNetworkDHCPConfig = (request, defaults) => ({});\nconst marshalPrivateNetworkIpamConfig = (request, defaults) => ({});\nconst marshalPrivateNetworkStaticConfig = (request, defaults) => ({\n  ip_address: request.ipAddress\n});\nconst marshalRouteMatch = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'sni',\n    value: request.sni\n  }, {\n    param: 'host_header',\n    value: request.hostHeader\n  }])\n});\nconst marshalSubscriberEmailConfig = (request, defaults) => ({\n  email: request.email\n});\nconst marshalSubscriberWebhookConfig = (request, defaults) => ({\n  uri: request.uri\n});\nconst marshalAddBackendServersRequest = (request, defaults) => ({\n  server_ip: request.serverIp\n});\nconst marshalAttachPrivateNetworkRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'static_config',\n    value: request.staticConfig ? marshalPrivateNetworkStaticConfig(request.staticConfig) : undefined\n  }, {\n    param: 'dhcp_config',\n    value: request.dhcpConfig ? marshalPrivateNetworkDHCPConfig(request.dhcpConfig) : undefined\n  }, {\n    param: 'ipam_config',\n    value: request.ipamConfig ? marshalPrivateNetworkIpamConfig(request.ipamConfig) : undefined\n  }])\n});\nconst marshalCreateAclRequest = (request, defaults) => ({\n  action: marshalAclAction(request.action),\n  description: request.description,\n  index: request.index,\n  match: request.match ? marshalAclMatch(request.match) : undefined,\n  name: request.name || randomName('acl')\n});\nconst marshalCreateBackendRequest = (request, defaults) => ({\n  failover_host: request.failoverHost,\n  forward_port: request.forwardPort,\n  forward_port_algorithm: request.forwardPortAlgorithm,\n  forward_protocol: request.forwardProtocol,\n  health_check: marshalHealthCheck(request.healthCheck),\n  ignore_ssl_server_verify: request.ignoreSslServerVerify,\n  max_connections: request.maxConnections,\n  max_retries: request.maxRetries,\n  name: request.name || randomName('lbb'),\n  on_marked_down_action: request.onMarkedDownAction ?? 'on_marked_down_action_none',\n  proxy_protocol: request.proxyProtocol ?? 'proxy_protocol_unknown',\n  redispatch_attempt_count: request.redispatchAttemptCount,\n  send_proxy_v2: request.sendProxyV2,\n  server_ip: request.serverIp,\n  ssl_bridging: request.sslBridging,\n  sticky_sessions: request.stickySessions,\n  sticky_sessions_cookie_name: request.stickySessionsCookieName,\n  timeout_connect: request.timeoutConnect,\n  timeout_queue: request.timeoutQueue,\n  timeout_server: request.timeoutServer,\n  timeout_tunnel: request.timeoutTunnel\n});\nconst marshalCreateCertificateRequest = (request, defaults) => ({\n  name: request.name || randomName('certificate'),\n  ...resolveOneOf([{\n    param: 'letsencrypt',\n    value: request.letsencrypt ? marshalCreateCertificateRequestLetsencryptConfig(request.letsencrypt) : undefined\n  }, {\n    param: 'custom_certificate',\n    value: request.customCertificate ? marshalCreateCertificateRequestCustomCertificate(request.customCertificate) : undefined\n  }], true)\n});\nconst marshalCreateFrontendRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  certificate_id: request.certificateId,\n  certificate_ids: request.certificateIds,\n  enable_http3: request.enableHttp3,\n  inbound_port: request.inboundPort,\n  name: request.name || randomName('lbf'),\n  timeout_client: request.timeoutClient\n});\nconst marshalCreateIpRequest = (request, defaults) => ({\n  reverse: request.reverse,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalCreateLbRequest = (request, defaults) => ({\n  description: request.description,\n  ip_id: request.ipId,\n  name: request.name || randomName('lb'),\n  ssl_compatibility_level: request.sslCompatibilityLevel ?? 'ssl_compatibility_level_unknown',\n  tags: request.tags,\n  type: request.type,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalCreateRouteRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  frontend_id: request.frontendId,\n  match: request.match ? marshalRouteMatch(request.match) : undefined\n});\nconst marshalCreateSubscriberRequest = (request, defaults) => ({\n  name: request.name,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }]),\n  ...resolveOneOf([{\n    param: 'email_config',\n    value: request.emailConfig ? marshalSubscriberEmailConfig(request.emailConfig) : undefined\n  }, {\n    param: 'webhook_config',\n    value: request.webhookConfig ? marshalSubscriberWebhookConfig(request.webhookConfig) : undefined\n  }])\n});\nconst marshalMigrateLbRequest = (request, defaults) => ({\n  type: request.type\n});\nconst marshalRemoveBackendServersRequest = (request, defaults) => ({\n  server_ip: request.serverIp\n});\nconst marshalSetBackendServersRequest = (request, defaults) => ({\n  server_ip: request.serverIp\n});\nconst marshalSubscribeToLbRequest = (request, defaults) => ({\n  subscriber_id: request.subscriberId\n});\nconst marshalUpdateAclRequest = (request, defaults) => ({\n  action: marshalAclAction(request.action),\n  description: request.description,\n  index: request.index,\n  match: request.match ? marshalAclMatch(request.match) : undefined,\n  name: request.name\n});\nconst marshalUpdateBackendRequest = (request, defaults) => ({\n  failover_host: request.failoverHost,\n  forward_port: request.forwardPort,\n  forward_port_algorithm: request.forwardPortAlgorithm,\n  forward_protocol: request.forwardProtocol,\n  ignore_ssl_server_verify: request.ignoreSslServerVerify,\n  max_connections: request.maxConnections,\n  max_retries: request.maxRetries,\n  name: request.name,\n  on_marked_down_action: request.onMarkedDownAction ?? 'on_marked_down_action_none',\n  proxy_protocol: request.proxyProtocol ?? 'proxy_protocol_unknown',\n  redispatch_attempt_count: request.redispatchAttemptCount,\n  send_proxy_v2: request.sendProxyV2,\n  ssl_bridging: request.sslBridging,\n  sticky_sessions: request.stickySessions,\n  sticky_sessions_cookie_name: request.stickySessionsCookieName,\n  timeout_connect: request.timeoutConnect,\n  timeout_queue: request.timeoutQueue,\n  timeout_server: request.timeoutServer,\n  timeout_tunnel: request.timeoutTunnel\n});\nconst marshalUpdateCertificateRequest = (request, defaults) => ({\n  name: request.name\n});\nconst marshalUpdateFrontendRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  certificate_id: request.certificateId,\n  certificate_ids: request.certificateIds,\n  enable_http3: request.enableHttp3,\n  inbound_port: request.inboundPort,\n  name: request.name,\n  timeout_client: request.timeoutClient\n});\nconst marshalUpdateHealthCheckRequest = (request, defaults) => ({\n  check_delay: request.checkDelay,\n  check_max_retries: request.checkMaxRetries,\n  check_send_proxy: request.checkSendProxy,\n  check_timeout: request.checkTimeout,\n  port: request.port,\n  transient_check_delay: request.transientCheckDelay,\n  ...resolveOneOf([{\n    param: 'tcp_config',\n    value: request.tcpConfig ? marshalHealthCheckTcpConfig(request.tcpConfig) : undefined\n  }, {\n    param: 'mysql_config',\n    value: request.mysqlConfig ? marshalHealthCheckMysqlConfig(request.mysqlConfig) : undefined\n  }, {\n    param: 'pgsql_config',\n    value: request.pgsqlConfig ? marshalHealthCheckPgsqlConfig(request.pgsqlConfig) : undefined\n  }, {\n    param: 'ldap_config',\n    value: request.ldapConfig ? marshalHealthCheckLdapConfig(request.ldapConfig) : undefined\n  }, {\n    param: 'redis_config',\n    value: request.redisConfig ? marshalHealthCheckRedisConfig(request.redisConfig) : undefined\n  }, {\n    param: 'http_config',\n    value: request.httpConfig ? marshalHealthCheckHttpConfig(request.httpConfig) : undefined\n  }, {\n    param: 'https_config',\n    value: request.httpsConfig ? marshalHealthCheckHttpsConfig(request.httpsConfig) : undefined\n  }])\n});\nconst marshalUpdateIpRequest = (request, defaults) => ({\n  reverse: request.reverse\n});\nconst marshalUpdateLbRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name,\n  ssl_compatibility_level: request.sslCompatibilityLevel ?? 'ssl_compatibility_level_unknown',\n  tags: request.tags\n});\nconst marshalUpdateRouteRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  match: request.match ? marshalRouteMatch(request.match) : undefined\n});\nconst marshalUpdateSubscriberRequest = (request, defaults) => ({\n  name: request.name,\n  ...resolveOneOf([{\n    param: 'email_config',\n    value: request.emailConfig ? marshalSubscriberEmailConfig(request.emailConfig) : undefined\n  }, {\n    param: 'webhook_config',\n    value: request.webhookConfig ? marshalSubscriberWebhookConfig(request.webhookConfig) : undefined\n  }])\n});\nconst marshalZonedApiAddBackendServersRequest = (request, defaults) => ({\n  server_ip: request.serverIp\n});\nconst marshalZonedApiAttachPrivateNetworkRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'static_config',\n    value: request.staticConfig ? marshalPrivateNetworkStaticConfig(request.staticConfig) : undefined\n  }, {\n    param: 'dhcp_config',\n    value: request.dhcpConfig ? marshalPrivateNetworkDHCPConfig(request.dhcpConfig) : undefined\n  }, {\n    param: 'ipam_config',\n    value: request.ipamConfig ? marshalPrivateNetworkIpamConfig(request.ipamConfig) : undefined\n  }])\n});\nconst marshalZonedApiCreateAclRequest = (request, defaults) => ({\n  action: marshalAclAction(request.action),\n  description: request.description,\n  index: request.index,\n  match: request.match ? marshalAclMatch(request.match) : undefined,\n  name: request.name || randomName('acl')\n});\nconst marshalZonedApiCreateBackendRequest = (request, defaults) => ({\n  failover_host: request.failoverHost,\n  forward_port: request.forwardPort,\n  forward_port_algorithm: request.forwardPortAlgorithm,\n  forward_protocol: request.forwardProtocol,\n  health_check: marshalHealthCheck(request.healthCheck),\n  ignore_ssl_server_verify: request.ignoreSslServerVerify,\n  max_connections: request.maxConnections,\n  max_retries: request.maxRetries,\n  name: request.name || randomName('lbb'),\n  on_marked_down_action: request.onMarkedDownAction ?? 'on_marked_down_action_none',\n  proxy_protocol: request.proxyProtocol ?? 'proxy_protocol_unknown',\n  redispatch_attempt_count: request.redispatchAttemptCount,\n  send_proxy_v2: request.sendProxyV2,\n  server_ip: request.serverIp,\n  ssl_bridging: request.sslBridging,\n  sticky_sessions: request.stickySessions,\n  sticky_sessions_cookie_name: request.stickySessionsCookieName,\n  timeout_connect: request.timeoutConnect,\n  timeout_queue: request.timeoutQueue,\n  timeout_server: request.timeoutServer,\n  timeout_tunnel: request.timeoutTunnel\n});\nconst marshalZonedApiCreateCertificateRequest = (request, defaults) => ({\n  name: request.name || randomName('certificate'),\n  ...resolveOneOf([{\n    param: 'letsencrypt',\n    value: request.letsencrypt ? marshalCreateCertificateRequestLetsencryptConfig(request.letsencrypt) : undefined\n  }, {\n    param: 'custom_certificate',\n    value: request.customCertificate ? marshalCreateCertificateRequestCustomCertificate(request.customCertificate) : undefined\n  }], true)\n});\nconst marshalZonedApiCreateFrontendRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  certificate_id: request.certificateId,\n  certificate_ids: request.certificateIds,\n  enable_http3: request.enableHttp3,\n  inbound_port: request.inboundPort,\n  name: request.name || randomName('lbf'),\n  timeout_client: request.timeoutClient\n});\nconst marshalZonedApiCreateIpRequest = (request, defaults) => ({\n  reverse: request.reverse,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalZonedApiCreateLbRequest = (request, defaults) => ({\n  description: request.description,\n  ip_id: request.ipId,\n  name: request.name || randomName('lb'),\n  ssl_compatibility_level: request.sslCompatibilityLevel ?? 'ssl_compatibility_level_unknown',\n  tags: request.tags,\n  type: request.type,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalZonedApiCreateRouteRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  frontend_id: request.frontendId,\n  match: request.match ? marshalRouteMatch(request.match) : undefined\n});\nconst marshalZonedApiCreateSubscriberRequest = (request, defaults) => ({\n  name: request.name,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }]),\n  ...resolveOneOf([{\n    param: 'email_config',\n    value: request.emailConfig ? marshalSubscriberEmailConfig(request.emailConfig) : undefined\n  }, {\n    param: 'webhook_config',\n    value: request.webhookConfig ? marshalSubscriberWebhookConfig(request.webhookConfig) : undefined\n  }])\n});\nconst marshalZonedApiMigrateLbRequest = (request, defaults) => ({\n  type: request.type\n});\nconst marshalZonedApiRemoveBackendServersRequest = (request, defaults) => ({\n  server_ip: request.serverIp\n});\nconst marshalZonedApiSetAclsRequest = (request, defaults) => ({\n  acls: request.acls.map(elt => marshalAclSpec(elt))\n});\nconst marshalZonedApiSetBackendServersRequest = (request, defaults) => ({\n  server_ip: request.serverIp\n});\nconst marshalZonedApiSubscribeToLbRequest = (request, defaults) => ({\n  subscriber_id: request.subscriberId\n});\nconst marshalZonedApiUpdateAclRequest = (request, defaults) => ({\n  action: marshalAclAction(request.action),\n  description: request.description,\n  index: request.index,\n  match: request.match ? marshalAclMatch(request.match) : undefined,\n  name: request.name\n});\nconst marshalZonedApiUpdateBackendRequest = (request, defaults) => ({\n  failover_host: request.failoverHost,\n  forward_port: request.forwardPort,\n  forward_port_algorithm: request.forwardPortAlgorithm,\n  forward_protocol: request.forwardProtocol,\n  ignore_ssl_server_verify: request.ignoreSslServerVerify,\n  max_connections: request.maxConnections,\n  max_retries: request.maxRetries,\n  name: request.name,\n  on_marked_down_action: request.onMarkedDownAction ?? 'on_marked_down_action_none',\n  proxy_protocol: request.proxyProtocol ?? 'proxy_protocol_unknown',\n  redispatch_attempt_count: request.redispatchAttemptCount,\n  send_proxy_v2: request.sendProxyV2,\n  ssl_bridging: request.sslBridging,\n  sticky_sessions: request.stickySessions,\n  sticky_sessions_cookie_name: request.stickySessionsCookieName,\n  timeout_connect: request.timeoutConnect,\n  timeout_queue: request.timeoutQueue,\n  timeout_server: request.timeoutServer,\n  timeout_tunnel: request.timeoutTunnel\n});\nconst marshalZonedApiUpdateCertificateRequest = (request, defaults) => ({\n  name: request.name\n});\nconst marshalZonedApiUpdateFrontendRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  certificate_id: request.certificateId,\n  certificate_ids: request.certificateIds,\n  enable_http3: request.enableHttp3,\n  inbound_port: request.inboundPort,\n  name: request.name,\n  timeout_client: request.timeoutClient\n});\nconst marshalZonedApiUpdateHealthCheckRequest = (request, defaults) => ({\n  check_delay: request.checkDelay,\n  check_max_retries: request.checkMaxRetries,\n  check_send_proxy: request.checkSendProxy,\n  check_timeout: request.checkTimeout,\n  port: request.port,\n  transient_check_delay: request.transientCheckDelay,\n  ...resolveOneOf([{\n    param: 'tcp_config',\n    value: request.tcpConfig ? marshalHealthCheckTcpConfig(request.tcpConfig) : undefined\n  }, {\n    param: 'mysql_config',\n    value: request.mysqlConfig ? marshalHealthCheckMysqlConfig(request.mysqlConfig) : undefined\n  }, {\n    param: 'pgsql_config',\n    value: request.pgsqlConfig ? marshalHealthCheckPgsqlConfig(request.pgsqlConfig) : undefined\n  }, {\n    param: 'ldap_config',\n    value: request.ldapConfig ? marshalHealthCheckLdapConfig(request.ldapConfig) : undefined\n  }, {\n    param: 'redis_config',\n    value: request.redisConfig ? marshalHealthCheckRedisConfig(request.redisConfig) : undefined\n  }, {\n    param: 'http_config',\n    value: request.httpConfig ? marshalHealthCheckHttpConfig(request.httpConfig) : undefined\n  }, {\n    param: 'https_config',\n    value: request.httpsConfig ? marshalHealthCheckHttpsConfig(request.httpsConfig) : undefined\n  }])\n});\nconst marshalZonedApiUpdateIpRequest = (request, defaults) => ({\n  reverse: request.reverse\n});\nconst marshalZonedApiUpdateLbRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name,\n  ssl_compatibility_level: request.sslCompatibilityLevel ?? 'ssl_compatibility_level_unknown',\n  tags: request.tags\n});\nconst marshalZonedApiUpdateRouteRequest = (request, defaults) => ({\n  backend_id: request.backendId,\n  match: request.match ? marshalRouteMatch(request.match) : undefined\n});\nconst marshalZonedApiUpdateSubscriberRequest = (request, defaults) => ({\n  name: request.name,\n  ...resolveOneOf([{\n    param: 'email_config',\n    value: request.emailConfig ? marshalSubscriberEmailConfig(request.emailConfig) : undefined\n  }, {\n    param: 'webhook_config',\n    value: request.webhookConfig ? marshalSubscriberWebhookConfig(request.webhookConfig) : undefined\n  }])\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$a = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Load balancer API.\n *\n * This API allows you to manage your load balancer service. Load balancer API.\n */\nlet API$c = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par', 'nl-ams', 'pl-waw'];\n  pageOfListLbs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListLbsResponse);\n\n  /**\n   * List load balancers.\n   *\n   * @param request - The request {@link ListLbsRequest}\n   * @returns A Promise of ListLbsResponse\n   */\n  listLbs = (request = {}) => enrichForPagination('lbs', this.pageOfListLbs, request);\n\n  /**\n   * Create a load balancer.\n   *\n   * @param request - The request {@link CreateLbRequest}\n   * @returns A Promise of Lb\n   */\n  createLb = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs`\n  }, unmarshalLb);\n\n  /**\n   * Get a load balancer.\n   *\n   * @param request - The request {@link GetLbRequest}\n   * @returns A Promise of Lb\n   */\n  getLb = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}`\n  }, unmarshalLb);\n\n  /**\n   * Waits for {@link Lb} to be in a final state.\n   *\n   * @param request - The request {@link GetLbRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Lb\n   */\n  waitForLb = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!LB_TRANSIENT_STATUSES.includes(res.status))), this.getLb, request, options);\n\n  /**\n   * Update a load balancer.\n   *\n   * @param request - The request {@link UpdateLbRequest}\n   * @returns A Promise of Lb\n   */\n  updateLb = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}`\n  }, unmarshalLb);\n\n  /**\n   * Delete a load balancer.\n   *\n   * @param request - The request {@link DeleteLbRequest}\n   */\n  deleteLb = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}`,\n    urlParams: urlParams(['release_ip', request.releaseIp])\n  });\n\n  /**\n   * Migrate a load balancer.\n   *\n   * @param request - The request {@link MigrateLbRequest}\n   * @returns A Promise of Lb\n   */\n  migrateLb = request => this.client.fetch({\n    body: JSON.stringify(marshalMigrateLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/migrate`\n  }, unmarshalLb);\n  pageOfListIPs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/ips`,\n    urlParams: urlParams(['ip_address', request.ipAddress], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListIpsResponse);\n\n  /**\n   * List IPs.\n   *\n   * @param request - The request {@link ListIPsRequest}\n   * @returns A Promise of ListIpsResponse\n   */\n  listIPs = (request = {}) => enrichForPagination('ips', this.pageOfListIPs, request);\n\n  /**\n   * Create an IP.\n   *\n   * @param request - The request {@link CreateIpRequest}\n   * @returns A Promise of Ip\n   */\n  createIp = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateIpRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/ips`\n  }, unmarshalIp);\n\n  /**\n   * Get an IP.\n   *\n   * @param request - The request {@link GetIpRequest}\n   * @returns A Promise of Ip\n   */\n  getIp = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/ips/${validatePathParam('ipId', request.ipId)}`\n  }, unmarshalIp);\n\n  /**\n   * Delete an IP.\n   *\n   * @param request - The request {@link ReleaseIpRequest}\n   */\n  releaseIp = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/ips/${validatePathParam('ipId', request.ipId)}`\n  });\n\n  /**\n   * Update an IP.\n   *\n   * @param request - The request {@link UpdateIpRequest}\n   * @returns A Promise of Ip\n   */\n  updateIp = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateIpRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PATCH',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/ips/${validatePathParam('ipId', request.ipId)}`\n  }, unmarshalIp);\n  pageOfListBackends = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/backends`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListBackendsResponse);\n\n  /**\n   * List backends in a given load balancer.\n   *\n   * @param request - The request {@link ListBackendsRequest}\n   * @returns A Promise of ListBackendsResponse\n   */\n  listBackends = request => enrichForPagination('backends', this.pageOfListBackends, request);\n\n  /**\n   * Create a backend in a given load balancer.\n   *\n   * @param request - The request {@link CreateBackendRequest}\n   * @returns A Promise of Backend\n   */\n  createBackend = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateBackendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/backends`\n  }, unmarshalBackend);\n\n  /**\n   * Get a backend in a given load balancer.\n   *\n   * @param request - The request {@link GetBackendRequest}\n   * @returns A Promise of Backend\n   */\n  getBackend = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backends/${validatePathParam('backendId', request.backendId)}`\n  }, unmarshalBackend);\n\n  /**\n   * Update a backend in a given load balancer.\n   *\n   * @param request - The request {@link UpdateBackendRequest}\n   * @returns A Promise of Backend\n   */\n  updateBackend = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateBackendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backends/${validatePathParam('backendId', request.backendId)}`\n  }, unmarshalBackend);\n\n  /**\n   * Delete a backend in a given load balancer.\n   *\n   * @param request - The request {@link DeleteBackendRequest}\n   */\n  deleteBackend = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backends/${validatePathParam('backendId', request.backendId)}`\n  });\n\n  /**\n   * Add a set of servers in a given backend.\n   *\n   * @param request - The request {@link AddBackendServersRequest}\n   * @returns A Promise of Backend\n   */\n  addBackendServers = request => this.client.fetch({\n    body: JSON.stringify(marshalAddBackendServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backends/${validatePathParam('backendId', request.backendId)}/servers`\n  }, unmarshalBackend);\n\n  /**\n   * Remove a set of servers for a given backend.\n   *\n   * @param request - The request {@link RemoveBackendServersRequest}\n   * @returns A Promise of Backend\n   */\n  removeBackendServers = request => this.client.fetch({\n    body: JSON.stringify(marshalRemoveBackendServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backends/${validatePathParam('backendId', request.backendId)}/servers`\n  }, unmarshalBackend);\n\n  /**\n   * Define all servers in a given backend.\n   *\n   * @param request - The request {@link SetBackendServersRequest}\n   * @returns A Promise of Backend\n   */\n  setBackendServers = request => this.client.fetch({\n    body: JSON.stringify(marshalSetBackendServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backends/${validatePathParam('backendId', request.backendId)}/servers`\n  }, unmarshalBackend);\n\n  /**\n   * Update an health check for a given backend.\n   *\n   * @param request - The request {@link UpdateHealthCheckRequest}\n   * @returns A Promise of HealthCheck\n   */\n  updateHealthCheck = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateHealthCheckRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backends/${validatePathParam('backendId', request.backendId)}/healthcheck`\n  }, unmarshalHealthCheck);\n  pageOfListFrontends = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/frontends`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListFrontendsResponse);\n\n  /**\n   * List frontends in a given load balancer.\n   *\n   * @param request - The request {@link ListFrontendsRequest}\n   * @returns A Promise of ListFrontendsResponse\n   */\n  listFrontends = request => enrichForPagination('frontends', this.pageOfListFrontends, request);\n\n  /**\n   * Create a frontend in a given load balancer.\n   *\n   * @param request - The request {@link CreateFrontendRequest}\n   * @returns A Promise of Frontend\n   */\n  createFrontend = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateFrontendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/frontends`\n  }, unmarshalFrontend);\n\n  /**\n   * Get a frontend.\n   *\n   * @param request - The request {@link GetFrontendRequest}\n   * @returns A Promise of Frontend\n   */\n  getFrontend = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/frontends/${validatePathParam('frontendId', request.frontendId)}`\n  }, unmarshalFrontend);\n\n  /**\n   * Update a frontend.\n   *\n   * @param request - The request {@link UpdateFrontendRequest}\n   * @returns A Promise of Frontend\n   */\n  updateFrontend = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateFrontendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/frontends/${validatePathParam('frontendId', request.frontendId)}`\n  }, unmarshalFrontend);\n\n  /**\n   * Delete a frontend.\n   *\n   * @param request - The request {@link DeleteFrontendRequest}\n   */\n  deleteFrontend = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/frontends/${validatePathParam('frontendId', request.frontendId)}`\n  });\n  pageOfListRoutes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes`,\n    urlParams: urlParams(['frontend_id', request.frontendId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListRoutesResponse);\n\n  /**\n   * List all backend redirections.\n   *\n   * @param request - The request {@link ListRoutesRequest}\n   * @returns A Promise of ListRoutesResponse\n   */\n  listRoutes = (request = {}) => enrichForPagination('routes', this.pageOfListRoutes, request);\n\n  /**\n   * Create a backend redirection.\n   *\n   * @param request - The request {@link CreateRouteRequest}\n   * @returns A Promise of Route\n   */\n  createRoute = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateRouteRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes`\n  }, unmarshalRoute);\n\n  /**\n   * Get single backend redirection.\n   *\n   * @param request - The request {@link GetRouteRequest}\n   * @returns A Promise of Route\n   */\n  getRoute = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes/${validatePathParam('routeId', request.routeId)}`\n  }, unmarshalRoute);\n\n  /**\n   * Edit a backend redirection.\n   *\n   * @param request - The request {@link UpdateRouteRequest}\n   * @returns A Promise of Route\n   */\n  updateRoute = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateRouteRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes/${validatePathParam('routeId', request.routeId)}`\n  }, unmarshalRoute);\n\n  /**\n   * Delete a backend redirection.\n   *\n   * @param request - The request {@link DeleteRouteRequest}\n   */\n  deleteRoute = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/routes/${validatePathParam('routeId', request.routeId)}`\n  });\n\n  /**\n   * Get usage statistics of a given load balancer.\n   *\n   * @deprecated\n   * @param request - The request {@link GetLbStatsRequest}\n   * @returns A Promise of LbStats\n   */\n  getLbStats = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/stats`\n  }, unmarshalLbStats);\n  pageOfListBackendStats = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/backend-stats`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListBackendStatsResponse);\n  listBackendStats = request => enrichForPagination('backendServersStats', this.pageOfListBackendStats, request);\n  pageOfListAcls = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/frontends/${validatePathParam('frontendId', request.frontendId)}/acls`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListAclResponse);\n\n  /**\n   * List ACL for a given frontend.\n   *\n   * @param request - The request {@link ListAclsRequest}\n   * @returns A Promise of ListAclResponse\n   */\n  listAcls = request => enrichForPagination('acls', this.pageOfListAcls, request);\n\n  /**\n   * Create an ACL for a given frontend.\n   *\n   * @param request - The request {@link CreateAclRequest}\n   * @returns A Promise of Acl\n   */\n  createAcl = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateAclRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/frontends/${validatePathParam('frontendId', request.frontendId)}/acls`\n  }, unmarshalAcl);\n\n  /**\n   * Get an ACL.\n   *\n   * @param request - The request {@link GetAclRequest}\n   * @returns A Promise of Acl\n   */\n  getAcl = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/acls/${validatePathParam('aclId', request.aclId)}`\n  }, unmarshalAcl);\n\n  /**\n   * Update an ACL.\n   *\n   * @param request - The request {@link UpdateAclRequest}\n   * @returns A Promise of Acl\n   */\n  updateAcl = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateAclRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/acls/${validatePathParam('aclId', request.aclId)}`\n  }, unmarshalAcl);\n\n  /**\n   * Delete an ACL.\n   *\n   * @param request - The request {@link DeleteAclRequest}\n   */\n  deleteAcl = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/acls/${validatePathParam('aclId', request.aclId)}`\n  });\n\n  /**\n   * Create a TLS certificate. Generate a new TLS certificate using Let's\n   * Encrypt or import your certificate.\n   *\n   * @param request - The request {@link CreateCertificateRequest}\n   * @returns A Promise of Certificate\n   */\n  createCertificate = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateCertificateRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/certificates`\n  }, unmarshalCertificate);\n  pageOfListCertificates = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/certificates`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListCertificatesResponse);\n\n  /**\n   * List all TLS certificates on a given load balancer.\n   *\n   * @param request - The request {@link ListCertificatesRequest}\n   * @returns A Promise of ListCertificatesResponse\n   */\n  listCertificates = request => enrichForPagination('certificates', this.pageOfListCertificates, request);\n\n  /**\n   * Get a TLS certificate.\n   *\n   * @param request - The request {@link GetCertificateRequest}\n   * @returns A Promise of Certificate\n   */\n  getCertificate = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/certificates/${validatePathParam('certificateId', request.certificateId)}`\n  }, unmarshalCertificate);\n\n  /**\n   * Waits for {@link Certificate} to be in a final state.\n   *\n   * @param request - The request {@link GetCertificateRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Certificate\n   */\n  waitForCertificate = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!CERTIFICATE_TRANSIENT_STATUSES.includes(res.status))), this.getCertificate, request, options);\n\n  /**\n   * Update a TLS certificate.\n   *\n   * @param request - The request {@link UpdateCertificateRequest}\n   * @returns A Promise of Certificate\n   */\n  updateCertificate = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateCertificateRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/certificates/${validatePathParam('certificateId', request.certificateId)}`\n  }, unmarshalCertificate);\n\n  /**\n   * Delete a TLS certificate.\n   *\n   * @param request - The request {@link DeleteCertificateRequest}\n   */\n  deleteCertificate = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/certificates/${validatePathParam('certificateId', request.certificateId)}`\n  });\n  pageOfListLbTypes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lb-types`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListLbTypesResponse);\n\n  /**\n   * List all load balancer offer type.\n   *\n   * @param request - The request {@link ListLbTypesRequest}\n   * @returns A Promise of ListLbTypesResponse\n   */\n  listLbTypes = (request = {}) => enrichForPagination('lbTypes', this.pageOfListLbTypes, request);\n\n  /**\n   * Create a subscriber, webhook or email.\n   *\n   * @param request - The request {@link CreateSubscriberRequest}\n   * @returns A Promise of Subscriber\n   */\n  createSubscriber = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSubscriberRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/subscribers`\n  }, unmarshalSubscriber);\n\n  /**\n   * Get a subscriber.\n   *\n   * @param request - The request {@link GetSubscriberRequest}\n   * @returns A Promise of Subscriber\n   */\n  getSubscriber = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/subscribers/${validatePathParam('subscriberId', request.subscriberId)}`\n  }, unmarshalSubscriber);\n  pageOfListSubscriber = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/subscribers`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListSubscriberResponse);\n\n  /**\n   * List all subscriber.\n   *\n   * @param request - The request {@link ListSubscriberRequest}\n   * @returns A Promise of ListSubscriberResponse\n   */\n  listSubscriber = request => enrichForPagination('subscribers', this.pageOfListSubscriber, request);\n\n  /**\n   * Update a subscriber.\n   *\n   * @param request - The request {@link UpdateSubscriberRequest}\n   * @returns A Promise of Subscriber\n   */\n  updateSubscriber = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateSubscriberRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/subscribers/${validatePathParam('subscriberId', request.subscriberId)}`\n  }, unmarshalSubscriber);\n\n  /**\n   * Delete a subscriber.\n   *\n   * @param request - The request {@link DeleteSubscriberRequest}\n   */\n  deleteSubscriber = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lb/subscriber/${validatePathParam('subscriberId', request.subscriberId)}`\n  });\n\n  /**\n   * Subscribe a subscriber to a given load balancer.\n   *\n   * @param request - The request {@link SubscribeToLbRequest}\n   * @returns A Promise of Lb\n   */\n  subscribeToLb = request => this.client.fetch({\n    body: JSON.stringify(marshalSubscribeToLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lb/${validatePathParam('lbId', request.lbId)}/subscribe`\n  }, unmarshalLb);\n\n  /**\n   * Unsubscribe a subscriber from a given load balancer.\n   *\n   * @param request - The request {@link UnsubscribeFromLbRequest}\n   * @returns A Promise of Lb\n   */\n  unsubscribeFromLb = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lb/${validatePathParam('lbId', request.lbId)}/unsubscribe`\n  }, unmarshalLb);\n  pageOfListLbPrivateNetworks = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/private-networks`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListLbPrivateNetworksResponse);\n\n  /**\n   * List attached private network of load balancer.\n   *\n   * @param request - The request {@link ListLbPrivateNetworksRequest}\n   * @returns A Promise of ListLbPrivateNetworksResponse\n   */\n  listLbPrivateNetworks = request => enrichForPagination('privateNetwork', this.pageOfListLbPrivateNetworks, request);\n\n  /**\n   * Add load balancer on instance private network.\n   *\n   * @param request - The request {@link AttachPrivateNetworkRequest}\n   * @returns A Promise of PrivateNetwork\n   */\n  attachPrivateNetwork = request => this.client.fetch({\n    body: JSON.stringify(marshalAttachPrivateNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}/attach`\n  }, unmarshalPrivateNetwork$2);\n\n  /**\n   * Remove load balancer of private network.\n   *\n   * @param request - The request {@link DetachPrivateNetworkRequest}\n   */\n  detachPrivateNetwork = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/lbs/${validatePathParam('lbId', request.lbId)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}/detach`\n  });\n};\n\n/**\n * Load Balancer API.\n *\n * This API allows you to manage your Scaleway Load Balancer services. Load\n * Balancer API.\n */\nclass ZonedAPI extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-1', 'fr-par-2', 'nl-ams-1', 'nl-ams-2', 'pl-waw-1', 'pl-waw-2'];\n  pageOfListLbs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListLbsResponse);\n\n  /**\n   * List Load Balancers. List all Load Balancers in the specified zone, for a\n   * Scaleway Organization or Scaleway Project. By default, the Load Balancers\n   * returned in the list are ordered by creation date in ascending order,\n   * though this can be modified via the `order_by` field.\n   *\n   * @param request - The request {@link ZonedApiListLbsRequest}\n   * @returns A Promise of ListLbsResponse\n   */\n  listLbs = (request = {}) => enrichForPagination('lbs', this.pageOfListLbs, request);\n\n  /**\n   * Create a Load Balancer. Create a new Load Balancer. Note that the Load\n   * Balancer will be created without frontends or backends; these must be\n   * created separately via the dedicated endpoints.\n   *\n   * @param request - The request {@link ZonedApiCreateLbRequest}\n   * @returns A Promise of Lb\n   */\n  createLb = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs`\n  }, unmarshalLb);\n\n  /**\n   * Get a Load Balancer. Retrieve information about an existing Load Balancer,\n   * specified by its Load Balancer ID. Its full details, including name, status\n   * and IP address, are returned in the response object.\n   *\n   * @param request - The request {@link ZonedApiGetLbRequest}\n   * @returns A Promise of Lb\n   */\n  getLb = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}`\n  }, unmarshalLb);\n\n  /**\n   * Waits for {@link Lb} to be in a final state.\n   *\n   * @param request - The request {@link GetLbRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Lb\n   */\n  waitForLb = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!LB_TRANSIENT_STATUSES.includes(res.status))), this.getLb, request, options);\n\n  /**\n   * Update a Load Balancer. Update the parameters of an existing Load Balancer,\n   * specified by its Load Balancer ID. Note that the request type is PUT and\n   * not PATCH. You must set all parameters.\n   *\n   * @param request - The request {@link ZonedApiUpdateLbRequest}\n   * @returns A Promise of Lb\n   */\n  updateLb = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}`\n  }, unmarshalLb);\n\n  /**\n   * Delete a Load Balancer. Delete an existing Load Balancer, specified by its\n   * Load Balancer ID. Deleting a Load Balancer is permanent, and cannot be\n   * undone. The Load Balancer's flexible IP address can either be deleted with\n   * the Load Balancer, or kept in your account for future use.\n   *\n   * @param request - The request {@link ZonedApiDeleteLbRequest}\n   */\n  deleteLb = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}`,\n    urlParams: urlParams(['release_ip', request.releaseIp])\n  });\n\n  /**\n   * Migrate a Load Balancer. Migrate an existing Load Balancer from one\n   * commercial type to another. Allows you to scale your Load Balancer up or\n   * down in terms of bandwidth or multi-cloud provision.\n   *\n   * @param request - The request {@link ZonedApiMigrateLbRequest}\n   * @returns A Promise of Lb\n   */\n  migrateLb = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiMigrateLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/migrate`\n  }, unmarshalLb);\n  pageOfListIPs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips`,\n    urlParams: urlParams(['ip_address', request.ipAddress], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListIpsResponse);\n\n  /**\n   * List IP addresses. List the Load Balancer flexible IP addresses held in the\n   * account (filtered by Organization ID or Project ID). It is also possible to\n   * search for a specific IP address.\n   *\n   * @param request - The request {@link ZonedApiListIPsRequest}\n   * @returns A Promise of ListIpsResponse\n   */\n  listIPs = (request = {}) => enrichForPagination('ips', this.pageOfListIPs, request);\n\n  /**\n   * Create an IP address. Create a new Load Balancer flexible IP address, in\n   * the specified Scaleway Project. This can be attached to new Load Balancers\n   * created in the future.\n   *\n   * @param request - The request {@link ZonedApiCreateIpRequest}\n   * @returns A Promise of Ip\n   */\n  createIp = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateIpRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips`\n  }, unmarshalIp);\n\n  /**\n   * Get an IP address. Retrieve the full details of a Load Balancer flexible IP\n   * address.\n   *\n   * @param request - The request {@link ZonedApiGetIpRequest}\n   * @returns A Promise of Ip\n   */\n  getIp = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ipId', request.ipId)}`\n  }, unmarshalIp);\n\n  /**\n   * Delete an IP address. Delete a Load Balancer flexible IP address. This\n   * action is irreversible, and cannot be undone.\n   *\n   * @param request - The request {@link ZonedApiReleaseIpRequest}\n   */\n  releaseIp = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ipId', request.ipId)}`\n  });\n\n  /**\n   * Update an IP address. Update the reverse DNS of a Load Balancer flexible IP\n   * address.\n   *\n   * @param request - The request {@link ZonedApiUpdateIpRequest}\n   * @returns A Promise of Ip\n   */\n  updateIp = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateIpRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PATCH',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ipId', request.ipId)}`\n  }, unmarshalIp);\n  pageOfListBackends = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/backends`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListBackendsResponse);\n\n  /**\n   * List the backends of a given Load Balancer. List all the backends of a Load\n   * Balancer, specified by its Load Balancer ID. By default, results are\n   * returned in ascending order by the creation date of each backend. The\n   * response is an array of backend objects, containing full details of each\n   * one including their configuration parameters such as protocol, port and\n   * forwarding algorithm.\n   *\n   * @param request - The request {@link ZonedApiListBackendsRequest}\n   * @returns A Promise of ListBackendsResponse\n   */\n  listBackends = request => enrichForPagination('backends', this.pageOfListBackends, request);\n\n  /**\n   * Create a backend for a given Load Balancer. Create a new backend for a\n   * given Load Balancer, specifying its full configuration including protocol,\n   * port and forwarding algorithm.\n   *\n   * @param request - The request {@link ZonedApiCreateBackendRequest}\n   * @returns A Promise of Backend\n   */\n  createBackend = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateBackendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/backends`\n  }, unmarshalBackend);\n\n  /**\n   * Get a backend of a given Load Balancer. Get the full details of a given\n   * backend, specified by its backend ID. The response contains the backend's\n   * full configuration parameters including protocol, port and forwarding\n   * algorithm.\n   *\n   * @param request - The request {@link ZonedApiGetBackendRequest}\n   * @returns A Promise of Backend\n   */\n  getBackend = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/backends/${validatePathParam('backendId', request.backendId)}`\n  }, unmarshalBackend);\n\n  /**\n   * Update a backend of a given Load Balancer. Update a backend of a given Load\n   * Balancer, specified by its backend ID. Note that the request type is PUT\n   * and not PATCH. You must set all parameters.\n   *\n   * @param request - The request {@link ZonedApiUpdateBackendRequest}\n   * @returns A Promise of Backend\n   */\n  updateBackend = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateBackendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/backends/${validatePathParam('backendId', request.backendId)}`\n  }, unmarshalBackend);\n\n  /**\n   * Delete a backend of a given Load Balancer. Delete a backend of a given Load\n   * Balancer, specified by its backend ID. This action is irreversible and\n   * cannot be undone.\n   *\n   * @param request - The request {@link ZonedApiDeleteBackendRequest}\n   */\n  deleteBackend = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/backends/${validatePathParam('backendId', request.backendId)}`\n  });\n\n  /**\n   * Add a set of backend servers to a given backend. For a given backend\n   * specified by its backend ID, add a set of backend servers (identified by\n   * their IP addresses) it should forward traffic to. These will be appended to\n   * any existing set of backend servers for this backend.\n   *\n   * @param request - The request {@link ZonedApiAddBackendServersRequest}\n   * @returns A Promise of Backend\n   */\n  addBackendServers = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiAddBackendServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/backends/${validatePathParam('backendId', request.backendId)}/servers`\n  }, unmarshalBackend);\n\n  /**\n   * Remove a set of servers for a given backend. For a given backend specified\n   * by its backend ID, remove the specified backend servers (identified by\n   * their IP addresses) so that it no longer forwards traffic to them.\n   *\n   * @param request - The request {@link ZonedApiRemoveBackendServersRequest}\n   * @returns A Promise of Backend\n   */\n  removeBackendServers = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiRemoveBackendServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/backends/${validatePathParam('backendId', request.backendId)}/servers`\n  }, unmarshalBackend);\n\n  /**\n   * Define all backend servers for a given backend. For a given backend\n   * specified by its backend ID, define the set of backend servers (identified\n   * by their IP addresses) that it should forward traffic to. Any existing\n   * backend servers configured for this backend will be removed.\n   *\n   * @param request - The request {@link ZonedApiSetBackendServersRequest}\n   * @returns A Promise of Backend\n   */\n  setBackendServers = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiSetBackendServersRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/backends/${validatePathParam('backendId', request.backendId)}/servers`\n  }, unmarshalBackend);\n\n  /**\n   * Update a health check for a given backend. Update the configuration of the\n   * health check performed by a given backend to verify the health of its\n   * backend servers, identified by its backend ID. Note that the request type\n   * is PUT and not PATCH. You must set all parameters.\n   *\n   * @param request - The request {@link ZonedApiUpdateHealthCheckRequest}\n   * @returns A Promise of HealthCheck\n   */\n  updateHealthCheck = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateHealthCheckRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/backends/${validatePathParam('backendId', request.backendId)}/healthcheck`\n  }, unmarshalHealthCheck);\n  pageOfListFrontends = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/frontends`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListFrontendsResponse);\n\n  /**\n   * List frontends of a given Load Balancer. List all the frontends of a Load\n   * Balancer, specified by its Load Balancer ID. By default, results are\n   * returned in ascending order by the creation date of each frontend. The\n   * response is an array of frontend objects, containing full details of each\n   * one including the port they listen on and the backend they are attached\n   * to.\n   *\n   * @param request - The request {@link ZonedApiListFrontendsRequest}\n   * @returns A Promise of ListFrontendsResponse\n   */\n  listFrontends = request => enrichForPagination('frontends', this.pageOfListFrontends, request);\n\n  /**\n   * Create a frontend in a given Load Balancer. Create a new frontend for a\n   * given Load Balancer, specifying its configuration including the port it\n   * should listen on and the backend to attach it to.\n   *\n   * @param request - The request {@link ZonedApiCreateFrontendRequest}\n   * @returns A Promise of Frontend\n   */\n  createFrontend = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateFrontendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/frontends`\n  }, unmarshalFrontend);\n\n  /**\n   * Get a frontend. Get the full details of a given frontend, specified by its\n   * frontend ID. The response contains the frontend's full configuration\n   * parameters including the backend it is attached to, the port it listens on,\n   * and any certificates it has.\n   *\n   * @param request - The request {@link ZonedApiGetFrontendRequest}\n   * @returns A Promise of Frontend\n   */\n  getFrontend = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/frontends/${validatePathParam('frontendId', request.frontendId)}`\n  }, unmarshalFrontend);\n\n  /**\n   * Update a frontend. Update a given frontend, specified by its frontend ID.\n   * You can update configuration parameters including its name and the port it\n   * listens on. Note that the request type is PUT and not PATCH. You must set\n   * all parameters.\n   *\n   * @param request - The request {@link ZonedApiUpdateFrontendRequest}\n   * @returns A Promise of Frontend\n   */\n  updateFrontend = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateFrontendRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/frontends/${validatePathParam('frontendId', request.frontendId)}`\n  }, unmarshalFrontend);\n\n  /**\n   * Delete a frontend. Delete a given frontend, specified by its frontend ID.\n   * This action is irreversible and cannot be undone.\n   *\n   * @param request - The request {@link ZonedApiDeleteFrontendRequest}\n   */\n  deleteFrontend = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/frontends/${validatePathParam('frontendId', request.frontendId)}`\n  });\n  pageOfListRoutes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/routes`,\n    urlParams: urlParams(['frontend_id', request.frontendId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListRoutesResponse);\n\n  /**\n   * List all routes. List all routes for a given frontend. The response is an\n   * array of routes, each one with a specified backend to direct to if a\n   * certain condition is matched (based on the value of the SNI field or HTTP\n   * Host header).\n   *\n   * @param request - The request {@link ZonedApiListRoutesRequest}\n   * @returns A Promise of ListRoutesResponse\n   */\n  listRoutes = (request = {}) => enrichForPagination('routes', this.pageOfListRoutes, request);\n\n  /**\n   * Create a route. Create a new route on a given frontend. To configure a\n   * route, specify the backend to direct to if a certain condition is matched\n   * (based on the value of the SNI field or HTTP Host header).\n   *\n   * @param request - The request {@link ZonedApiCreateRouteRequest}\n   * @returns A Promise of Route\n   */\n  createRoute = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateRouteRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/routes`\n  }, unmarshalRoute);\n\n  /**\n   * Get a route. Retrieve information about an existing route, specified by its\n   * route ID. Its full details, origin frontend, target backend and match\n   * condition, are returned in the response object.\n   *\n   * @param request - The request {@link ZonedApiGetRouteRequest}\n   * @returns A Promise of Route\n   */\n  getRoute = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/routes/${validatePathParam('routeId', request.routeId)}`\n  }, unmarshalRoute);\n\n  /**\n   * Update a route. Update the configuration of an existing route, specified by\n   * its route ID.\n   *\n   * @param request - The request {@link ZonedApiUpdateRouteRequest}\n   * @returns A Promise of Route\n   */\n  updateRoute = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateRouteRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/routes/${validatePathParam('routeId', request.routeId)}`\n  }, unmarshalRoute);\n\n  /**\n   * Delete a route. Delete an existing route, specified by its route ID.\n   * Deleting a route is permanent, and cannot be undone.\n   *\n   * @param request - The request {@link ZonedApiDeleteRouteRequest}\n   */\n  deleteRoute = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/routes/${validatePathParam('routeId', request.routeId)}`\n  });\n\n  /**\n   * Get usage statistics of a given Load Balancer.\n   *\n   * @deprecated\n   * @param request - The request {@link ZonedApiGetLbStatsRequest}\n   * @returns A Promise of LbStats\n   */\n  getLbStats = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/stats`\n  }, unmarshalLbStats);\n  pageOfListBackendStats = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/backend-stats`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListBackendStatsResponse);\n\n  /**\n   * List backend server statistics. List information about your backend\n   * servers, including their state and the result of their last health check.\n   *\n   * @param request - The request {@link ZonedApiListBackendStatsRequest}\n   * @returns A Promise of ListBackendStatsResponse\n   */\n  listBackendStats = request => enrichForPagination('backendServersStats', this.pageOfListBackendStats, request);\n  pageOfListAcls = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/frontends/${validatePathParam('frontendId', request.frontendId)}/acls`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListAclResponse);\n\n  /**\n   * List ACLs for a given frontend. List the ACLs for a given frontend,\n   * specified by its frontend ID. The response is an array of ACL objects, each\n   * one representing an ACL that denies or allows traffic based on certain\n   * conditions.\n   *\n   * @param request - The request {@link ZonedApiListAclsRequest}\n   * @returns A Promise of ListAclResponse\n   */\n  listAcls = request => enrichForPagination('acls', this.pageOfListAcls, request);\n\n  /**\n   * Create an ACL for a given frontend. Create a new ACL for a given frontend.\n   * Each ACL must have a name, an action to perform (allow or deny), and a\n   * match rule (the action is carried out when the incoming traffic matches the\n   * rule).\n   *\n   * @param request - The request {@link ZonedApiCreateAclRequest}\n   * @returns A Promise of Acl\n   */\n  createAcl = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateAclRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/frontends/${validatePathParam('frontendId', request.frontendId)}/acls`\n  }, unmarshalAcl);\n\n  /**\n   * Get an ACL. Get information for a particular ACL, specified by its ACL ID.\n   * The response returns full details of the ACL, including its name, action,\n   * match rule and frontend.\n   *\n   * @param request - The request {@link ZonedApiGetAclRequest}\n   * @returns A Promise of Acl\n   */\n  getAcl = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/acls/${validatePathParam('aclId', request.aclId)}`\n  }, unmarshalAcl);\n\n  /**\n   * Update an ACL. Update a particular ACL, specified by its ACL ID. You can\n   * update details including its name, action and match rule.\n   *\n   * @param request - The request {@link ZonedApiUpdateAclRequest}\n   * @returns A Promise of Acl\n   */\n  updateAcl = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateAclRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/acls/${validatePathParam('aclId', request.aclId)}`\n  }, unmarshalAcl);\n\n  /**\n   * Delete an ACL. Delete an ACL, specified by its ACL ID. Deleting an ACL is\n   * irreversible and cannot be undone.\n   *\n   * @param request - The request {@link ZonedApiDeleteAclRequest}\n   */\n  deleteAcl = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/acls/${validatePathParam('aclId', request.aclId)}`\n  });\n\n  /**\n   * Define all ACLs for a given frontend. For a given frontend specified by its\n   * frontend ID, define and add the complete set of ACLS for that frontend. Any\n   * existing ACLs on this frontend will be removed.\n   *\n   * @param request - The request {@link ZonedApiSetAclsRequest}\n   * @returns A Promise of SetAclsResponse\n   */\n  setAcls = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiSetAclsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/frontends/${validatePathParam('frontendId', request.frontendId)}/acls`\n  }, unmarshalSetAclsResponse);\n\n  /**\n   * Create an SSL/TLS certificate. Generate a new SSL/TLS certificate for a\n   * given Load Balancer. You can choose to create a Let's Encrypt certificate,\n   * or import a custom certificate.\n   *\n   * @param request - The request {@link ZonedApiCreateCertificateRequest}\n   * @returns A Promise of Certificate\n   */\n  createCertificate = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateCertificateRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/certificates`\n  }, unmarshalCertificate);\n  pageOfListCertificates = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/certificates`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListCertificatesResponse);\n\n  /**\n   * List all SSL/TLS certificates on a given Load Balancer. List all the\n   * SSL/TLS certificates on a given Load Balancer. The response is an array of\n   * certificate objects, which are by default listed in ascending order of\n   * creation date.\n   *\n   * @param request - The request {@link ZonedApiListCertificatesRequest}\n   * @returns A Promise of ListCertificatesResponse\n   */\n  listCertificates = request => enrichForPagination('certificates', this.pageOfListCertificates, request);\n\n  /**\n   * Get an SSL/TLS certificate. Get information for a particular SSL/TLS\n   * certificate, specified by its certificate ID. The response returns full\n   * details of the certificate, including its type, main domain name, and\n   * alternative domain names.\n   *\n   * @param request - The request {@link ZonedApiGetCertificateRequest}\n   * @returns A Promise of Certificate\n   */\n  getCertificate = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/certificates/${validatePathParam('certificateId', request.certificateId)}`\n  }, unmarshalCertificate);\n\n  /**\n   * Waits for {@link Certificate} to be in a final state.\n   *\n   * @param request - The request {@link GetCertificateRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Certificate\n   */\n  waitForCertificate = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!CERTIFICATE_TRANSIENT_STATUSES.includes(res.status))), this.getCertificate, request, options);\n\n  /**\n   * Update an SSL/TLS certificate. Update the name of a particular SSL/TLS\n   * certificate, specified by its certificate ID.\n   *\n   * @param request - The request {@link ZonedApiUpdateCertificateRequest}\n   * @returns A Promise of Certificate\n   */\n  updateCertificate = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateCertificateRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/certificates/${validatePathParam('certificateId', request.certificateId)}`\n  }, unmarshalCertificate);\n\n  /**\n   * Delete an SSL/TLS certificate. Delete an SSL/TLS certificate, specified by\n   * its certificate ID. Deleting a certificate is irreversible and cannot be\n   * undone.\n   *\n   * @param request - The request {@link ZonedApiDeleteCertificateRequest}\n   */\n  deleteCertificate = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/certificates/${validatePathParam('certificateId', request.certificateId)}`\n  });\n  pageOfListLbTypes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lb-types`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListLbTypesResponse);\n\n  /**\n   * List all Load Balancer offer types. List all the different commercial Load\n   * Balancer types. The response includes an array of offer types, each with a\n   * name, description, and information about its stock availability.\n   *\n   * @param request - The request {@link ZonedApiListLbTypesRequest}\n   * @returns A Promise of ListLbTypesResponse\n   */\n  listLbTypes = (request = {}) => enrichForPagination('lbTypes', this.pageOfListLbTypes, request);\n\n  /**\n   * Create a subscriber. Create a new subscriber, either with an email\n   * configuration or a webhook configuration, for a specified Scaleway\n   * Project.\n   *\n   * @param request - The request {@link ZonedApiCreateSubscriberRequest}\n   * @returns A Promise of Subscriber\n   */\n  createSubscriber = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiCreateSubscriberRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/subscribers`\n  }, unmarshalSubscriber);\n\n  /**\n   * Get a subscriber. Retrieve information about an existing subscriber,\n   * specified by its subscriber ID. Its full details, including name and\n   * email/webhook configuration, are returned in the response object.\n   *\n   * @param request - The request {@link ZonedApiGetSubscriberRequest}\n   * @returns A Promise of Subscriber\n   */\n  getSubscriber = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/subscribers/${validatePathParam('subscriberId', request.subscriberId)}`\n  }, unmarshalSubscriber);\n  pageOfListSubscriber = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/subscribers`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListSubscriberResponse);\n\n  /**\n   * List all subscribers. List all subscribers to Load Balancer alerts. By\n   * default, returns all subscribers to Load Balancer alerts for the\n   * Organization associated with the authentication token used for the\n   * request.\n   *\n   * @param request - The request {@link ZonedApiListSubscriberRequest}\n   * @returns A Promise of ListSubscriberResponse\n   */\n  listSubscriber = request => enrichForPagination('subscribers', this.pageOfListSubscriber, request);\n\n  /**\n   * Update a subscriber. Update the parameters of a given subscriber (e.g.\n   * name, webhook configuration, email configuration), specified by its\n   * subscriber ID.\n   *\n   * @param request - The request {@link ZonedApiUpdateSubscriberRequest}\n   * @returns A Promise of Subscriber\n   */\n  updateSubscriber = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiUpdateSubscriberRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'PUT',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/subscribers/${validatePathParam('subscriberId', request.subscriberId)}`\n  }, unmarshalSubscriber);\n\n  /**\n   * Delete a subscriber. Delete an existing subscriber, specified by its\n   * subscriber ID. Deleting a subscriber is permanent, and cannot be undone.\n   *\n   * @param request - The request {@link ZonedApiDeleteSubscriberRequest}\n   */\n  deleteSubscriber = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lb/subscription/${validatePathParam('subscriberId', request.subscriberId)}`\n  });\n\n  /**\n   * Subscribe a subscriber to alerts for a given Load Balancer. Subscribe an\n   * existing subscriber to alerts for a given Load Balancer.\n   *\n   * @param request - The request {@link ZonedApiSubscribeToLbRequest}\n   * @returns A Promise of Lb\n   */\n  subscribeToLb = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiSubscribeToLbRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lb/${validatePathParam('lbId', request.lbId)}/subscribe`\n  }, unmarshalLb);\n\n  /**\n   * Unsubscribe a subscriber from alerts for a given Load Balancer. Unsubscribe\n   * a subscriber from alerts for a given Load Balancer. The subscriber is not\n   * deleted, and can be resubscribed in the future if necessary.\n   *\n   * @param request - The request {@link ZonedApiUnsubscribeFromLbRequest}\n   * @returns A Promise of Lb\n   */\n  unsubscribeFromLb = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lb/${validatePathParam('lbId', request.lbId)}/unsubscribe`\n  }, unmarshalLb);\n  pageOfListLbPrivateNetworks = request => this.client.fetch({\n    method: 'GET',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/private-networks`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListLbPrivateNetworksResponse);\n\n  /**\n   * List Private Networks attached to a Load Balancer. List the Private\n   * Networks attached to a given Load Balancer, specified by its Load Balancer\n   * ID. The response is an array of Private Network objects, giving information\n   * including the status, configuration, name and creation date of each Private\n   * Network.\n   *\n   * @param request - The request {@link ZonedApiListLbPrivateNetworksRequest}\n   * @returns A Promise of ListLbPrivateNetworksResponse\n   */\n  listLbPrivateNetworks = request => enrichForPagination('privateNetwork', this.pageOfListLbPrivateNetworks, request);\n\n  /**\n   * Attach a Load Balancer to a Private Network. Attach a specified Load\n   * Balancer to a specified Private Network, defining a static or DHCP\n   * configuration for the Load Balancer on the network.\n   *\n   * @param request - The request {@link ZonedApiAttachPrivateNetworkRequest}\n   * @returns A Promise of PrivateNetwork\n   */\n  attachPrivateNetwork = request => this.client.fetch({\n    body: JSON.stringify(marshalZonedApiAttachPrivateNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}/attach`\n  }, unmarshalPrivateNetwork$2);\n\n  /**\n   * Detach Load Balancer from Private Network. Detach a specified Load Balancer\n   * from a specified Private Network.\n   *\n   * @param request - The request {@link ZonedApiDetachPrivateNetworkRequest}\n   */\n  detachPrivateNetwork = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$a,\n    method: 'POST',\n    path: `/lb/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/lbs/${validatePathParam('lbId', request.lbId)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}/detach`\n  });\n}\n\nclass LbV1UtilsAPI extends API$c {\n  /**\n   * Waits for all private networks of a load balancer to be in a final state.\n   *\n   * @param request - The request {@link WaitForLbPrivateNetworksRequest}\n   * @param options - The waiting options\n   * @returns A Promise of ListLbPrivateNetworksResponse\n   */\n  waitForLbPrivateNetworks = (request, options) => tryAtIntervals(async () => {\n    const value = await this.listLbPrivateNetworks({\n      lbId: request.lbId,\n      region: request.region\n    }).all().then(list => ({\n      privateNetwork: list,\n      totalCount: list.length\n    }));\n    return {\n      done: value.privateNetwork.find(elt => PRIVATE_NETWORK_TRANSIENT_STATUSES.includes(elt.status)) === undefined,\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n\n  /**\n   * Waits for all instances of a load balancer to be in a final state.\n   *\n   * @param request - The request {@link GetLbRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Lb\n   */\n  waitForLbInstances = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getLb(request);\n    return {\n      done: !LB_TRANSIENT_STATUSES.includes(value.status) && value.instances.find(elt => INSTANCE_TRANSIENT_STATUSES$1.includes(elt.status)) === undefined,\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n}\nclass LbZonedV1UtilsAPI extends ZonedAPI {\n  /**\n   * Waits for all private networks of a (zoned) load balancer to be in a final\n   * state.\n   *\n   * @param request - The request {@link ZonedWaitForLbPrivateNetworksRequest}\n   * @param options - The waiting options\n   * @returns A Promise of ListLbPrivateNetworksResponse\n   */\n  waitForLbPrivateNetworks = (request, options) => tryAtIntervals(async () => {\n    const value = await this.listLbPrivateNetworks({\n      lbId: request.lbId,\n      zone: request.zone\n    }).all().then(list => ({\n      privateNetwork: list,\n      totalCount: list.length\n    }));\n    return {\n      done: value.privateNetwork.find(elt => PRIVATE_NETWORK_TRANSIENT_STATUSES.includes(elt.status)) === undefined,\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n\n  /**\n   * Waits for all instances of a (zoned) load balancer to be in a final state.\n   *\n   * @param request - The request {@link GetLbRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Lb\n   */\n  waitForLbInstances = (request, options) => tryAtIntervals(async () => {\n    const value = await this.getLb(request);\n    return {\n      done: !LB_TRANSIENT_STATUSES.includes(value.status) && value.instances.find(elt => INSTANCE_TRANSIENT_STATUSES$1.includes(elt.status)) === undefined,\n      value\n    };\n  }, createExponentialBackoffStrategy(options?.minDelay ?? 1, options?.maxDelay ?? 30), options?.timeout);\n}\n\nvar index$c = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: LbV1UtilsAPI,\n  CERTIFICATE_TRANSIENT_STATUSES: CERTIFICATE_TRANSIENT_STATUSES,\n  INSTANCE_TRANSIENT_STATUSES: INSTANCE_TRANSIENT_STATUSES$1,\n  LB_TRANSIENT_STATUSES: LB_TRANSIENT_STATUSES,\n  PRIVATE_NETWORK_TRANSIENT_STATUSES: PRIVATE_NETWORK_TRANSIENT_STATUSES,\n  ZonedAPI: LbZonedV1UtilsAPI\n});\n\nvar index$b = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index$c\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalLocalImage$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'LocalImage' failed as data isn't a dictionary.`);\n  }\n  return {\n    arch: data.arch,\n    compatibleCommercialTypes: data.compatible_commercial_types,\n    id: data.id,\n    zone: data.zone\n  };\n};\nconst unmarshalOrganization = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Organization' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name\n  };\n};\nconst unmarshalVersion$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Version' failed as data isn't a dictionary.`);\n  }\n  return {\n    creationDate: unmarshalDate(data.creation_date),\n    id: data.id,\n    localImages: unmarshalArrayOfObject(data.local_images, unmarshalLocalImage$1),\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name\n  };\n};\nconst unmarshalImage$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Image' failed as data isn't a dictionary.`);\n  }\n  return {\n    categories: data.categories,\n    creationDate: unmarshalDate(data.creation_date),\n    currentPublicVersion: data.current_public_version,\n    description: data.description,\n    id: data.id,\n    label: data.label,\n    logo: data.logo,\n    modificationDate: unmarshalDate(data.modification_date),\n    name: data.name,\n    organization: data.organization ? unmarshalOrganization(data.organization) : undefined,\n    validUntil: unmarshalDate(data.valid_until),\n    versions: unmarshalArrayOfObject(data.versions, unmarshalVersion$1)\n  };\n};\nconst unmarshalGetImageResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetImageResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    image: data.image ? unmarshalImage$2(data.image) : undefined\n  };\n};\nconst unmarshalGetVersionResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GetVersionResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    version: data.version ? unmarshalVersion$1(data.version) : undefined\n  };\n};\nconst unmarshalListImagesResponse$2 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    images: unmarshalArrayOfObject(data.images, unmarshalImage$2),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListVersionsResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    versions: unmarshalArrayOfObject(data.versions, unmarshalVersion$1)\n  };\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n/** Marketplace API. */\nlet API$b = class API extends API$q {\n  pageOfListImages = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v1/images`,\n    urlParams: urlParams(['page', request.page], ['per_page', request.perPage ?? this.client.settings.defaultPageSize])\n  }, unmarshalListImagesResponse$2);\n\n  /**\n   * List marketplace images.\n   *\n   * @param request - The request {@link ListImagesRequest}\n   * @returns A Promise of ListImagesResponse\n   */\n  listImages = (request = {}) => enrichForPagination('images', this.pageOfListImages, request);\n\n  /**\n   * Get a specific marketplace image.\n   *\n   * @param request - The request {@link GetImageRequest}\n   * @returns A Promise of GetImageResponse\n   */\n  getImage = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v1/images/${validatePathParam('imageId', request.imageId)}`\n  }, unmarshalGetImageResponse);\n  listVersions = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v1/images/${validatePathParam('imageId', request.imageId)}/versions`\n  }, unmarshalListVersionsResponse$1);\n  getVersion = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v1/images/${validatePathParam('imageId', request.imageId)}/versions/${validatePathParam('versionId', request.versionId)}`\n  }, unmarshalGetVersionResponse);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$b = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$b\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalCategory = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Category' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    id: data.id,\n    name: data.name\n  };\n};\nconst unmarshalImage$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Image' failed as data isn't a dictionary.`);\n  }\n  return {\n    categories: data.categories,\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    id: data.id,\n    label: data.label,\n    logo: data.logo,\n    name: data.name,\n    updatedAt: unmarshalDate(data.updated_at),\n    validUntil: unmarshalDate(data.valid_until)\n  };\n};\nconst unmarshalLocalImage = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'LocalImage' failed as data isn't a dictionary.`);\n  }\n  return {\n    arch: data.arch,\n    compatibleCommercialTypes: data.compatible_commercial_types,\n    id: data.id,\n    label: data.label,\n    zone: data.zone\n  };\n};\nconst unmarshalVersion = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Version' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    name: data.name,\n    publishedAt: unmarshalDate(data.published_at),\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalListCategoriesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListCategoriesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    categories: unmarshalArrayOfObject(data.categories, unmarshalCategory),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListImagesResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    images: unmarshalArrayOfObject(data.images, unmarshalImage$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListLocalImagesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListLocalImagesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    localImages: unmarshalArrayOfObject(data.local_images, unmarshalLocalImage),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListVersionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    versions: unmarshalArrayOfObject(data.versions, unmarshalVersion)\n  };\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n/** Marketplace API. */\nlet API$a = class API extends API$q {\n  pageOfListImages = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/images`,\n    urlParams: urlParams(['arch', request.arch], ['category', request.category], ['include_eol', request.includeEol], ['order_by', request.orderBy ?? 'name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListImagesResponse$1);\n\n  /**\n   * List marketplace images. List all available images on the marketplace,\n   * their UUID, CPU architecture and description.\n   *\n   * @param request - The request {@link ListImagesRequest}\n   * @returns A Promise of ListImagesResponse\n   */\n  listImages = request => enrichForPagination('images', this.pageOfListImages, request);\n\n  /**\n   * Get a specific marketplace image. Get detailed information about a\n   * marketplace image, specified by its `image_id` (UUID format).\n   *\n   * @param request - The request {@link GetImageRequest}\n   * @returns A Promise of Image\n   */\n  getImage = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/images/${validatePathParam('imageId', request.imageId)}`\n  }, unmarshalImage$1);\n  pageOfListVersions = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/versions`,\n    urlParams: urlParams(['image_id', request.imageId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListVersionsResponse);\n\n  /**\n   * List versions of an Image. Get a list of all available version of an image,\n   * specified by its `image_id` (UUID format).\n   *\n   * @param request - The request {@link ListVersionsRequest}\n   * @returns A Promise of ListVersionsResponse\n   */\n  listVersions = request => enrichForPagination('versions', this.pageOfListVersions, request);\n\n  /**\n   * Get a specific image version. Get information such as the name, creation\n   * date, last update and published date for an image version specified by its\n   * `version_id` (UUID format).\n   *\n   * @param request - The request {@link GetVersionRequest}\n   * @returns A Promise of Version\n   */\n  getVersion = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/versions/${validatePathParam('versionId', request.versionId)}`\n  }, unmarshalVersion);\n  pageOfListLocalImages = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/local-images`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['zone', request.zone ?? this.client.settings.defaultZone], ...Object.entries(resolveOneOf([{\n      param: 'image_id',\n      value: request.imageId\n    }, {\n      param: 'version_id',\n      value: request.versionId\n    }, {\n      param: 'image_label',\n      value: request.imageLabel\n    }])))\n  }, unmarshalListLocalImagesResponse);\n\n  /**\n   * List local images from a specific image or version. List information about\n   * local images in a specific Availability Zone, specified by its `image_id`\n   * (UUID format), `version_id` (UUID format) or `image_label`. Only one of\n   * these three parameters may be set.\n   *\n   * @param request - The request {@link ListLocalImagesRequest}\n   * @returns A Promise of ListLocalImagesResponse\n   */\n  listLocalImages = (request = {}) => enrichForPagination('localImages', this.pageOfListLocalImages, request);\n\n  /**\n   * Get a specific local image by ID. Get detailed information about a local\n   * image, including compatible commercial types, supported architecture,\n   * labels and the Availability Zone of the image, specified by its\n   * `local_image_id` (UUID format).\n   *\n   * @param request - The request {@link GetLocalImageRequest}\n   * @returns A Promise of LocalImage\n   */\n  getLocalImage = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/local-images/${validatePathParam('localImageId', request.localImageId)}`\n  }, unmarshalLocalImage);\n  pageOfListCategories = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/categories`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListCategoriesResponse);\n\n  /**\n   * List existing image categories. Get a list of all existing categories. The\n   * output can be paginated.\n   *\n   * @param request - The request {@link ListCategoriesRequest}\n   * @returns A Promise of ListCategoriesResponse\n   */\n  listCategories = (request = {}) => enrichForPagination('categories', this.pageOfListCategories, request);\n\n  /**\n   * Get a specific category. Get information about a specific category of the\n   * marketplace catalog, specified by its `category_id` (UUID format).\n   *\n   * @param request - The request {@link GetCategoryRequest}\n   * @returns A Promise of Category\n   */\n  getCategory = request => this.client.fetch({\n    method: 'GET',\n    path: `/marketplace/v2/categories/${validatePathParam('categoryId', request.categoryId)}`\n  }, unmarshalCategory);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$a = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$a\n});\n\nvar index$a = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$b,\n  v2: index_gen$a\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalPermissions = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Permissions' failed as data isn't a dictionary.`);\n  }\n  return {\n    canManage: data.can_manage,\n    canPublish: data.can_publish,\n    canReceive: data.can_receive\n  };\n};\nconst unmarshalCredentialSummarySQSSNSCreds = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CredentialSummarySQSSNSCreds' failed as data isn't a dictionary.`);\n  }\n  return {\n    accessKey: data.access_key,\n    permissions: data.permissions ? unmarshalPermissions(data.permissions) : undefined\n  };\n};\nconst unmarshalCredentialNATSCredsFile = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CredentialNATSCredsFile' failed as data isn't a dictionary.`);\n  }\n  return {\n    content: data.content\n  };\n};\nconst unmarshalCredentialSQSSNSCreds = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CredentialSQSSNSCreds' failed as data isn't a dictionary.`);\n  }\n  return {\n    accessKey: data.access_key,\n    permissions: data.permissions ? unmarshalPermissions(data.permissions) : undefined,\n    secretKey: data.secret_key\n  };\n};\nconst unmarshalCredentialSummary = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CredentialSummary' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name,\n    namespaceId: data.namespace_id,\n    protocol: data.protocol,\n    sqsSnsCredentials: data.sqs_sns_credentials ? unmarshalCredentialSummarySQSSNSCreds(data.sqs_sns_credentials) : undefined\n  };\n};\nconst unmarshalNamespace$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Namespace' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    endpoint: data.endpoint,\n    id: data.id,\n    name: data.name,\n    projectId: data.project_id,\n    protocol: data.protocol,\n    region: data.region,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalCredential = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Credential' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name,\n    namespaceId: data.namespace_id,\n    natsCredentials: data.nats_credentials ? unmarshalCredentialNATSCredsFile(data.nats_credentials) : undefined,\n    protocol: data.protocol,\n    sqsSnsCredentials: data.sqs_sns_credentials ? unmarshalCredentialSQSSNSCreds(data.sqs_sns_credentials) : undefined\n  };\n};\nconst unmarshalListCredentialsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListCredentialsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    credentials: unmarshalArrayOfObject(data.credentials, unmarshalCredentialSummary),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNamespacesResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    namespaces: unmarshalArrayOfObject(data.namespaces, unmarshalNamespace$1),\n    totalCount: data.total_count\n  };\n};\nconst marshalPermissions = (request, defaults) => ({\n  can_manage: request.canManage,\n  can_publish: request.canPublish,\n  can_receive: request.canReceive\n});\nconst marshalCreateCredentialRequest = (request, defaults) => ({\n  name: request.name || randomName('mnq'),\n  namespace_id: request.namespaceId,\n  permissions: request.permissions ? marshalPermissions(request.permissions) : undefined\n});\nconst marshalCreateNamespaceRequest$1 = (request, defaults) => ({\n  name: request.name || randomName('mnq'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  protocol: request.protocol\n});\nconst marshalUpdateCredentialRequest = (request, defaults) => ({\n  name: request.name,\n  permissions: request.permissions ? marshalPermissions(request.permissions) : undefined\n});\nconst marshalUpdateNamespaceRequest$1 = (request, defaults) => ({\n  name: request.name,\n  namespace_id: request.namespaceId\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$9 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Messaging and Queuing API.\n *\n * This API allows you to manage Scaleway Messaging and Queueing brokers.\n * Messaging and Queuing API.\n */\nlet API$9 = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par'];\n  pageOfListNamespaces = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListNamespacesResponse$1);\n\n  /**\n   * List namespaces. List all Messaging and Queuing namespaces in the specified\n   * region, for a Scaleway Organization or Project. By default, the namespaces\n   * returned in the list are ordered by creation date in ascending order,\n   * though this can be modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListNamespacesRequest}\n   * @returns A Promise of ListNamespacesResponse\n   */\n  listNamespaces = (request = {}) => enrichForPagination('namespaces', this.pageOfListNamespaces, request);\n\n  /**\n   * Create a namespace. Create a Messaging and Queuing namespace, set to the\n   * desired protocol.\n   *\n   * @param request - The request {@link CreateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  createNamespace = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateNamespaceRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$9,\n    method: 'POST',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`\n  }, unmarshalNamespace$1);\n\n  /**\n   * Update the name of a namespace. Update the name of a Messaging and Queuing\n   * namespace, specified by its namespace ID.\n   *\n   * @param request - The request {@link UpdateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  updateNamespace = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateNamespaceRequest$1(request, this.client.settings)),\n    headers: jsonContentHeaders$9,\n    method: 'PATCH',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`\n  }, unmarshalNamespace$1);\n\n  /**\n   * Get a namespace. Retrieve information about an existing Messaging and\n   * Queuing namespace, identified by its namespace ID. Its full details,\n   * including name, endpoint and protocol, are returned in the response.\n   *\n   * @param request - The request {@link GetNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  getNamespace = request => this.client.fetch({\n    method: 'GET',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace$1);\n\n  /**\n   * Delete a namespace. Delete a Messaging and Queuing namespace, specified by\n   * its namespace ID. Note that deleting a namespace is irreversible, and any\n   * URLs, credentials and queued messages belonging to this namespace will also\n   * be deleted.\n   *\n   * @param request - The request {@link DeleteNamespaceRequest}\n   */\n  deleteNamespace = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  });\n\n  /**\n   * Create credentials. Create a set of credentials for a Messaging and Queuing\n   * namespace, specified by its namespace ID. If creating credentials for a\n   * NATS namespace, the `permissions` object must not be included in the\n   * request. If creating credentials for an SQS/SNS namespace, the\n   * `permissions` object is required, with all three of its child attributes.\n   *\n   * @param request - The request {@link CreateCredentialRequest}\n   * @returns A Promise of Credential\n   */\n  createCredential = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateCredentialRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$9,\n    method: 'POST',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/credentials`\n  }, unmarshalCredential);\n\n  /**\n   * Delete credentials. Delete a set of credentials, specified by their\n   * credential ID. Deleting credentials is irreversible and cannot be undone.\n   * The credentials can no longer be used to access the namespace.\n   *\n   * @param request - The request {@link DeleteCredentialRequest}\n   */\n  deleteCredential = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/credentials/${validatePathParam('credentialId', request.credentialId)}`\n  });\n  pageOfListCredentials = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/credentials`,\n    urlParams: urlParams(['namespace_id', request.namespaceId], ['order_by', request.orderBy ?? 'id_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListCredentialsResponse);\n\n  /**\n   * List credentials. List existing credentials in the specified region. The\n   * response contains only the metadata for the credentials, not the\n   * credentials themselves (for this, use **Get Credentials**).\n   *\n   * @param request - The request {@link ListCredentialsRequest}\n   * @returns A Promise of ListCredentialsResponse\n   */\n  listCredentials = (request = {}) => enrichForPagination('credentials', this.pageOfListCredentials, request);\n\n  /**\n   * Update credentials. Update a set of credentials. You can update the\n   * credentials' name, or (in the case of SQS/SNS credentials only) their\n   * permissions. To update the name of NATS credentials, do not include the\n   * `permissions` object in your request.\n   *\n   * @param request - The request {@link UpdateCredentialRequest}\n   * @returns A Promise of Credential\n   */\n  updateCredential = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateCredentialRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$9,\n    method: 'PATCH',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/credentials/${validatePathParam('credentialId', request.credentialId)}`\n  }, unmarshalCredential);\n\n  /**\n   * Get credentials. Retrieve an existing set of credentials, identified by the\n   * `credential_id`. The credentials themselves, as well as their metadata\n   * (protocol, namespace ID etc), are returned in the response.\n   *\n   * @param request - The request {@link GetCredentialRequest}\n   * @returns A Promise of Credential\n   */\n  getCredential = request => this.client.fetch({\n    method: 'GET',\n    path: `/mnq/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/credentials/${validatePathParam('credentialId', request.credentialId)}`\n  }, unmarshalCredential);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$9 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$9\n});\n\nvar index$9 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1alpha1: index_gen$9\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link DatabaseBackupStatus}. */\nconst DATABASE_BACKUP_TRANSIENT_STATUSES = ['creating', 'restoring', 'deleting', 'exporting'];\n\n/** Lists transient statutes of the enum {@link InstanceLogStatus}. */\nconst INSTANCE_LOG_TRANSIENT_STATUSES = ['creating'];\n\n/** Lists transient statutes of the enum {@link InstanceStatus}. */\nconst INSTANCE_TRANSIENT_STATUSES = ['provisioning', 'configuring', 'deleting', 'autohealing', 'initializing', 'backuping', 'snapshotting', 'restarting'];\n\n/** Lists transient statutes of the enum {@link MaintenanceStatus}. */\nconst MAINTENANCE_TRANSIENT_STATUSES = ['pending'];\n\n/** Lists transient statutes of the enum {@link ReadReplicaStatus}. */\nconst READ_REPLICA_TRANSIENT_STATUSES = ['provisioning', 'initializing', 'deleting', 'configuring'];\n\n/** Lists transient statutes of the enum {@link SnapshotStatus}. */\nconst SNAPSHOT_TRANSIENT_STATUSES = ['creating', 'restoring', 'deleting'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalEndpointDirectAccessDetails = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'EndpointDirectAccessDetails' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalEndpointLoadBalancerDetails = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'EndpointLoadBalancerDetails' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalEndpointPrivateNetworkDetails = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'EndpointPrivateNetworkDetails' failed as data isn't a dictionary.`);\n  }\n  return {\n    privateNetworkId: data.private_network_id,\n    serviceIp: data.service_ip,\n    zone: data.zone\n  };\n};\nconst unmarshalEndpoint$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Endpoint' failed as data isn't a dictionary.`);\n  }\n  return {\n    directAccess: data.direct_access ? unmarshalEndpointDirectAccessDetails(data.direct_access) : undefined,\n    hostname: data.hostname,\n    id: data.id,\n    ip: data.ip,\n    loadBalancer: data.load_balancer ? unmarshalEndpointLoadBalancerDetails(data.load_balancer) : undefined,\n    name: data.name,\n    port: data.port,\n    privateNetwork: data.private_network ? unmarshalEndpointPrivateNetworkDetails(data.private_network) : undefined\n  };\n};\nconst unmarshalEngineSetting = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'EngineSetting' failed as data isn't a dictionary.`);\n  }\n  return {\n    defaultValue: data.default_value,\n    description: data.description,\n    floatMax: data.float_max,\n    floatMin: data.float_min,\n    hotConfigurable: data.hot_configurable,\n    intMax: data.int_max,\n    intMin: data.int_min,\n    name: data.name,\n    propertyType: data.property_type,\n    stringConstraint: data.string_constraint,\n    unit: data.unit\n  };\n};\nconst unmarshalBackupSchedule = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'BackupSchedule' failed as data isn't a dictionary.`);\n  }\n  return {\n    disabled: data.disabled,\n    frequency: data.frequency,\n    retention: data.retention\n  };\n};\nconst unmarshalEngineVersion = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'EngineVersion' failed as data isn't a dictionary.`);\n  }\n  return {\n    availableInitSettings: unmarshalArrayOfObject(data.available_init_settings, unmarshalEngineSetting),\n    availableSettings: unmarshalArrayOfObject(data.available_settings, unmarshalEngineSetting),\n    beta: data.beta,\n    disabled: data.disabled,\n    endOfLife: unmarshalDate(data.end_of_life),\n    name: data.name,\n    version: data.version\n  };\n};\nconst unmarshalInstanceSetting = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'InstanceSetting' failed as data isn't a dictionary.`);\n  }\n  return {\n    name: data.name,\n    value: data.value\n  };\n};\nconst unmarshalLogsPolicy = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'LogsPolicy' failed as data isn't a dictionary.`);\n  }\n  return {\n    maxAgeRetention: data.max_age_retention,\n    totalDiskRetention: data.total_disk_retention\n  };\n};\nconst unmarshalMaintenance = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Maintenance' failed as data isn't a dictionary.`);\n  }\n  return {\n    closedAt: unmarshalDate(data.closed_at),\n    reason: data.reason,\n    startsAt: unmarshalDate(data.starts_at),\n    status: data.status,\n    stopsAt: unmarshalDate(data.stops_at)\n  };\n};\nconst unmarshalNodeTypeVolumeConstraintSizes = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'NodeTypeVolumeConstraintSizes' failed as data isn't a dictionary.`);\n  }\n  return {\n    maxSize: data.max_size,\n    minSize: data.min_size\n  };\n};\nconst unmarshalNodeTypeVolumeType = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'NodeTypeVolumeType' failed as data isn't a dictionary.`);\n  }\n  return {\n    chunkSize: data.chunk_size,\n    description: data.description,\n    maxSize: data.max_size,\n    minSize: data.min_size,\n    type: data.type\n  };\n};\nconst unmarshalReadReplica = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ReadReplica' failed as data isn't a dictionary.`);\n  }\n  return {\n    endpoints: unmarshalArrayOfObject(data.endpoints, unmarshalEndpoint$1),\n    id: data.id,\n    region: data.region,\n    status: data.status\n  };\n};\nconst unmarshalUpgradableVersion = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'UpgradableVersion' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    minorVersion: data.minor_version,\n    name: data.name,\n    version: data.version\n  };\n};\nconst unmarshalVolume = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Volume' failed as data isn't a dictionary.`);\n  }\n  return {\n    size: data.size,\n    type: data.type\n  };\n};\nconst unmarshalACLRule$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ACLRule' failed as data isn't a dictionary.`);\n  }\n  return {\n    action: data.action,\n    description: data.description,\n    direction: data.direction,\n    ip: data.ip,\n    port: data.port,\n    protocol: data.protocol\n  };\n};\nconst unmarshalDatabase = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Database' failed as data isn't a dictionary.`);\n  }\n  return {\n    managed: data.managed,\n    name: data.name,\n    owner: data.owner,\n    size: data.size\n  };\n};\nconst unmarshalDatabaseBackup = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DatabaseBackup' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    databaseName: data.database_name,\n    downloadUrl: data.download_url,\n    downloadUrlExpiresAt: unmarshalDate(data.download_url_expires_at),\n    expiresAt: unmarshalDate(data.expires_at),\n    id: data.id,\n    instanceId: data.instance_id,\n    instanceName: data.instance_name,\n    name: data.name,\n    region: data.region,\n    sameRegion: data.same_region,\n    size: data.size,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalDatabaseEngine = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DatabaseEngine' failed as data isn't a dictionary.`);\n  }\n  return {\n    logoUrl: data.logo_url,\n    name: data.name,\n    region: data.region,\n    versions: unmarshalArrayOfObject(data.versions, unmarshalEngineVersion)\n  };\n};\nconst unmarshalInstance = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Instance' failed as data isn't a dictionary.`);\n  }\n  return {\n    backupSameRegion: data.backup_same_region,\n    backupSchedule: data.backup_schedule ? unmarshalBackupSchedule(data.backup_schedule) : undefined,\n    createdAt: unmarshalDate(data.created_at),\n    endpoint: data.endpoint ? unmarshalEndpoint$1(data.endpoint) : undefined,\n    endpoints: unmarshalArrayOfObject(data.endpoints, unmarshalEndpoint$1),\n    engine: data.engine,\n    id: data.id,\n    initSettings: unmarshalArrayOfObject(data.init_settings, unmarshalInstanceSetting),\n    isHaCluster: data.is_ha_cluster,\n    logsPolicy: data.logs_policy ? unmarshalLogsPolicy(data.logs_policy) : undefined,\n    maintenances: unmarshalArrayOfObject(data.maintenances, unmarshalMaintenance),\n    name: data.name,\n    nodeType: data.node_type,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    readReplicas: unmarshalArrayOfObject(data.read_replicas, unmarshalReadReplica),\n    region: data.region,\n    settings: unmarshalArrayOfObject(data.settings, unmarshalInstanceSetting),\n    status: data.status,\n    tags: data.tags,\n    upgradableVersion: unmarshalArrayOfObject(data.upgradable_version, unmarshalUpgradableVersion),\n    volume: data.volume ? unmarshalVolume(data.volume) : undefined\n  };\n};\nconst unmarshalInstanceLog = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'InstanceLog' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    downloadUrl: data.download_url,\n    expiresAt: unmarshalDate(data.expires_at),\n    id: data.id,\n    nodeName: data.node_name,\n    region: data.region,\n    status: data.status\n  };\n};\nconst unmarshalListInstanceLogsDetailsResponseInstanceLogDetail = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListInstanceLogsDetailsResponseInstanceLogDetail' failed as data isn't a dictionary.`);\n  }\n  return {\n    logName: data.log_name,\n    size: data.size\n  };\n};\nconst unmarshalNodeType$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'NodeType' failed as data isn't a dictionary.`);\n  }\n  return {\n    availableVolumeTypes: unmarshalArrayOfObject(data.available_volume_types, unmarshalNodeTypeVolumeType),\n    beta: data.beta,\n    description: data.description,\n    disabled: data.disabled,\n    generation: data.generation,\n    isBssdCompatible: data.is_bssd_compatible,\n    isHaRequired: data.is_ha_required,\n    memory: data.memory,\n    name: data.name,\n    region: data.region,\n    stockStatus: data.stock_status,\n    vcpus: data.vcpus,\n    volumeConstraint: data.volume_constraint ? unmarshalNodeTypeVolumeConstraintSizes(data.volume_constraint) : undefined\n  };\n};\nconst unmarshalPrivilege = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Privilege' failed as data isn't a dictionary.`);\n  }\n  return {\n    databaseName: data.database_name,\n    permission: data.permission,\n    userName: data.user_name\n  };\n};\nconst unmarshalSnapshot = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Snapshot' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    expiresAt: unmarshalDate(data.expires_at),\n    id: data.id,\n    instanceId: data.instance_id,\n    instanceName: data.instance_name,\n    name: data.name,\n    nodeType: data.node_type,\n    region: data.region,\n    size: data.size,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalUser = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'User' failed as data isn't a dictionary.`);\n  }\n  return {\n    isAdmin: data.is_admin,\n    name: data.name\n  };\n};\nconst unmarshalAddInstanceACLRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AddInstanceACLRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalACLRule$1)\n  };\n};\nconst unmarshalAddInstanceSettingsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AddInstanceSettingsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    settings: unmarshalArrayOfObject(data.settings, unmarshalInstanceSetting)\n  };\n};\nconst unmarshalDeleteInstanceACLRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DeleteInstanceACLRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalACLRule$1)\n  };\n};\nconst unmarshalDeleteInstanceSettingsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DeleteInstanceSettingsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    settings: unmarshalArrayOfObject(data.settings, unmarshalInstanceSetting)\n  };\n};\nconst unmarshalInstanceMetrics = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'InstanceMetrics' failed as data isn't a dictionary.`);\n  }\n  return {\n    timeseries: unmarshalArrayOfObject(data.timeseries, unmarshalTimeSeries)\n  };\n};\nconst unmarshalListDatabaseBackupsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDatabaseBackupsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    databaseBackups: unmarshalArrayOfObject(data.database_backups, unmarshalDatabaseBackup),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDatabaseEnginesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDatabaseEnginesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    engines: unmarshalArrayOfObject(data.engines, unmarshalDatabaseEngine),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDatabasesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDatabasesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    databases: unmarshalArrayOfObject(data.databases, unmarshalDatabase),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListInstanceACLRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListInstanceACLRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalACLRule$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListInstanceLogsDetailsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListInstanceLogsDetailsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    details: unmarshalArrayOfObject(data.details, unmarshalListInstanceLogsDetailsResponseInstanceLogDetail)\n  };\n};\nconst unmarshalListInstanceLogsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListInstanceLogsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    instanceLogs: unmarshalArrayOfObject(data.instance_logs, unmarshalInstanceLog)\n  };\n};\nconst unmarshalListInstancesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListInstancesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    instances: unmarshalArrayOfObject(data.instances, unmarshalInstance),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNodeTypesResponse$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNodeTypesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    nodeTypes: unmarshalArrayOfObject(data.node_types, unmarshalNodeType$1),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPrivilegesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPrivilegesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    privileges: unmarshalArrayOfObject(data.privileges, unmarshalPrivilege),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListSnapshotsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSnapshotsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    snapshots: unmarshalArrayOfObject(data.snapshots, unmarshalSnapshot),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListUsersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListUsersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    users: unmarshalArrayOfObject(data.users, unmarshalUser)\n  };\n};\nconst unmarshalPrepareInstanceLogsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrepareInstanceLogsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    instanceLogs: unmarshalArrayOfObject(data.instance_logs, unmarshalInstanceLog)\n  };\n};\nconst unmarshalSetInstanceACLRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetInstanceACLRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    rules: unmarshalArrayOfObject(data.rules, unmarshalACLRule$1)\n  };\n};\nconst unmarshalSetInstanceSettingsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetInstanceSettingsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    settings: unmarshalArrayOfObject(data.settings, unmarshalInstanceSetting)\n  };\n};\nconst marshalEndpointSpecPrivateNetworkIpamConfig = (request, defaults) => ({});\nconst marshalReadReplicaEndpointSpecPrivateNetworkIpamConfig = (request, defaults) => ({});\nconst marshalEndpointSpecLoadBalancer = (request, defaults) => ({});\nconst marshalEndpointSpecPrivateNetwork = (request, defaults) => ({\n  private_network_id: request.privateNetworkId,\n  ...resolveOneOf([{\n    param: 'service_ip',\n    value: request.serviceIp\n  }, {\n    param: 'ipam_config',\n    value: request.ipamConfig ? marshalEndpointSpecPrivateNetworkIpamConfig(request.ipamConfig) : undefined\n  }])\n});\nconst marshalReadReplicaEndpointSpecDirectAccess = (request, defaults) => ({});\nconst marshalReadReplicaEndpointSpecPrivateNetwork = (request, defaults) => ({\n  private_network_id: request.privateNetworkId,\n  ...resolveOneOf([{\n    param: 'service_ip',\n    value: request.serviceIp\n  }, {\n    param: 'ipam_config',\n    value: request.ipamConfig ? marshalReadReplicaEndpointSpecPrivateNetworkIpamConfig(request.ipamConfig) : undefined\n  }])\n});\nconst marshalACLRuleRequest = (request, defaults) => ({\n  description: request.description,\n  ip: request.ip\n});\nconst marshalEndpointSpec$1 = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'load_balancer',\n    value: request.loadBalancer ? marshalEndpointSpecLoadBalancer(request.loadBalancer) : undefined\n  }, {\n    param: 'private_network',\n    value: request.privateNetwork ? marshalEndpointSpecPrivateNetwork(request.privateNetwork) : undefined\n  }])\n});\nconst marshalInstanceSetting = (request, defaults) => ({\n  name: request.name,\n  value: request.value\n});\nconst marshalLogsPolicy = (request, defaults) => ({\n  max_age_retention: request.maxAgeRetention,\n  total_disk_retention: request.totalDiskRetention\n});\nconst marshalReadReplicaEndpointSpec = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'direct_access',\n    value: request.directAccess ? marshalReadReplicaEndpointSpecDirectAccess(request.directAccess) : undefined\n  }, {\n    param: 'private_network',\n    value: request.privateNetwork ? marshalReadReplicaEndpointSpecPrivateNetwork(request.privateNetwork) : undefined\n  }])\n});\nconst marshalAddInstanceACLRulesRequest = (request, defaults) => ({\n  rules: request.rules.map(elt => marshalACLRuleRequest(elt))\n});\nconst marshalAddInstanceSettingsRequest = (request, defaults) => ({\n  settings: request.settings.map(elt => marshalInstanceSetting(elt))\n});\nconst marshalCloneInstanceRequest = (request, defaults) => ({\n  name: request.name,\n  node_type: request.nodeType\n});\nconst marshalCreateDatabaseBackupRequest = (request, defaults) => ({\n  database_name: request.databaseName,\n  expires_at: request.expiresAt,\n  instance_id: request.instanceId,\n  name: request.name || randomName('bkp')\n});\nconst marshalCreateDatabaseRequest = (request, defaults) => ({\n  name: request.name\n});\nconst marshalCreateEndpointRequest = (request, defaults) => ({\n  endpoint_spec: request.endpointSpec ? marshalEndpointSpec$1(request.endpointSpec) : undefined\n});\nconst marshalCreateInstanceFromSnapshotRequest = (request, defaults) => ({\n  instance_name: request.instanceName,\n  is_ha_cluster: request.isHaCluster,\n  node_type: request.nodeType\n});\nconst marshalCreateInstanceRequest = (request, defaults) => ({\n  backup_same_region: request.backupSameRegion,\n  disable_backup: request.disableBackup,\n  engine: request.engine,\n  init_endpoints: request.initEndpoints ? request.initEndpoints.map(elt => marshalEndpointSpec$1(elt)) : undefined,\n  init_settings: request.initSettings ? request.initSettings.map(elt => marshalInstanceSetting(elt)) : undefined,\n  is_ha_cluster: request.isHaCluster,\n  name: request.name || randomName('ins'),\n  node_type: request.nodeType,\n  password: request.password,\n  tags: request.tags,\n  user_name: request.userName,\n  volume_size: request.volumeSize,\n  volume_type: request.volumeType ?? 'lssd',\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalCreateReadReplicaEndpointRequest = (request, defaults) => ({\n  endpoint_spec: request.endpointSpec.map(elt => marshalReadReplicaEndpointSpec(elt))\n});\nconst marshalCreateReadReplicaRequest = (request, defaults) => ({\n  endpoint_spec: request.endpointSpec ? request.endpointSpec.map(elt => marshalReadReplicaEndpointSpec(elt)) : undefined,\n  instance_id: request.instanceId\n});\nconst marshalCreateSnapshotRequest = (request, defaults) => ({\n  expires_at: request.expiresAt,\n  name: request.name || randomName('snp')\n});\nconst marshalCreateUserRequest = (request, defaults) => ({\n  is_admin: request.isAdmin,\n  name: request.name,\n  password: request.password\n});\nconst marshalDeleteInstanceACLRulesRequest = (request, defaults) => ({\n  acl_rule_ips: request.aclRuleIps\n});\nconst marshalDeleteInstanceSettingsRequest = (request, defaults) => ({\n  setting_names: request.settingNames\n});\nconst marshalMigrateEndpointRequest = (request, defaults) => ({\n  instance_id: request.instanceId\n});\nconst marshalPrepareInstanceLogsRequest = (request, defaults) => ({\n  end_date: request.endDate,\n  start_date: request.startDate\n});\nconst marshalPurgeInstanceLogsRequest = (request, defaults) => ({\n  log_name: request.logName\n});\nconst marshalRestoreDatabaseBackupRequest = (request, defaults) => ({\n  database_name: request.databaseName,\n  instance_id: request.instanceId\n});\nconst marshalSetInstanceACLRulesRequest = (request, defaults) => ({\n  rules: request.rules.map(elt => marshalACLRuleRequest(elt))\n});\nconst marshalSetInstanceSettingsRequest = (request, defaults) => ({\n  settings: request.settings.map(elt => marshalInstanceSetting(elt))\n});\nconst marshalSetPrivilegeRequest = (request, defaults) => ({\n  database_name: request.databaseName,\n  permission: request.permission ?? 'readonly',\n  user_name: request.userName\n});\nconst marshalUpdateDatabaseBackupRequest = (request, defaults) => ({\n  expires_at: request.expiresAt,\n  name: request.name\n});\nconst marshalUpdateInstanceRequest = (request, defaults) => ({\n  backup_same_region: request.backupSameRegion,\n  backup_schedule_frequency: request.backupScheduleFrequency,\n  backup_schedule_retention: request.backupScheduleRetention,\n  is_backup_schedule_disabled: request.isBackupScheduleDisabled,\n  logs_policy: request.logsPolicy ? marshalLogsPolicy(request.logsPolicy) : undefined,\n  name: request.name,\n  tags: request.tags\n});\nconst marshalUpdateSnapshotRequest = (request, defaults) => ({\n  expires_at: request.expiresAt,\n  name: request.name\n});\nconst marshalUpdateUserRequest = (request, defaults) => ({\n  is_admin: request.isAdmin,\n  password: request.password\n});\nconst marshalUpgradeInstanceRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'node_type',\n    value: request.nodeType\n  }, {\n    param: 'enable_ha',\n    value: request.enableHa\n  }, {\n    param: 'volume_size',\n    value: request.volumeSize\n  }, {\n    param: 'volume_type',\n    value: request.volumeType\n  }, {\n    param: 'upgradable_version_id',\n    value: request.upgradableVersionId\n  }])\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$8 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Managed Database for PostgreSQL and MySQL API. */\nlet API$8 = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par', 'nl-ams', 'pl-waw'];\n  pageOfListDatabaseEngines = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/database-engines`,\n    urlParams: urlParams(['name', request.name], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['version', request.version])\n  }, unmarshalListDatabaseEnginesResponse);\n\n  /**\n   * List available database engines. List the PostgreSQL and MySQL database\n   * engines available at Scaleway.\n   *\n   * @param request - The request {@link ListDatabaseEnginesRequest}\n   * @returns A Promise of ListDatabaseEnginesResponse\n   */\n  listDatabaseEngines = (request = {}) => enrichForPagination('engines', this.pageOfListDatabaseEngines, request);\n  pageOfListNodeTypes = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/node-types`,\n    urlParams: urlParams(['include_disabled_types', request.includeDisabledTypes], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListNodeTypesResponse$1);\n\n  /**\n   * List available node types. List all available node types. By default, the\n   * node types returned in the list are ordered by creation date in ascending\n   * order, though this can be modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListNodeTypesRequest}\n   * @returns A Promise of ListNodeTypesResponse\n   */\n  listNodeTypes = request => enrichForPagination('nodeTypes', this.pageOfListNodeTypes, request);\n  pageOfListDatabaseBackups = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backups`,\n    urlParams: urlParams(['instance_id', request.instanceId], ['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListDatabaseBackupsResponse);\n\n  /**\n   * List database backups. List all backups in a specified region, for a given\n   * Scaleway Organization or Scaleway Project. By default, the backups listed\n   * are ordered by creation date in ascending order. This can be modified via\n   * the `order_by` field.\n   *\n   * @param request - The request {@link ListDatabaseBackupsRequest}\n   * @returns A Promise of ListDatabaseBackupsResponse\n   */\n  listDatabaseBackups = (request = {}) => enrichForPagination('databaseBackups', this.pageOfListDatabaseBackups, request);\n\n  /**\n   * Create a database backup. Create a new backup. You must set the\n   * `instance_id`, `database_name`, `name` and `expires_at` parameters.\n   *\n   * @param request - The request {@link CreateDatabaseBackupRequest}\n   * @returns A Promise of DatabaseBackup\n   */\n  createDatabaseBackup = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDatabaseBackupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backups`\n  }, unmarshalDatabaseBackup);\n\n  /**\n   * Get a database backup. Retrieve information about a given backup, specified\n   * by its database backup ID and region. Full details about the backup, like\n   * size, URL and expiration date, are returned in the response.\n   *\n   * @param request - The request {@link GetDatabaseBackupRequest}\n   * @returns A Promise of DatabaseBackup\n   */\n  getDatabaseBackup = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backups/${validatePathParam('databaseBackupId', request.databaseBackupId)}`\n  }, unmarshalDatabaseBackup);\n\n  /**\n   * Waits for {@link DatabaseBackup} to be in a final state.\n   *\n   * @param request - The request {@link GetDatabaseBackupRequest}\n   * @param options - The waiting options\n   * @returns A Promise of DatabaseBackup\n   */\n  waitForDatabaseBackup = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!DATABASE_BACKUP_TRANSIENT_STATUSES.includes(res.status))), this.getDatabaseBackup, request, options);\n\n  /**\n   * Update a database backup. Update the parameters of a backup, including name\n   * and expiration date.\n   *\n   * @param request - The request {@link UpdateDatabaseBackupRequest}\n   * @returns A Promise of DatabaseBackup\n   */\n  updateDatabaseBackup = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateDatabaseBackupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'PATCH',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backups/${validatePathParam('databaseBackupId', request.databaseBackupId)}`\n  }, unmarshalDatabaseBackup);\n\n  /**\n   * Delete a database backup. Delete a backup, specified by its database backup\n   * ID and region. Deleting a backup is permanent, and cannot be undone.\n   *\n   * @param request - The request {@link DeleteDatabaseBackupRequest}\n   * @returns A Promise of DatabaseBackup\n   */\n  deleteDatabaseBackup = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backups/${validatePathParam('databaseBackupId', request.databaseBackupId)}`\n  }, unmarshalDatabaseBackup);\n\n  /**\n   * Restore a database backup. Launch the process of restoring database backup.\n   * You must specify the `instance_id` of the Database Instance of destination,\n   * where the backup will be restored. Note that large database backups can\n   * take up to several hours to restore.\n   *\n   * @param request - The request {@link RestoreDatabaseBackupRequest}\n   * @returns A Promise of DatabaseBackup\n   */\n  restoreDatabaseBackup = request => this.client.fetch({\n    body: JSON.stringify(marshalRestoreDatabaseBackupRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backups/${validatePathParam('databaseBackupId', request.databaseBackupId)}/restore`\n  }, unmarshalDatabaseBackup);\n\n  /**\n   * Export a database backup. Export a backup, specified by the\n   * `database_backup_id` and the `region` parameters. The download URL is\n   * returned in the response.\n   *\n   * @param request - The request {@link ExportDatabaseBackupRequest}\n   * @returns A Promise of DatabaseBackup\n   */\n  exportDatabaseBackup = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/backups/${validatePathParam('databaseBackupId', request.databaseBackupId)}/export`\n  }, unmarshalDatabaseBackup);\n\n  /**\n   * Upgrade a Database Instance. Upgrade your current Database Instance\n   * specifications like node type, high availability, volume, or the database\n   * engine version. Note that upon upgrade the `enable_ha` parameter can only\n   * be set to `true`.\n   *\n   * @param request - The request {@link UpgradeInstanceRequest}\n   * @returns A Promise of Instance\n   */\n  upgradeInstance = request => this.client.fetch({\n    body: JSON.stringify(marshalUpgradeInstanceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/upgrade`\n  }, unmarshalInstance);\n  pageOfListInstances = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['tags', request.tags])\n  }, unmarshalListInstancesResponse);\n\n  /**\n   * List Database Instances. List all Database Instances in the specified\n   * region, for a given Scaleway Organization or Scaleway Project. By default,\n   * the Database Instances returned in the list are ordered by creation date in\n   * ascending order, though this can be modified via the order_by field. You\n   * can define additional parameters for your query, such as `tags` and `name`.\n   * For the `name` parameter, the value you include will be checked against the\n   * whole name string to see if it includes the string you put in the\n   * parameter.\n   *\n   * @param request - The request {@link ListInstancesRequest}\n   * @returns A Promise of ListInstancesResponse\n   */\n  listInstances = (request = {}) => enrichForPagination('instances', this.pageOfListInstances, request);\n\n  /**\n   * Get a Database Instance. Retrieve information about a given Database\n   * Instance, specified by the `region` and `instance_id` parameters. Its full\n   * details, including name, status, IP address and port, are returned in the\n   * response object.\n   *\n   * @param request - The request {@link GetInstanceRequest}\n   * @returns A Promise of Instance\n   */\n  getInstance = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}`\n  }, unmarshalInstance);\n\n  /**\n   * Waits for {@link Instance} to be in a final state.\n   *\n   * @param request - The request {@link GetInstanceRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Instance\n   */\n  waitForInstance = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!INSTANCE_TRANSIENT_STATUSES.includes(res.status))), this.getInstance, request, options);\n\n  /**\n   * Create a Database Instance. Create a new Database Instance. You must set\n   * the `engine`, `user_name`, `password` and `node_type` parameters.\n   * Optionally, you can specify the volume type and size.\n   *\n   * @param request - The request {@link CreateInstanceRequest}\n   * @returns A Promise of Instance\n   */\n  createInstance = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateInstanceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances`\n  }, unmarshalInstance);\n\n  /**\n   * Update a Database Instance. Update the parameters of a Database Instance,\n   * including name, tags and backup schedule details.\n   *\n   * @param request - The request {@link UpdateInstanceRequest}\n   * @returns A Promise of Instance\n   */\n  updateInstance = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateInstanceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'PATCH',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}`\n  }, unmarshalInstance);\n\n  /**\n   * Delete a Database Instance. Delete a given Database Instance, specified by\n   * the `region` and `instance_id` parameters. Deleting a Database Instance is\n   * permanent, and cannot be undone. Note that upon deletion all your data will\n   * be lost.\n   *\n   * @param request - The request {@link DeleteInstanceRequest}\n   * @returns A Promise of Instance\n   */\n  deleteInstance = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}`\n  }, unmarshalInstance);\n\n  /**\n   * Clone a Database Instance. Clone a given Database Instance, specified by\n   * the `region` and `instance_id` parameters. The clone feature allows you to\n   * create a new Database Instance from an existing one. The clone includes all\n   * existing databases, users and permissions. You can create a clone on a\n   * Database Instance bigger than your current one.\n   *\n   * @param request - The request {@link CloneInstanceRequest}\n   * @returns A Promise of Instance\n   */\n  cloneInstance = request => this.client.fetch({\n    body: JSON.stringify(marshalCloneInstanceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/clone`\n  }, unmarshalInstance);\n\n  /**\n   * Restart Database Instance. Restart a given Database Instance, specified by\n   * the `region` and `instance_id` parameters. The status of the Database\n   * Instance returned in the response.\n   *\n   * @param request - The request {@link RestartInstanceRequest}\n   * @returns A Promise of Instance\n   */\n  restartInstance = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/restart`\n  }, unmarshalInstance);\n\n  /**\n   * Get the TLS certificate of a Database Instance. Retrieve information about\n   * the TLS certificate of a given Database Instance. Details like name and\n   * content are returned in the response.\n   *\n   * @param request - The request {@link GetInstanceCertificateRequest}\n   * @returns A Promise of Blob\n   */\n  getInstanceCertificate = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/certificate`,\n    urlParams: urlParams(['dl', 1]),\n    responseType: 'blob'\n  });\n\n  /**\n   * Renew the TLS certificate of a Database Instance. Renew a TLS for a\n   * Database Instance. Renewing a certificate means that you will not be able\n   * to connect to your Database Instance using the previous certificate. You\n   * will also need to download and update the new certificate for all database\n   * clients.\n   *\n   * @param request - The request {@link RenewInstanceCertificateRequest}\n   */\n  renewInstanceCertificate = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/renew-certificate`\n  });\n\n  /**\n   * Get Database Instance metrics. Retrieve the time series metrics of a given\n   * Database Instance. You can define the period from which to retrieve metrics\n   * by specifying the `start_date` and `end_date`.\n   *\n   * @param request - The request {@link GetInstanceMetricsRequest}\n   * @returns A Promise of InstanceMetrics\n   */\n  getInstanceMetrics = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/metrics`,\n    urlParams: urlParams(['end_date', request.endDate], ['metric_name', request.metricName], ['start_date', request.startDate])\n  }, unmarshalInstanceMetrics);\n\n  /**\n   * Create a Read Replica. Create a new Read Replica of a Database Instance.\n   * You must specify the `region` and the `instance_id`. You can only create a\n   * maximum of 3 Read Replicas per Database Instance.\n   *\n   * @param request - The request {@link CreateReadReplicaRequest}\n   * @returns A Promise of ReadReplica\n   */\n  createReadReplica = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateReadReplicaRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/read-replicas`\n  }, unmarshalReadReplica);\n\n  /**\n   * Get a Read Replica. Retrieve information about a Database Instance Read\n   * Replica. Full details about the Read Replica, like `endpoints`, `status`\n   * and `region` are returned in the response.\n   *\n   * @param request - The request {@link GetReadReplicaRequest}\n   * @returns A Promise of ReadReplica\n   */\n  getReadReplica = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/read-replicas/${validatePathParam('readReplicaId', request.readReplicaId)}`\n  }, unmarshalReadReplica);\n\n  /**\n   * Waits for {@link ReadReplica} to be in a final state.\n   *\n   * @param request - The request {@link GetReadReplicaRequest}\n   * @param options - The waiting options\n   * @returns A Promise of ReadReplica\n   */\n  waitForReadReplica = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!READ_REPLICA_TRANSIENT_STATUSES.includes(res.status))), this.getReadReplica, request, options);\n\n  /**\n   * Delete a Read Replica. Delete a Read Replica of a Database Instance. You\n   * must specify the `region` and `read_replica_id` parameters of the Read\n   * Replica you want to delete.\n   *\n   * @param request - The request {@link DeleteReadReplicaRequest}\n   * @returns A Promise of ReadReplica\n   */\n  deleteReadReplica = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/read-replicas/${validatePathParam('readReplicaId', request.readReplicaId)}`\n  }, unmarshalReadReplica);\n\n  /**\n   * Resync a Read Replica. When you resync a Read Replica, first it is reset,\n   * then its data is resynchronized from the primary node. Your Read Replica\n   * remains unavailable during the resync process. The duration of this process\n   * is proportional to the size of your Database Instance. The configured\n   * endpoints do not change.\n   *\n   * @param request - The request {@link ResetReadReplicaRequest}\n   * @returns A Promise of ReadReplica\n   */\n  resetReadReplica = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/read-replicas/${validatePathParam('readReplicaId', request.readReplicaId)}/reset`\n  }, unmarshalReadReplica);\n\n  /**\n   * Create an endpoint for a Read Replica. Create a new endpoint for a Read\n   * Replica. Read Replicas can have at most one direct access and one Private\n   * Network endpoint.\n   *\n   * @param request - The request {@link CreateReadReplicaEndpointRequest}\n   * @returns A Promise of ReadReplica\n   */\n  createReadReplicaEndpoint = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateReadReplicaEndpointRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/read-replicas/${validatePathParam('readReplicaId', request.readReplicaId)}/endpoints`\n  }, unmarshalReadReplica);\n\n  /**\n   * Prepare logs of a Database Instance. Prepare your Database Instance logs.\n   * You can define the `start_date` and `end_date` parameters for your query.\n   * The download URL is returned in the response. Logs are recorded from 00h00\n   * to 23h59 and then aggregated in a `.log` file once a day. Therefore, even\n   * if you specify a timeframe from which you want to get the logs, you will\n   * receive logs from the full 24 hours.\n   *\n   * @param request - The request {@link PrepareInstanceLogsRequest}\n   * @returns A Promise of PrepareInstanceLogsResponse\n   */\n  prepareInstanceLogs = request => this.client.fetch({\n    body: JSON.stringify(marshalPrepareInstanceLogsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/prepare-logs`\n  }, unmarshalPrepareInstanceLogsResponse);\n\n  /**\n   * List available logs of a Database Instance. List the available logs of a\n   * Database Instance. By default, the logs returned in the list are ordered by\n   * creation date in ascending order, though this can be modified via the\n   * order_by field.\n   *\n   * @param request - The request {@link ListInstanceLogsRequest}\n   * @returns A Promise of ListInstanceLogsResponse\n   */\n  listInstanceLogs = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/logs`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'])\n  }, unmarshalListInstanceLogsResponse);\n\n  /**\n   * Get given logs of a Database Instance. Retrieve information about the logs\n   * of a Database Instance. Specify the `instance_log_id` and `region` in your\n   * request to get information such as `download_url`, `status`, `expires_at`\n   * and `created_at` about your logs in the response.\n   *\n   * @param request - The request {@link GetInstanceLogRequest}\n   * @returns A Promise of InstanceLog\n   */\n  getInstanceLog = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/logs/${validatePathParam('instanceLogId', request.instanceLogId)}`\n  }, unmarshalInstanceLog);\n\n  /**\n   * Waits for {@link InstanceLog} to be in a final state.\n   *\n   * @param request - The request {@link GetInstanceLogRequest}\n   * @param options - The waiting options\n   * @returns A Promise of InstanceLog\n   */\n  waitForInstanceLog = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!INSTANCE_LOG_TRANSIENT_STATUSES.includes(res.status))), this.getInstanceLog, request, options);\n\n  /**\n   * Purge remote Database Instance logs. Purge a given remote log from a\n   * Database Instance. You can specify the `log_name` of the log you wish to\n   * clean from your Database Instance.\n   *\n   * @param request - The request {@link PurgeInstanceLogsRequest}\n   */\n  purgeInstanceLogs = request => this.client.fetch({\n    body: JSON.stringify(marshalPurgeInstanceLogsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/purge-logs`\n  });\n\n  /**\n   * List remote Database Instance logs details. List remote log details. By\n   * default, the details returned in the list are ordered by creation date in\n   * ascending order, though this can be modified via the order_by field.\n   *\n   * @param request - The request {@link ListInstanceLogsDetailsRequest}\n   * @returns A Promise of ListInstanceLogsDetailsResponse\n   */\n  listInstanceLogsDetails = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/logs-details`\n  }, unmarshalListInstanceLogsDetailsResponse);\n\n  /**\n   * Add Database Instance advanced settings. Add an advanced setting to a\n   * Database Instance. You must set the `name` and the `value` of each\n   * setting.\n   *\n   * @param request - The request {@link AddInstanceSettingsRequest}\n   * @returns A Promise of AddInstanceSettingsResponse\n   */\n  addInstanceSettings = request => this.client.fetch({\n    body: JSON.stringify(marshalAddInstanceSettingsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/settings`\n  }, unmarshalAddInstanceSettingsResponse);\n\n  /**\n   * Delete Database Instance advanced settings. Delete an advanced setting in a\n   * Database Instance. You must specify the names of the settings you want to\n   * delete in the request.\n   *\n   * @param request - The request {@link DeleteInstanceSettingsRequest}\n   * @returns A Promise of DeleteInstanceSettingsResponse\n   */\n  deleteInstanceSettings = request => this.client.fetch({\n    body: JSON.stringify(marshalDeleteInstanceSettingsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/settings`\n  }, unmarshalDeleteInstanceSettingsResponse);\n\n  /**\n   * Set Database Instance advanced settings. Update an advanced setting for a\n   * Database Instance. Settings added upon database engine initalization can\n   * only be defined once, and cannot, therefore, be updated.\n   *\n   * @param request - The request {@link SetInstanceSettingsRequest}\n   * @returns A Promise of SetInstanceSettingsResponse\n   */\n  setInstanceSettings = request => this.client.fetch({\n    body: JSON.stringify(marshalSetInstanceSettingsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'PUT',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/settings`\n  }, unmarshalSetInstanceSettingsResponse);\n  pageOfListInstanceACLRules = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/acls`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListInstanceACLRulesResponse);\n\n  /**\n   * List ACL rules of a Database Instance. List the ACL rules for a given\n   * Database Instance. The response is an array of ACL objects, each one\n   * representing an ACL that denies, allows or redirects traffic based on\n   * certain conditions.\n   *\n   * @param request - The request {@link ListInstanceACLRulesRequest}\n   * @returns A Promise of ListInstanceACLRulesResponse\n   */\n  listInstanceACLRules = request => enrichForPagination('rules', this.pageOfListInstanceACLRules, request);\n\n  /**\n   * Add an ACL rule to a Database Instance. Add an additional ACL rule to a\n   * Database Instance.\n   *\n   * @param request - The request {@link AddInstanceACLRulesRequest}\n   * @returns A Promise of AddInstanceACLRulesResponse\n   */\n  addInstanceACLRules = request => this.client.fetch({\n    body: JSON.stringify(marshalAddInstanceACLRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/acls`\n  }, unmarshalAddInstanceACLRulesResponse);\n\n  /**\n   * Set ACL rules for a Database Instance. Replace all the ACL rules of a\n   * Database Instance.\n   *\n   * @param request - The request {@link SetInstanceACLRulesRequest}\n   * @returns A Promise of SetInstanceACLRulesResponse\n   */\n  setInstanceACLRules = request => this.client.fetch({\n    body: JSON.stringify(marshalSetInstanceACLRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'PUT',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/acls`\n  }, unmarshalSetInstanceACLRulesResponse);\n\n  /**\n   * Delete ACL rules of a Database Instance. Delete one or more ACL rules of a\n   * Database Instance.\n   *\n   * @param request - The request {@link DeleteInstanceACLRulesRequest}\n   * @returns A Promise of DeleteInstanceACLRulesResponse\n   */\n  deleteInstanceACLRules = request => this.client.fetch({\n    body: JSON.stringify(marshalDeleteInstanceACLRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/acls`\n  }, unmarshalDeleteInstanceACLRulesResponse);\n  pageOfListUsers = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/users`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListUsersResponse);\n\n  /**\n   * List users of a Database Instance. List all users of a given Database\n   * Instance. By default, the users returned in the list are ordered by\n   * creation date in ascending order, though this can be modified via the\n   * order_by field.\n   *\n   * @param request - The request {@link ListUsersRequest}\n   * @returns A Promise of ListUsersResponse\n   */\n  listUsers = request => enrichForPagination('users', this.pageOfListUsers, request);\n\n  /**\n   * Create a user for a Database Instance. Create a new user for a Database\n   * Instance. You must define the `name`, `password` and `is_admin`\n   * parameters.\n   *\n   * @param request - The request {@link CreateUserRequest}\n   * @returns A Promise of User\n   */\n  createUser = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateUserRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/users`\n  }, unmarshalUser);\n\n  /**\n   * Update a user on a Database Instance. Update the parameters of a user on a\n   * Database Instance. You can update the `password` and `is_admin` parameters,\n   * but you cannot change the name of the user.\n   *\n   * @param request - The request {@link UpdateUserRequest}\n   * @returns A Promise of User\n   */\n  updateUser = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateUserRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'PATCH',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/users/${validatePathParam('name', request.name)}`\n  }, unmarshalUser);\n\n  /**\n   * Delete a user on a Database Instance. Delete a given user on a Database\n   * Instance. You must specify, in the endpoint, the `region`, `instance_id`\n   * and `name` parameters of the user you want to delete.\n   *\n   * @param request - The request {@link DeleteUserRequest}\n   */\n  deleteUser = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/users/${validatePathParam('name', request.name)}`\n  });\n  pageOfListDatabases = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/databases`,\n    urlParams: urlParams(['managed', request.managed], ['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['owner', request.owner], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListDatabasesResponse);\n\n  /**\n   * List databases in a Database Instance. List all databases of a given\n   * Database Instance. By default, the databases returned in the list are\n   * ordered by creation date in ascending order, though this can be modified\n   * via the order_by field. You can define additional parameters for your\n   * query, such as `name`, `managed` and `owner`.\n   *\n   * @param request - The request {@link ListDatabasesRequest}\n   * @returns A Promise of ListDatabasesResponse\n   */\n  listDatabases = request => enrichForPagination('databases', this.pageOfListDatabases, request);\n\n  /**\n   * Create a database in a Database Instance. Create a new database. You must\n   * define the `name` parameter in the request.\n   *\n   * @param request - The request {@link CreateDatabaseRequest}\n   * @returns A Promise of Database\n   */\n  createDatabase = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDatabaseRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/databases`\n  }, unmarshalDatabase);\n\n  /**\n   * Delete a database in a Database Instance. Delete a given database on a\n   * Database Instance. You must specify, in the endpoint, the `region`,\n   * `instance_id` and `name` parameters of the database you want to delete.\n   *\n   * @param request - The request {@link DeleteDatabaseRequest}\n   */\n  deleteDatabase = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/databases/${validatePathParam('name', request.name)}`\n  });\n  pageOfListPrivileges = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/privileges`,\n    urlParams: urlParams(['database_name', request.databaseName], ['order_by', request.orderBy ?? 'user_name_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['user_name', request.userName])\n  }, unmarshalListPrivilegesResponse);\n\n  /**\n   * List user privileges for a database. List privileges of a user on a\n   * database. By default, the details returned in the list are ordered by\n   * creation date in ascending order, though this can be modified via the\n   * order_by field. You can define additional parameters for your query, such\n   * as `database_name` and `user_name`.\n   *\n   * @param request - The request {@link ListPrivilegesRequest}\n   * @returns A Promise of ListPrivilegesResponse\n   */\n  listPrivileges = request => enrichForPagination('privileges', this.pageOfListPrivileges, request);\n\n  /**\n   * Set user privileges for a database. Set the privileges of a user on a\n   * database. You must define `database_name`, `user_name` and `permission` in\n   * the request body.\n   *\n   * @param request - The request {@link SetPrivilegeRequest}\n   * @returns A Promise of Privilege\n   */\n  setPrivilege = request => this.client.fetch({\n    body: JSON.stringify(marshalSetPrivilegeRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'PUT',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/privileges`\n  }, unmarshalPrivilege);\n  pageOfListSnapshots = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/snapshots`,\n    urlParams: urlParams(['instance_id', request.instanceId], ['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListSnapshotsResponse);\n\n  /**\n   * List snapshots. List snapshots. You can include the `instance_id` or\n   * `project_id` in your query to get the list of snapshots for specific\n   * Database Instances and/or Projects. By default, the details returned in the\n   * list are ordered by creation date in ascending order, though this can be\n   * modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListSnapshotsRequest}\n   * @returns A Promise of ListSnapshotsResponse\n   */\n  listSnapshots = (request = {}) => enrichForPagination('snapshots', this.pageOfListSnapshots, request);\n\n  /**\n   * Get a Database Instance snapshot. Retrieve information about a given\n   * snapshot, specified by its `snapshot_id` and `region`. Full details about\n   * the snapshot, like size and expiration date, are returned in the response.\n   *\n   * @param request - The request {@link GetSnapshotRequest}\n   * @returns A Promise of Snapshot\n   */\n  getSnapshot = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}`\n  }, unmarshalSnapshot);\n\n  /**\n   * Waits for {@link Snapshot} to be in a final state.\n   *\n   * @param request - The request {@link GetSnapshotRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Snapshot\n   */\n  waitForSnapshot = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!SNAPSHOT_TRANSIENT_STATUSES.includes(res.status))), this.getSnapshot, request, options);\n\n  /**\n   * Create a Database Instance snapshot. Create a new snapshot of a Database\n   * Instance. You must define the `name` parameter in the request.\n   *\n   * @param request - The request {@link CreateSnapshotRequest}\n   * @returns A Promise of Snapshot\n   */\n  createSnapshot = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSnapshotRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/snapshots`\n  }, unmarshalSnapshot);\n\n  /**\n   * Update a Database Instance snapshot. Update the parameters of a snapshot of\n   * a Database Instance. You can update the `name` and `expires_at`\n   * parameters.\n   *\n   * @param request - The request {@link UpdateSnapshotRequest}\n   * @returns A Promise of Snapshot\n   */\n  updateSnapshot = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateSnapshotRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'PATCH',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}`\n  }, unmarshalSnapshot);\n\n  /**\n   * Delete a Database Instance snapshot. Delete a given snapshot of a Database\n   * Instance. You must specify, in the endpoint, the `region` and `snapshot_id`\n   * parameters of the snapshot you want to delete.\n   *\n   * @param request - The request {@link DeleteSnapshotRequest}\n   * @returns A Promise of Snapshot\n   */\n  deleteSnapshot = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}`\n  }, unmarshalSnapshot);\n\n  /**\n   * Create a new Database Instance from a snapshot. Restore a snapshot. When\n   * you restore a snapshot, a new Instance is created and billed to your\n   * account. Note that is possible to select a larger node type for your new\n   * Database Instance. However, the Block volume size will be the same as the\n   * size of the restored snapshot. All Instance settings will be restored if\n   * you chose a node type with the same or more memory size than the initial\n   * Instance. Settings will be reset to the default if your node type has less\n   * memory.\n   *\n   * @param request - The request {@link CreateInstanceFromSnapshotRequest}\n   * @returns A Promise of Instance\n   */\n  createInstanceFromSnapshot = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateInstanceFromSnapshotRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/snapshots/${validatePathParam('snapshotId', request.snapshotId)}/create-instance`\n  }, unmarshalInstance);\n\n  /**\n   * Create a new Database Instance endpoint. Create a new endpoint for a\n   * Database Instance. You can add `load_balancer` and `private_network`\n   * specifications to the body of the request. Note that this action replaces\n   * your current endpoint, which means you might need to update any environment\n   * configurations that point to the old endpoint.\n   *\n   * @param request - The request {@link CreateEndpointRequest}\n   * @returns A Promise of Endpoint\n   */\n  createEndpoint = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateEndpointRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/instances/${validatePathParam('instanceId', request.instanceId)}/endpoints`\n  }, unmarshalEndpoint$1);\n\n  /**\n   * Delete a Database Instance endpoint. Delete the endpoint of a Database\n   * Instance. You must specify the `region` and `endpoint_id` parameters of the\n   * endpoint you want to delete. Note that might need to update any environment\n   * configurations that point to the deleted endpoint.\n   *\n   * @param request - The request {@link DeleteEndpointRequest}\n   */\n  deleteEndpoint = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/endpoints/${validatePathParam('endpointId', request.endpointId)}`\n  });\n\n  /**\n   * Get a Database Instance endpoint. Retrieve information about a Database\n   * Instance endpoint. Full details about the endpoint, like `ip`, `port`,\n   * `private_network` and `load_balancer` specifications are returned in the\n   * response.\n   *\n   * @param request - The request {@link GetEndpointRequest}\n   * @returns A Promise of Endpoint\n   */\n  getEndpoint = request => this.client.fetch({\n    method: 'GET',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/endpoints/${validatePathParam('endpointId', request.endpointId)}`\n  }, unmarshalEndpoint$1);\n\n  /**\n   * Migrate an existing instance endpoint to another instance.\n   *\n   * @param request - The request {@link MigrateEndpointRequest}\n   * @returns A Promise of Endpoint\n   */\n  migrateEndpoint = request => this.client.fetch({\n    body: JSON.stringify(marshalMigrateEndpointRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$8,\n    method: 'POST',\n    path: `/rdb/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/endpoints/${validatePathParam('endpointId', request.endpointId)}/migrate`\n  }, unmarshalEndpoint$1);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$8 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$8,\n  DATABASE_BACKUP_TRANSIENT_STATUSES: DATABASE_BACKUP_TRANSIENT_STATUSES,\n  INSTANCE_LOG_TRANSIENT_STATUSES: INSTANCE_LOG_TRANSIENT_STATUSES,\n  INSTANCE_TRANSIENT_STATUSES: INSTANCE_TRANSIENT_STATUSES,\n  MAINTENANCE_TRANSIENT_STATUSES: MAINTENANCE_TRANSIENT_STATUSES,\n  READ_REPLICA_TRANSIENT_STATUSES: READ_REPLICA_TRANSIENT_STATUSES,\n  SNAPSHOT_TRANSIENT_STATUSES: SNAPSHOT_TRANSIENT_STATUSES\n});\n\nvar index$8 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$8\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link ClusterStatus}. */\nconst CLUSTER_TRANSIENT_STATUSES = ['provisioning', 'configuring', 'deleting', 'autohealing', 'initializing'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalPrivateNetwork$1 = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrivateNetwork' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    serviceIps: data.service_ips,\n    zone: data.zone\n  };\n};\nconst unmarshalPublicNetwork = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PublicNetwork' failed as data isn't a dictionary.`);\n  }\n  return {};\n};\nconst unmarshalACLRule = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ACLRule' failed as data isn't a dictionary.`);\n  }\n  return {\n    description: data.description,\n    id: data.id,\n    ipCidr: data.ip_cidr\n  };\n};\nconst unmarshalAvailableClusterSetting = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AvailableClusterSetting' failed as data isn't a dictionary.`);\n  }\n  return {\n    defaultValue: data.default_value,\n    deprecated: data.deprecated,\n    description: data.description,\n    maxValue: data.max_value,\n    minValue: data.min_value,\n    name: data.name,\n    regex: data.regex,\n    type: data.type\n  };\n};\nconst unmarshalClusterSetting = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClusterSetting' failed as data isn't a dictionary.`);\n  }\n  return {\n    name: data.name,\n    value: data.value\n  };\n};\nconst unmarshalEndpoint = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Endpoint' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    ips: data.ips,\n    port: data.port,\n    privateNetwork: data.private_network ? unmarshalPrivateNetwork$1(data.private_network) : undefined,\n    publicNetwork: data.public_network ? unmarshalPublicNetwork(data.public_network) : undefined\n  };\n};\nconst unmarshalCluster = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Cluster' failed as data isn't a dictionary.`);\n  }\n  return {\n    aclRules: unmarshalArrayOfObject(data.acl_rules, unmarshalACLRule),\n    clusterSettings: unmarshalArrayOfObject(data.cluster_settings, unmarshalClusterSetting),\n    clusterSize: data.cluster_size,\n    createdAt: unmarshalDate(data.created_at),\n    endpoints: unmarshalArrayOfObject(data.endpoints, unmarshalEndpoint),\n    id: data.id,\n    name: data.name,\n    nodeType: data.node_type,\n    projectId: data.project_id,\n    status: data.status,\n    tags: data.tags,\n    tlsEnabled: data.tls_enabled,\n    updatedAt: unmarshalDate(data.updated_at),\n    upgradableVersions: data.upgradable_versions,\n    userName: data.user_name,\n    version: data.version,\n    zone: data.zone\n  };\n};\nconst unmarshalClusterVersion = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClusterVersion' failed as data isn't a dictionary.`);\n  }\n  return {\n    availableSettings: unmarshalArrayOfObject(data.available_settings, unmarshalAvailableClusterSetting),\n    endOfLifeAt: unmarshalDate(data.end_of_life_at),\n    logoUrl: data.logo_url,\n    version: data.version,\n    zone: data.zone\n  };\n};\nconst unmarshalNodeType = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'NodeType' failed as data isn't a dictionary.`);\n  }\n  return {\n    beta: data.beta,\n    description: data.description,\n    disabled: data.disabled,\n    memory: data.memory,\n    name: data.name,\n    stockStatus: data.stock_status,\n    vcpus: data.vcpus,\n    zone: data.zone\n  };\n};\nconst unmarshalAddAclRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AddAclRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    aclRules: unmarshalArrayOfObject(data.acl_rules, unmarshalACLRule),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalAddEndpointsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AddEndpointsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    endpoints: unmarshalArrayOfObject(data.endpoints, unmarshalEndpoint),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalClusterMetricsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClusterMetricsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    timeseries: unmarshalArrayOfObject(data.timeseries, unmarshalTimeSeries)\n  };\n};\nconst unmarshalClusterSettingsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ClusterSettingsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    settings: unmarshalArrayOfObject(data.settings, unmarshalClusterSetting)\n  };\n};\nconst unmarshalListClusterVersionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListClusterVersionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    versions: unmarshalArrayOfObject(data.versions, unmarshalClusterVersion)\n  };\n};\nconst unmarshalListClustersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListClustersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    clusters: unmarshalArrayOfObject(data.clusters, unmarshalCluster),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNodeTypesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNodeTypesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    nodeTypes: unmarshalArrayOfObject(data.node_types, unmarshalNodeType),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalSetAclRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetAclRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    aclRules: unmarshalArrayOfObject(data.acl_rules, unmarshalACLRule)\n  };\n};\nconst unmarshalSetEndpointsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetEndpointsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    endpoints: unmarshalArrayOfObject(data.endpoints, unmarshalEndpoint)\n  };\n};\nconst marshalEndpointSpecPrivateNetworkSpecIpamConfig = (request, defaults) => ({});\nconst marshalEndpointSpecPrivateNetworkSpec = (request, defaults) => ({\n  id: request.id,\n  ipam_config: request.ipamConfig ? marshalEndpointSpecPrivateNetworkSpecIpamConfig(request.ipamConfig) : undefined,\n  service_ips: request.serviceIps\n});\nconst marshalEndpointSpecPublicNetworkSpec = (request, defaults) => ({});\nconst marshalACLRuleSpec = (request, defaults) => ({\n  description: request.description,\n  ip_cidr: request.ipCidr\n});\nconst marshalClusterSetting = (request, defaults) => ({\n  name: request.name,\n  value: request.value\n});\nconst marshalEndpointSpec = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'private_network',\n    value: request.privateNetwork ? marshalEndpointSpecPrivateNetworkSpec(request.privateNetwork) : undefined\n  }, {\n    param: 'public_network',\n    value: request.publicNetwork ? marshalEndpointSpecPublicNetworkSpec(request.publicNetwork) : undefined\n  }])\n});\nconst marshalAddAclRulesRequest = (request, defaults) => ({\n  acl_rules: request.aclRules.map(elt => marshalACLRuleSpec(elt))\n});\nconst marshalAddClusterSettingsRequest = (request, defaults) => ({\n  settings: request.settings.map(elt => marshalClusterSetting(elt))\n});\nconst marshalAddEndpointsRequest = (request, defaults) => ({\n  endpoints: request.endpoints.map(elt => marshalEndpointSpec(elt))\n});\nconst marshalCreateClusterRequest = (request, defaults) => ({\n  acl_rules: request.aclRules ? request.aclRules.map(elt => marshalACLRuleSpec(elt)) : undefined,\n  cluster_settings: request.clusterSettings ? request.clusterSettings.map(elt => marshalClusterSetting(elt)) : undefined,\n  cluster_size: request.clusterSize,\n  endpoints: request.endpoints ? request.endpoints.map(elt => marshalEndpointSpec(elt)) : undefined,\n  name: request.name || randomName('ins'),\n  node_type: request.nodeType,\n  password: request.password,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  tags: request.tags,\n  tls_enabled: request.tlsEnabled,\n  user_name: request.userName,\n  version: request.version\n});\nconst marshalMigrateClusterRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'version',\n    value: request.version\n  }, {\n    param: 'node_type',\n    value: request.nodeType\n  }, {\n    param: 'cluster_size',\n    value: request.clusterSize\n  }])\n});\nconst marshalSetAclRulesRequest = (request, defaults) => ({\n  acl_rules: request.aclRules.map(elt => marshalACLRuleSpec(elt))\n});\nconst marshalSetClusterSettingsRequest = (request, defaults) => ({\n  settings: request.settings.map(elt => marshalClusterSetting(elt))\n});\nconst marshalSetEndpointsRequest = (request, defaults) => ({\n  endpoints: request.endpoints.map(elt => marshalEndpointSpec(elt))\n});\nconst marshalUpdateClusterRequest = (request, defaults) => ({\n  name: request.name,\n  password: request.password,\n  tags: request.tags,\n  user_name: request.userName\n});\nconst marshalUpdateEndpointRequest = (request, defaults) => ({\n  ...resolveOneOf([{\n    param: 'private_network',\n    value: request.privateNetwork ? marshalEndpointSpecPrivateNetworkSpec(request.privateNetwork) : undefined\n  }, {\n    param: 'public_network',\n    value: request.publicNetwork ? marshalEndpointSpecPublicNetworkSpec(request.publicNetwork) : undefined\n  }])\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$7 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Managed Database for Redis™ API. */\nlet API$7 = class API extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-1', 'fr-par-2', 'nl-ams-1', 'nl-ams-2', 'pl-waw-1', 'pl-waw-2'];\n\n  /**\n   * Create a Redis™ Database Instance. Create a new Redis™ Database Instance\n   * (Redis™ cluster). You must set the `zone`, `project_id`, `version`,\n   * `node_type`, `user_name` and `password` parameters. Optionally you can\n   * define `acl_rules`, `endpoints`, `tls_enabled` and `cluster_settings`.\n   *\n   * @param request - The request {@link CreateClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  createCluster = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateClusterRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'POST',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters`\n  }, unmarshalCluster);\n\n  /**\n   * Update a Redis™ Database Instance. Update the parameters of a Redis™\n   * Database Instance (Redis™ cluster), including `name`, `tags`, `user_name`\n   * and `password`.\n   *\n   * @param request - The request {@link UpdateClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  updateCluster = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateClusterRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'PATCH',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}`\n  }, unmarshalCluster);\n\n  /**\n   * Get a Redis™ Database Instance. Retrieve information about a Redis™\n   * Database Instance (Redis™ cluster). Specify the `cluster_id` and `region`\n   * in your request to get information such as `id`, `status`, `version`,\n   * `tls_enabled`, `cluster_settings`, `upgradable_versions` and `endpoints`\n   * about your cluster in the response.\n   *\n   * @param request - The request {@link GetClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  getCluster = request => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}`\n  }, unmarshalCluster);\n\n  /**\n   * Waits for {@link Cluster} to be in a final state.\n   *\n   * @param request - The request {@link GetClusterRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Cluster\n   */\n  waitForCluster = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!CLUSTER_TRANSIENT_STATUSES.includes(res.status))), this.getCluster, request, options);\n  pageOfListClusters = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['tags', request.tags], ['version', request.version])\n  }, unmarshalListClustersResponse);\n\n  /**\n   * List Redis™ Database Instances. List all Redis™ Database Instances (Redis™\n   * cluster) in the specified zone. By default, the Database Instances returned\n   * in the list are ordered by creation date in ascending order, though this\n   * can be modified via the order_by field. You can define additional\n   * parameters for your query, such as `tags`, `name`, `organization_id` and\n   * `version`.\n   *\n   * @param request - The request {@link ListClustersRequest}\n   * @returns A Promise of ListClustersResponse\n   */\n  listClusters = (request = {}) => enrichForPagination('clusters', this.pageOfListClusters, request);\n\n  /**\n   * Scale up a Redis™ Database Instance. Upgrade your standalone Redis™\n   * Database Instance node, either by upgrading to a bigger node type (vertical\n   * scaling) or by adding more nodes to your Database Instance to increase your\n   * number of endpoints and distribute cache (horizontal scaling). Note that\n   * scaling horizontally your Redis™ Database Instance will not renew its TLS\n   * certificate. In order to refresh the TLS certificate, you must use the\n   * Renew TLS certificate endpoint.\n   *\n   * @param request - The request {@link MigrateClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  migrateCluster = request => this.client.fetch({\n    body: JSON.stringify(marshalMigrateClusterRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'POST',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/migrate`\n  }, unmarshalCluster);\n\n  /**\n   * Delete a Redis™ Database Instance. Delete a Redis™ Database Instance\n   * (Redis™ cluster), specified by the `region` and `cluster_id` parameters.\n   * Deleting a Database Instance is permanent, and cannot be undone. Note that\n   * upon deletion all your data will be lost.\n   *\n   * @param request - The request {@link DeleteClusterRequest}\n   * @returns A Promise of Cluster\n   */\n  deleteCluster = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}`\n  }, unmarshalCluster);\n\n  /**\n   * Get metrics of a Redis™ Database Instance. Retrieve the metrics of a Redis™\n   * Database Instance (Redis™ cluster). You can define the period from which to\n   * retrieve metrics by specifying the `start_date` and `end_date`.\n   *\n   * @param request - The request {@link GetClusterMetricsRequest}\n   * @returns A Promise of ClusterMetricsResponse\n   */\n  getClusterMetrics = request => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/metrics`,\n    urlParams: urlParams(['end_at', request.endAt], ['metric_name', request.metricName], ['start_at', request.startAt])\n  }, unmarshalClusterMetricsResponse);\n  pageOfListNodeTypes = request => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/node-types`,\n    urlParams: urlParams(['include_disabled_types', request.includeDisabledTypes], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListNodeTypesResponse);\n\n  /**\n   * List available node types. List all available node types. By default, the\n   * node types returned in the list are ordered by creation date in ascending\n   * order, though this can be modified via the `order_by` field.\n   *\n   * @param request - The request {@link ListNodeTypesRequest}\n   * @returns A Promise of ListNodeTypesResponse\n   */\n  listNodeTypes = request => enrichForPagination('nodeTypes', this.pageOfListNodeTypes, request);\n  pageOfListClusterVersions = request => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/cluster-versions`,\n    urlParams: urlParams(['include_beta', request.includeBeta], ['include_deprecated', request.includeDeprecated], ['include_disabled', request.includeDisabled], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['version', request.version])\n  }, unmarshalListClusterVersionsResponse);\n\n  /**\n   * List available Redis™ versions. List the Redis™ database engine versions\n   * available. You can define additional parameters for your query, such as\n   * `include_disabled`, `include_beta`, `include_deprecated` and `version`.\n   *\n   * @param request - The request {@link ListClusterVersionsRequest}\n   * @returns A Promise of ListClusterVersionsResponse\n   */\n  listClusterVersions = request => enrichForPagination('versions', this.pageOfListClusterVersions, request);\n\n  /**\n   * Get the TLS certificate of a cluster. Retrieve information about the TLS\n   * certificate of a Redis™ Database Instance (Redis™ cluster). Details like\n   * name and content are returned in the response.\n   *\n   * @param request - The request {@link GetClusterCertificateRequest}\n   * @returns A Promise of Blob\n   */\n  getClusterCertificate = request => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/certificate`,\n    urlParams: urlParams(['dl', 1]),\n    responseType: 'blob'\n  });\n\n  /**\n   * Renew the TLS certificate of a cluster. Renew a TLS certificate for a\n   * Redis™ Database Instance (Redis™ cluster). Renewing a certificate means\n   * that you will not be able to connect to your Database Instance using the\n   * previous certificate. You will also need to download and update the new\n   * certificate for all database clients.\n   *\n   * @param request - The request {@link RenewClusterCertificateRequest}\n   * @returns A Promise of Cluster\n   */\n  renewClusterCertificate = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$7,\n    method: 'POST',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/renew-certificate`\n  }, unmarshalCluster);\n\n  /**\n   * Add advanced settings. Add an advanced setting to a Redis™ Database\n   * Instance (Redis™ cluster). You must set the `name` and the `value` of each\n   * setting.\n   *\n   * @param request - The request {@link AddClusterSettingsRequest}\n   * @returns A Promise of ClusterSettingsResponse\n   */\n  addClusterSettings = request => this.client.fetch({\n    body: JSON.stringify(marshalAddClusterSettingsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'POST',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/settings`\n  }, unmarshalClusterSettingsResponse);\n\n  /**\n   * Delete advanced setting. Delete an advanced setting in a Redis™ Database\n   * Instance (Redis™ cluster). You must specify the names of the settings you\n   * want to delete in the request body.\n   *\n   * @param request - The request {@link DeleteClusterSettingRequest}\n   * @returns A Promise of Cluster\n   */\n  deleteClusterSetting = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/settings/${validatePathParam('settingName', request.settingName)}`\n  }, unmarshalCluster);\n\n  /**\n   * Set advanced settings. Update an advanced setting for a Redis™ Database\n   * Instance (Redis™ cluster). Settings added upon database engine\n   * initalization can only be defined once, and cannot, therefore, be updated.\n   *\n   * @param request - The request {@link SetClusterSettingsRequest}\n   * @returns A Promise of ClusterSettingsResponse\n   */\n  setClusterSettings = request => this.client.fetch({\n    body: JSON.stringify(marshalSetClusterSettingsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'PUT',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/settings`\n  }, unmarshalClusterSettingsResponse);\n\n  /**\n   * Set ACL rules for a cluster. Replace all the ACL rules of a Redis™ Database\n   * Instance (Redis™ cluster).\n   *\n   * @param request - The request {@link SetAclRulesRequest}\n   * @returns A Promise of SetAclRulesResponse\n   */\n  setAclRules = request => this.client.fetch({\n    body: JSON.stringify(marshalSetAclRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'PUT',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/acls`\n  }, unmarshalSetAclRulesResponse);\n\n  /**\n   * Add ACL rules for a cluster. Add an additional ACL rule to a Redis™\n   * Database Instance (Redis™ cluster).\n   *\n   * @param request - The request {@link AddAclRulesRequest}\n   * @returns A Promise of AddAclRulesResponse\n   */\n  addAclRules = request => this.client.fetch({\n    body: JSON.stringify(marshalAddAclRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'POST',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/acls`\n  }, unmarshalAddAclRulesResponse);\n\n  /**\n   * Delete an ACL rule for a cluster. Delete an ACL rule of a Redis™ Database\n   * Instance (Redis™ cluster). You must specify the `acl_id` of the rule you\n   * want to delete in your request.\n   *\n   * @param request - The request {@link DeleteAclRuleRequest}\n   * @returns A Promise of Cluster\n   */\n  deleteAclRule = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/acls/${validatePathParam('aclId', request.aclId)}`\n  }, unmarshalCluster);\n\n  /**\n   * Get an ACL rule. Retrieve information about an ACL rule of a Redis™\n   * Database Instance (Redis™ cluster). You must specify the `acl_id` of the\n   * rule in your request.\n   *\n   * @param request - The request {@link GetAclRuleRequest}\n   * @returns A Promise of ACLRule\n   */\n  getAclRule = request => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/acls/${validatePathParam('aclId', request.aclId)}`\n  }, unmarshalACLRule);\n\n  /**\n   * Set endpoints for a cluster. Update an endpoint for a Redis™ Database\n   * Instance (Redis™ cluster). You must specify the `cluster_id` and the\n   * `endpoints` parameters in your request.\n   *\n   * @param request - The request {@link SetEndpointsRequest}\n   * @returns A Promise of SetEndpointsResponse\n   */\n  setEndpoints = request => this.client.fetch({\n    body: JSON.stringify(marshalSetEndpointsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'PUT',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/endpoints`\n  }, unmarshalSetEndpointsResponse);\n\n  /**\n   * Add endpoints for a cluster. Add a new endpoint for a Redis™ Database\n   * Instance (Redis™ cluster). You can add `private_network` or\n   * `public_network` specifications to the body of the request.\n   *\n   * @param request - The request {@link AddEndpointsRequest}\n   * @returns A Promise of AddEndpointsResponse\n   */\n  addEndpoints = request => this.client.fetch({\n    body: JSON.stringify(marshalAddEndpointsRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'POST',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/clusters/${validatePathParam('clusterId', request.clusterId)}/endpoints`\n  }, unmarshalAddEndpointsResponse);\n\n  /**\n   * Delete an endpoint for a cluster. Delete the endpoint of a Redis™ Database\n   * Instance (Redis™ cluster). You must specify the `region` and `endpoint_id`\n   * parameters of the endpoint you want to delete. Note that might need to\n   * update any environment configurations that point to the deleted endpoint.\n   *\n   * @param request - The request {@link DeleteEndpointRequest}\n   * @returns A Promise of Cluster\n   */\n  deleteEndpoint = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/endpoints/${validatePathParam('endpointId', request.endpointId)}`\n  }, unmarshalCluster);\n\n  /**\n   * Get an endpoint. Retrieve information about a Redis™ Database Instance\n   * (Redis™ cluster) endpoint. Full details about the endpoint, like `ips`,\n   * `port`, `private_network` and `public_network` specifications are returned\n   * in the response.\n   *\n   * @param request - The request {@link GetEndpointRequest}\n   * @returns A Promise of Endpoint\n   */\n  getEndpoint = request => this.client.fetch({\n    method: 'GET',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/endpoints/${validatePathParam('endpointId', request.endpointId)}`\n  }, unmarshalEndpoint);\n\n  /**\n   * Update an endpoint. Update information about a Redis™ Database Instance\n   * (Redis™ cluster) endpoint. Full details about the endpoint, like `ips`,\n   * `port`, `private_network` and `public_network` specifications are returned\n   * in the response.\n   *\n   * @param request - The request {@link UpdateEndpointRequest}\n   * @returns A Promise of Endpoint\n   */\n  updateEndpoint = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateEndpointRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$7,\n    method: 'PATCH',\n    path: `/redis/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/endpoints/${validatePathParam('endpointId', request.endpointId)}`\n  }, unmarshalEndpoint);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$7 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$7,\n  CLUSTER_TRANSIENT_STATUSES: CLUSTER_TRANSIENT_STATUSES\n});\n\nvar index$7 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$7\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link ImageStatus}. */\nconst IMAGE_TRANSIENT_STATUSES = ['deleting'];\n\n/** Lists transient statutes of the enum {@link NamespaceStatus}. */\nconst NAMESPACE_TRANSIENT_STATUSES = ['deleting'];\n\n/** Lists transient statutes of the enum {@link TagStatus}. */\nconst TAG_TRANSIENT_STATUSES = ['deleting'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalImage = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Image' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    name: data.name,\n    namespaceId: data.namespace_id,\n    size: data.size,\n    status: data.status,\n    statusMessage: data.status_message,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    visibility: data.visibility\n  };\n};\nconst unmarshalNamespace = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Namespace' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    endpoint: data.endpoint,\n    id: data.id,\n    imageCount: data.image_count,\n    isPublic: data.is_public,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    region: data.region,\n    size: data.size,\n    status: data.status,\n    statusMessage: data.status_message,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalTag = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Tag' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    digest: data.digest,\n    id: data.id,\n    imageId: data.image_id,\n    name: data.name,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalListImagesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    images: unmarshalArrayOfObject(data.images, unmarshalImage),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListNamespacesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    namespaces: unmarshalArrayOfObject(data.namespaces, unmarshalNamespace),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListTagsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListTagsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    tags: unmarshalArrayOfObject(data.tags, unmarshalTag),\n    totalCount: data.total_count\n  };\n};\nconst marshalCreateNamespaceRequest = (request, defaults) => ({\n  description: request.description,\n  is_public: request.isPublic,\n  name: request.name || randomName('ns'),\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalUpdateImageRequest = (request, defaults) => ({\n  visibility: request.visibility ?? 'visibility_unknown'\n});\nconst marshalUpdateNamespaceRequest = (request, defaults) => ({\n  description: request.description,\n  is_public: request.isPublic\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$6 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Container Registry API. */\nlet API$6 = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par', 'nl-ams', 'pl-waw'];\n  pageOfListNamespaces = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListNamespacesResponse);\n\n  /**\n   * List namespaces. List all namespaces in a specified region. By default, the\n   * namespaces listed are ordered by creation date in ascending order. This can\n   * be modified via the order_by field. You can also define additional\n   * parameters for your query, such as the `instance_id` and `project_id`\n   * parameters.\n   *\n   * @param request - The request {@link ListNamespacesRequest}\n   * @returns A Promise of ListNamespacesResponse\n   */\n  listNamespaces = (request = {}) => enrichForPagination('namespaces', this.pageOfListNamespaces, request);\n\n  /**\n   * Get a namespace. Retrieve information about a given namespace, specified by\n   * its `namespace_id` and region. Full details about the namespace, such as\n   * `description`, `project_id`, `status`, `endpoint`, `is_public`, `size`, and\n   * `image_count` are returned in the response.\n   *\n   * @param request - The request {@link GetNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  getNamespace = request => this.client.fetch({\n    method: 'GET',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace);\n\n  /**\n   * Waits for {@link Namespace} to be in a final state.\n   *\n   * @param request - The request {@link GetNamespaceRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Namespace\n   */\n  waitForNamespace = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!NAMESPACE_TRANSIENT_STATUSES.includes(res.status))), this.getNamespace, request, options);\n\n  /**\n   * Create a namespace. Create a new Container Registry namespace. You must\n   * specify the namespace name and region in which you want it to be created.\n   * Optionally, you can specify the `project_id` and `is_public` in the request\n   * payload.\n   *\n   * @param request - The request {@link CreateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  createNamespace = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateNamespaceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$6,\n    method: 'POST',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces`\n  }, unmarshalNamespace);\n\n  /**\n   * Update a namespace. Update the parameters of a given namespace, specified\n   * by its `namespace_id` and `region`. You can update the `description` and\n   * `is_public` parameters.\n   *\n   * @param request - The request {@link UpdateNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  updateNamespace = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateNamespaceRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$6,\n    method: 'PATCH',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace);\n\n  /**\n   * Delete a namespace. Delete a given namespace. You must specify, in the\n   * endpoint, the `region` and `namespace_id` parameters of the namespace you\n   * want to delete.\n   *\n   * @param request - The request {@link DeleteNamespaceRequest}\n   * @returns A Promise of Namespace\n   */\n  deleteNamespace = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/namespaces/${validatePathParam('namespaceId', request.namespaceId)}`\n  }, unmarshalNamespace);\n  pageOfListImages = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/images`,\n    urlParams: urlParams(['name', request.name], ['namespace_id', request.namespaceId], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListImagesResponse);\n\n  /**\n   * List images. List all images in a specified region. By default, the images\n   * listed are ordered by creation date in ascending order. This can be\n   * modified via the order_by field. You can also define additional parameters\n   * for your query, such as the `namespace_id` and `project_id` parameters.\n   *\n   * @param request - The request {@link ListImagesRequest}\n   * @returns A Promise of ListImagesResponse\n   */\n  listImages = (request = {}) => enrichForPagination('images', this.pageOfListImages, request);\n\n  /**\n   * Get an image. Retrieve information about a given container image, specified\n   * by its `image_id` and region. Full details about the image, such as `name`,\n   * `namespace_id`, `status`, `visibility`, and `size` are returned in the\n   * response.\n   *\n   * @param request - The request {@link GetImageRequest}\n   * @returns A Promise of Image\n   */\n  getImage = request => this.client.fetch({\n    method: 'GET',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/images/${validatePathParam('imageId', request.imageId)}`\n  }, unmarshalImage);\n\n  /**\n   * Waits for {@link Image} to be in a final state.\n   *\n   * @param request - The request {@link GetImageRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Image\n   */\n  waitForImage = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!IMAGE_TRANSIENT_STATUSES.includes(res.status))), this.getImage, request, options);\n\n  /**\n   * Update an image. Update the parameters of a given image, specified by its\n   * `image_id` and `region`. You can update the `visibility` parameter.\n   *\n   * @param request - The request {@link UpdateImageRequest}\n   * @returns A Promise of Image\n   */\n  updateImage = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateImageRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$6,\n    method: 'PATCH',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/images/${validatePathParam('imageId', request.imageId)}`\n  }, unmarshalImage);\n\n  /**\n   * Delete an image. Delete a given image. You must specify, in the endpoint,\n   * the `region` and `image_id` parameters of the image you want to delete.\n   *\n   * @param request - The request {@link DeleteImageRequest}\n   * @returns A Promise of Image\n   */\n  deleteImage = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/images/${validatePathParam('imageId', request.imageId)}`\n  }, unmarshalImage);\n  pageOfListTags = request => this.client.fetch({\n    method: 'GET',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/images/${validatePathParam('imageId', request.imageId)}/tags`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize])\n  }, unmarshalListTagsResponse);\n\n  /**\n   * List tags. List all tags for a given image, specified by region. By\n   * default, the tags listed are ordered by creation date in ascending order.\n   * This can be modified via the order_by field. You can also define additional\n   * parameters for your query, such as the `name`.\n   *\n   * @param request - The request {@link ListTagsRequest}\n   * @returns A Promise of ListTagsResponse\n   */\n  listTags = request => enrichForPagination('tags', this.pageOfListTags, request);\n\n  /**\n   * Get a tag. Retrieve information about a given image tag, specified by its\n   * `tag_id` and region. Full details about the tag, such as `name`,\n   * `image_id`, `status`, and `digest` are returned in the response.\n   *\n   * @param request - The request {@link GetTagRequest}\n   * @returns A Promise of Tag\n   */\n  getTag = request => this.client.fetch({\n    method: 'GET',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tags/${validatePathParam('tagId', request.tagId)}`\n  }, unmarshalTag);\n\n  /**\n   * Waits for {@link Tag} to be in a final state.\n   *\n   * @param request - The request {@link GetTagRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Tag\n   */\n  waitForTag = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!TAG_TRANSIENT_STATUSES.includes(res.status))), this.getTag, request, options);\n\n  /**\n   * Delete a tag. Delete a given image tag. You must specify, in the endpoint,\n   * the `region` and `tag_id` parameters of the tag you want to delete.\n   *\n   * @param request - The request {@link DeleteTagRequest}\n   * @returns A Promise of Tag\n   */\n  deleteTag = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/registry/v1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/tags/${validatePathParam('tagId', request.tagId)}`,\n    urlParams: urlParams(['force', request.force])\n  }, unmarshalTag);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$6 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$6,\n  IMAGE_TRANSIENT_STATUSES: IMAGE_TRANSIENT_STATUSES,\n  NAMESPACE_TRANSIENT_STATUSES: NAMESPACE_TRANSIENT_STATUSES,\n  TAG_TRANSIENT_STATUSES: TAG_TRANSIENT_STATUSES\n});\n\nvar index$6 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$6\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalSecret = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Secret' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    id: data.id,\n    isManaged: data.is_managed,\n    name: data.name,\n    projectId: data.project_id,\n    region: data.region,\n    status: data.status,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    versionCount: data.version_count\n  };\n};\nconst unmarshalSecretVersion = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SecretVersion' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    description: data.description,\n    isLatest: data.is_latest,\n    revision: data.revision,\n    secretId: data.secret_id,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalAccessSecretVersionResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'AccessSecretVersionResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    data: data.data,\n    dataCrc32: data.data_crc32,\n    revision: data.revision,\n    secretId: data.secret_id\n  };\n};\nconst unmarshalListSecretVersionsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSecretVersionsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    totalCount: data.total_count,\n    versions: unmarshalArrayOfObject(data.versions, unmarshalSecretVersion)\n  };\n};\nconst unmarshalListSecretsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListSecretsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    secrets: unmarshalArrayOfObject(data.secrets, unmarshalSecret),\n    totalCount: data.total_count\n  };\n};\nconst marshalPasswordGenerationParams = (request, defaults) => ({\n  additional_chars: request.additionalChars,\n  length: request.length,\n  no_digits: request.noDigits,\n  no_lowercase_letters: request.noLowercaseLetters,\n  no_uppercase_letters: request.noUppercaseLetters\n});\nconst marshalAddSecretOwnerRequest = (request, defaults) => ({\n  product_name: request.productName\n});\nconst marshalCreateSecretRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  tags: request.tags\n});\nconst marshalCreateSecretVersionRequest = (request, defaults) => ({\n  data: request.data,\n  data_crc32: request.dataCrc32,\n  description: request.description,\n  disable_previous: request.disablePrevious,\n  ...resolveOneOf([{\n    param: 'password_generation',\n    value: request.passwordGeneration ? marshalPasswordGenerationParams(request.passwordGeneration) : undefined\n  }])\n});\nconst marshalUpdateSecretRequest = (request, defaults) => ({\n  description: request.description,\n  name: request.name,\n  tags: request.tags\n});\nconst marshalUpdateSecretVersionRequest = (request, defaults) => ({\n  description: request.description\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$5 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Secret Manager API.\n *\n * Secret Manager API. This API allows you to conveniently store, access and\n * share sensitive data.\n */\nlet API$5 = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par'];\n\n  /**\n   * Create a secret. You must sepcify the `region` to create a secret.\n   *\n   * @param request - The request {@link CreateSecretRequest}\n   * @returns A Promise of Secret\n   */\n  createSecret = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSecretRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$5,\n    method: 'POST',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets`\n  }, unmarshalSecret);\n\n  /**\n   * Get metadata using the secret's name. Retrieve the metadata of a secret\n   * specified by the `region` and the `secret_name` parameters.\n   *\n   * @param request - The request {@link GetSecretRequest}\n   * @returns A Promise of Secret\n   */\n  getSecret = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}`\n  }, unmarshalSecret);\n\n  /**\n   * Get metadata using the secret's ID. Retrieve the metadata of a secret\n   * specified by the `region` and the `secret_id` parameters.\n   *\n   * @param request - The request {@link GetSecretByNameRequest}\n   * @returns A Promise of Secret\n   */\n  getSecretByName = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets-by-name/${validatePathParam('secretName', request.secretName)}`\n  }, unmarshalSecret);\n\n  /**\n   * Update metadata of a secret. Edit a secret's metadata such as name, tag(s)\n   * and description. The secret to update is specified by the `secret_id` and\n   * `region` parameters.\n   *\n   * @param request - The request {@link UpdateSecretRequest}\n   * @returns A Promise of Secret\n   */\n  updateSecret = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateSecretRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$5,\n    method: 'PATCH',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}`\n  }, unmarshalSecret);\n  pageOfListSecrets = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets`,\n    urlParams: urlParams(['is_managed', request.isManaged], ['name', request.name], ['order_by', request.orderBy ?? 'name_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['tags', request.tags])\n  }, unmarshalListSecretsResponse);\n\n  /**\n   * List secrets. Retrieve the list of secrets created within an Organization\n   * and/or Project. You must specify either the `organization_id` or the\n   * `project_id` and the `region`.\n   *\n   * @param request - The request {@link ListSecretsRequest}\n   * @returns A Promise of ListSecretsResponse\n   */\n  listSecrets = (request = {}) => enrichForPagination('secrets', this.pageOfListSecrets, request);\n\n  /**\n   * Delete a secret. Delete a given secret specified by the `region` and\n   * `secret_id` parameters.\n   *\n   * @param request - The request {@link DeleteSecretRequest}\n   */\n  deleteSecret = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}`\n  });\n\n  /**\n   * Allow a product to use the secret.\n   *\n   * @param request - The request {@link AddSecretOwnerRequest}\n   */\n  addSecretOwner = request => this.client.fetch({\n    body: JSON.stringify(marshalAddSecretOwnerRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$5,\n    method: 'POST',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/add-owner`\n  });\n\n  /**\n   * Create a version. Create a version of a given secret specified by the\n   * `region` and `secret_id` parameters.\n   *\n   * @param request - The request {@link CreateSecretVersionRequest}\n   * @returns A Promise of SecretVersion\n   */\n  createSecretVersion = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateSecretVersionRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$5,\n    method: 'POST',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions`\n  }, unmarshalSecretVersion);\n\n  /**\n   * Get metadata of a secret's version using the secret's ID. Retrieve the\n   * metadata of a secret's given version specified by the `region`, `secret_id`\n   * and `revision` parameters.\n   *\n   * @param request - The request {@link GetSecretVersionRequest}\n   * @returns A Promise of SecretVersion\n   */\n  getSecretVersion = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions/${validatePathParam('revision', request.revision)}`\n  }, unmarshalSecretVersion);\n\n  /**\n   * Get metadata of a secret's version using the secret's name. Retrieve the\n   * metadata of a secret's given version specified by the `region`,\n   * `secret_name` and `revision` parameters.\n   *\n   * @param request - The request {@link GetSecretVersionByNameRequest}\n   * @returns A Promise of SecretVersion\n   */\n  getSecretVersionByName = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets-by-name/${validatePathParam('secretName', request.secretName)}/versions/${validatePathParam('revision', request.revision)}`\n  }, unmarshalSecretVersion);\n\n  /**\n   * Update metadata of a version. Edit the metadata of a secret's given\n   * version, specified by the `region`, `secret_id` and `revision` parameters.\n   *\n   * @param request - The request {@link UpdateSecretVersionRequest}\n   * @returns A Promise of SecretVersion\n   */\n  updateSecretVersion = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateSecretVersionRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$5,\n    method: 'PATCH',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions/${validatePathParam('revision', request.revision)}`\n  }, unmarshalSecretVersion);\n  pageOfListSecretVersions = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['status', request.status])\n  }, unmarshalListSecretVersionsResponse);\n\n  /**\n   * List versions of a secret using the secret's ID. Retrieve the list of a\n   * given secret's versions specified by the `secret_id` and `region`\n   * parameters.\n   *\n   * @param request - The request {@link ListSecretVersionsRequest}\n   * @returns A Promise of ListSecretVersionsResponse\n   */\n  listSecretVersions = request => enrichForPagination('versions', this.pageOfListSecretVersions, request);\n  pageOfListSecretVersionsByName = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets-by-name/${validatePathParam('secretName', request.secretName)}/versions`,\n    urlParams: urlParams(['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['status', request.status])\n  }, unmarshalListSecretVersionsResponse);\n\n  /**\n   * List versions of a secret using the secret's name. Retrieve the list of a\n   * given secret's versions specified by the `secret_name` and `region`\n   * parameters.\n   *\n   * @param request - The request {@link ListSecretVersionsByNameRequest}\n   * @returns A Promise of ListSecretVersionsResponse\n   */\n  listSecretVersionsByName = request => enrichForPagination('versions', this.pageOfListSecretVersionsByName, request);\n\n  /**\n   * Enable a version. Make a specific version accessible. You must specify the\n   * `region`, `secret_id` and `revision` parameters.\n   *\n   * @param request - The request {@link EnableSecretVersionRequest}\n   * @returns A Promise of SecretVersion\n   */\n  enableSecretVersion = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$5,\n    method: 'POST',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions/${validatePathParam('revision', request.revision)}/enable`\n  }, unmarshalSecretVersion);\n\n  /**\n   * Disable a version. Make a specific version inaccessible. You must specify\n   * the `region`, `secret_id` and `revision` parameters.\n   *\n   * @param request - The request {@link DisableSecretVersionRequest}\n   * @returns A Promise of SecretVersion\n   */\n  disableSecretVersion = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$5,\n    method: 'POST',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions/${validatePathParam('revision', request.revision)}/disable`\n  }, unmarshalSecretVersion);\n\n  /**\n   * Access a secret's version using the secret's ID. Access sensitive data in a\n   * secret's version specified by the `region`, `secret_id` and `revision`\n   * parameters.\n   *\n   * @param request - The request {@link AccessSecretVersionRequest}\n   * @returns A Promise of AccessSecretVersionResponse\n   */\n  accessSecretVersion = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions/${validatePathParam('revision', request.revision)}/access`\n  }, unmarshalAccessSecretVersionResponse);\n\n  /**\n   * Access a secret's version using the secret's name. Access sensitive data in\n   * a secret's version specified by the `region`, `secret_name` and `revision`\n   * parameters.\n   *\n   * @param request - The request {@link AccessSecretVersionByNameRequest}\n   * @returns A Promise of AccessSecretVersionResponse\n   */\n  accessSecretVersionByName = request => this.client.fetch({\n    method: 'GET',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets-by-name/${validatePathParam('secretName', request.secretName)}/versions/${validatePathParam('revision', request.revision)}/access`\n  }, unmarshalAccessSecretVersionResponse);\n\n  /**\n   * Delete a version. Delete a secret's version and the sensitive data\n   * contained in it. Deleting a version is permanent and cannot be undone.\n   *\n   * @param request - The request {@link DestroySecretVersionRequest}\n   * @returns A Promise of SecretVersion\n   */\n  destroySecretVersion = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$5,\n    method: 'POST',\n    path: `/secret-manager/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/secrets/${validatePathParam('secretId', request.secretId)}/versions/${validatePathParam('revision', request.revision)}/destroy`\n  }, unmarshalSecretVersion);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$5 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$5\n});\n\nvar index$5 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1alpha1: index_gen$5\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link HumanStatus}. */\nconst HUMAN_TRANSIENT_STATUSES = ['running'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalHuman = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Human' failed as data isn't a dictionary.`);\n  }\n  return {\n    altitudeInMeter: data.altitude_in_meter,\n    altitudeInMillimeter: data.altitude_in_millimeter,\n    createdAt: unmarshalDate(data.created_at),\n    eyesColor: data.eyes_color,\n    fingersCount: data.fingers_count,\n    hairCount: data.hair_count,\n    height: data.height,\n    id: data.id,\n    isHappy: data.is_happy,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    shoeSize: data.shoe_size,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalListHumansResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListHumansResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    humans: unmarshalArrayOfObject(data.humans, unmarshalHuman),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalRegisterResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'RegisterResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    accessKey: data.access_key,\n    secretKey: data.secret_key\n  };\n};\nconst marshalCreateHumanRequest = (request, defaults) => ({\n  altitude_in_meter: request.altitudeInMeter,\n  altitude_in_millimeter: request.altitudeInMillimeter,\n  eyes_color: request.eyesColor ?? 'unknown',\n  fingers_count: request.fingersCount,\n  hair_count: request.hairCount,\n  height: request.height,\n  is_happy: request.isHappy,\n  name: request.name,\n  shoe_size: request.shoeSize,\n  ...resolveOneOf([{\n    default: defaults.defaultProjectId,\n    param: 'project_id',\n    value: request.projectId\n  }, {\n    default: defaults.defaultOrganizationId,\n    param: 'organization_id',\n    value: request.organizationId\n  }])\n});\nconst marshalRegisterRequest = (request, defaults) => ({\n  username: request.username\n});\nconst marshalUpdateHumanRequest = (request, defaults) => ({\n  altitude_in_meter: request.altitudeInMeter,\n  altitude_in_millimeter: request.altitudeInMillimeter,\n  eyes_color: request.eyesColor ?? 'unknown',\n  fingers_count: request.fingersCount,\n  hair_count: request.hairCount,\n  height: request.height,\n  is_happy: request.isHappy,\n  name: request.name,\n  shoe_size: request.shoeSize\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$4 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/**\n * Fake API.\n *\n * No Auth Service for end-to-end testing. Test is a fake service that aim to\n * manage fake humans. It is used for internal and public end-to-end tests.\n *\n * This service don't use the Scaleway authentication service but a fake one. It\n * allows to use this test service publicly without requiring a Scaleway\n * account.\n *\n * First, you need to register a user with `scw test human register` to get an\n * access-key. Then, you can use other test commands by setting the\n * SCW_SECRET_KEY env variable.\n */\nlet API$4 = class API extends API$q {\n  /**\n   * Register a user. Register a human and return a access-key and a secret-key\n   * that must be used in all other commands.\n   *\n   * Hint: you can use other test commands by setting the SCW_SECRET_KEY env\n   * variable.\n   *\n   * @param request - The request {@link RegisterRequest}\n   * @returns A Promise of RegisterResponse\n   */\n  register = request => this.client.fetch({\n    body: JSON.stringify(marshalRegisterRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$4,\n    method: 'POST',\n    path: `/test/v1/register`\n  }, unmarshalRegisterResponse);\n  pageOfListHumans = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/test/v1/humans`,\n    urlParams: urlParams(['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListHumansResponse);\n\n  /**\n   * List all your humans.\n   *\n   * @param request - The request {@link ListHumansRequest}\n   * @returns A Promise of ListHumansResponse\n   */\n  listHumans = (request = {}) => enrichForPagination('humans', this.pageOfListHumans, request);\n\n  /**\n   * Get human details. Get the human details associated with the given id.\n   *\n   * @param request - The request {@link GetHumanRequest}\n   * @returns A Promise of Human\n   */\n  getHuman = request => this.client.fetch({\n    method: 'GET',\n    path: `/test/v1/humans/${validatePathParam('humanId', request.humanId)}`\n  }, unmarshalHuman);\n\n  /**\n   * Waits for {@link Human} to be in a final state.\n   *\n   * @param request - The request {@link GetHumanRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Human\n   */\n  waitForHuman = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!HUMAN_TRANSIENT_STATUSES.includes(res.status))), this.getHuman, request, options);\n\n  /**\n   * Create a new human.\n   *\n   * @param request - The request {@link CreateHumanRequest}\n   * @returns A Promise of Human\n   */\n  createHuman = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateHumanRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$4,\n    method: 'POST',\n    path: `/test/v1/humans`\n  }, unmarshalHuman);\n\n  /**\n   * Update an existing human. Update the human associated with the given id.\n   *\n   * @param request - The request {@link UpdateHumanRequest}\n   * @returns A Promise of Human\n   */\n  updateHuman = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateHumanRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$4,\n    method: 'PATCH',\n    path: `/test/v1/humans/${validatePathParam('humanId', request.humanId)}`\n  }, unmarshalHuman);\n\n  /**\n   * Delete an existing human. Delete the human associated with the given id.\n   *\n   * @param request - The request {@link DeleteHumanRequest}\n   * @returns A Promise of Human\n   */\n  deleteHuman = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/test/v1/humans/${validatePathParam('humanId', request.humanId)}`\n  }, unmarshalHuman);\n\n  /**\n   * Start a 1h running for the given human. Start a one hour running for the\n   * given human.\n   *\n   * @param request - The request {@link RunHumanRequest}\n   * @returns A Promise of Human\n   */\n  runHuman = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$4,\n    method: 'POST',\n    path: `/test/v1/humans/${validatePathParam('humanId', request.humanId)}/run`\n  }, unmarshalHuman);\n\n  /**\n   * Make a human smoke.\n   *\n   * @deprecated\n   * @param request - The request {@link SmokeHumanRequest}\n   * @returns A Promise of Human\n   */\n  smokeHuman = (request = {}) => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$4,\n    method: 'POST',\n    path: `/test/v1/humans/${validatePathParam('humanId', request.humanId)}/smoke`\n  }, unmarshalHuman);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$4 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$4,\n  HUMAN_TRANSIENT_STATUSES: HUMAN_TRANSIENT_STATUSES\n});\n\nvar index$4 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$4\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link DomainStatus}. */\nconst DOMAIN_TRANSIENT_STATUSES = ['pending'];\n\n/** Lists transient statutes of the enum {@link EmailStatus}. */\nconst EMAIL_TRANSIENT_STATUSES = ['new', 'sending'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalDomainStatistics = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DomainStatistics' failed as data isn't a dictionary.`);\n  }\n  return {\n    canceledCount: data.canceled_count,\n    failedCount: data.failed_count,\n    sentCount: data.sent_count,\n    totalCount: data.total_count\n  };\n};\nconst unmarshalEmailTry = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'EmailTry' failed as data isn't a dictionary.`);\n  }\n  return {\n    code: data.code,\n    message: data.message,\n    rank: data.rank,\n    triedAt: unmarshalDate(data.tried_at)\n  };\n};\nconst unmarshalDomain = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Domain' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    dkimConfig: data.dkim_config,\n    id: data.id,\n    lastError: data.last_error,\n    lastValidAt: unmarshalDate(data.last_valid_at),\n    name: data.name,\n    nextCheckAt: unmarshalDate(data.next_check_at),\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    region: data.region,\n    revokedAt: unmarshalDate(data.revoked_at),\n    spfConfig: data.spf_config,\n    statistics: data.statistics ? unmarshalDomainStatistics(data.statistics) : undefined,\n    status: data.status\n  };\n};\nconst unmarshalEmail = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Email' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    lastTries: unmarshalArrayOfObject(data.last_tries, unmarshalEmailTry),\n    mailFrom: data.mail_from,\n    messageId: data.message_id,\n    projectId: data.project_id,\n    rcptTo: data.rcpt_to,\n    rcptType: data.rcpt_type,\n    status: data.status,\n    statusDetails: data.status_details,\n    subject: data.subject,\n    tryCount: data.try_count,\n    updatedAt: unmarshalDate(data.updated_at)\n  };\n};\nconst unmarshalCreateEmailResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'CreateEmailResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    emails: unmarshalArrayOfObject(data.emails, unmarshalEmail)\n  };\n};\nconst unmarshalListDomainsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    domains: unmarshalArrayOfObject(data.domains, unmarshalDomain),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListEmailsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListEmailsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    emails: unmarshalArrayOfObject(data.emails, unmarshalEmail),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalStatistics = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Statistics' failed as data isn't a dictionary.`);\n  }\n  return {\n    canceledCount: data.canceled_count,\n    failedCount: data.failed_count,\n    newCount: data.new_count,\n    sendingCount: data.sending_count,\n    sentCount: data.sent_count,\n    totalCount: data.total_count\n  };\n};\nconst marshalCreateEmailRequestAddress = (request, defaults) => ({\n  email: request.email,\n  name: request.name\n});\nconst marshalCreateEmailRequestAttachment = (request, defaults) => ({\n  content: request.content,\n  name: request.name,\n  type: request.type\n});\nconst marshalCreateDomainRequest = (request, defaults) => ({\n  accept_tos: request.acceptTos,\n  domain_name: request.domainName,\n  project_id: request.projectId ?? defaults.defaultProjectId\n});\nconst marshalCreateEmailRequest = (request, defaults) => ({\n  attachments: request.attachments ? request.attachments.map(elt => marshalCreateEmailRequestAttachment(elt)) : undefined,\n  bcc: request.bcc ? request.bcc.map(elt => marshalCreateEmailRequestAddress(elt)) : undefined,\n  cc: request.cc ? request.cc.map(elt => marshalCreateEmailRequestAddress(elt)) : undefined,\n  from: request.from ? marshalCreateEmailRequestAddress(request.from) : undefined,\n  html: request.html,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  send_before: request.sendBefore,\n  subject: request.subject,\n  text: request.text,\n  to: request.to ? request.to.map(elt => marshalCreateEmailRequestAddress(elt)) : undefined\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$3 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Transactional Email API. */\nlet API$3 = class API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par'];\n\n  /**\n   * Send an email. You must specify the `region`, the sender and the\n   * recipient's information and the `project_id` to send an email from a\n   * checked domain. The subject of the email must contain at least 6\n   * characters.\n   *\n   * @param request - The request {@link CreateEmailRequest}\n   * @returns A Promise of CreateEmailResponse\n   */\n  createEmail = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateEmailRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$3,\n    method: 'POST',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/emails`\n  }, unmarshalCreateEmailResponse);\n\n  /**\n   * Get an email. Retrieve information about a specific email using the\n   * `email_id` and `region` parameters.\n   *\n   * @param request - The request {@link GetEmailRequest}\n   * @returns A Promise of Email\n   */\n  getEmail = request => this.client.fetch({\n    method: 'GET',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/emails/${validatePathParam('emailId', request.emailId)}`\n  }, unmarshalEmail);\n\n  /**\n   * Waits for {@link Email} to be in a final state.\n   *\n   * @param request - The request {@link GetEmailRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Email\n   */\n  waitForEmail = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!EMAIL_TRANSIENT_STATUSES.includes(res.status))), this.getEmail, request, options);\n  pageOfListEmails = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/emails`,\n    urlParams: urlParams(['domain_id', request.domainId], ['mail_from', request.mailFrom], ['mail_to', request.mailTo], ['message_id', request.messageId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['since', request.since], ['statuses', request.statuses], ['subject', request.subject], ['until', request.until])\n  }, unmarshalListEmailsResponse);\n\n  /**\n   * List emails. Retrieve the list of emails sent from a specific domain or for\n   * a specific Project or Organization. You must specify the `region`.\n   *\n   * @param request - The request {@link ListEmailsRequest}\n   * @returns A Promise of ListEmailsResponse\n   */\n  listEmails = (request = {}) => enrichForPagination('emails', this.pageOfListEmails, request);\n\n  /**\n   * Email statuses. Get information on your emails' statuses.\n   *\n   * @param request - The request {@link GetStatisticsRequest}\n   * @returns A Promise of Statistics\n   */\n  getStatistics = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/statistics`,\n    urlParams: urlParams(['domain_id', request.domainId], ['mail_from', request.mailFrom], ['project_id', request.projectId], ['since', request.since], ['until', request.until])\n  }, unmarshalStatistics);\n\n  /**\n   * Cancel an email. You can cancel the sending of an email if it has not been\n   * sent yet. You must specify the `region` and the `email_id` of the email you\n   * want to cancel.\n   *\n   * @param request - The request {@link CancelEmailRequest}\n   * @returns A Promise of Email\n   */\n  cancelEmail = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$3,\n    method: 'POST',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/emails/${validatePathParam('emailId', request.emailId)}/cancel`\n  }, unmarshalEmail);\n\n  /**\n   * Register a domain in a project. You must specify the `region`, `project_id`\n   * and `domain_name` to register a domain in a specific Project.\n   *\n   * @param request - The request {@link CreateDomainRequest}\n   * @returns A Promise of Domain\n   */\n  createDomain = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDomainRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$3,\n    method: 'POST',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains`\n  }, unmarshalDomain);\n\n  /**\n   * Get information about a domain. Retrieve information about a specific\n   * domain using the `region` and `domain_id` parameters.\n   *\n   * @param request - The request {@link GetDomainRequest}\n   * @returns A Promise of Domain\n   */\n  getDomain = request => this.client.fetch({\n    method: 'GET',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domainId', request.domainId)}`\n  }, unmarshalDomain);\n\n  /**\n   * Waits for {@link Domain} to be in a final state.\n   *\n   * @param request - The request {@link GetDomainRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Domain\n   */\n  waitForDomain = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!DOMAIN_TRANSIENT_STATUSES.includes(res.status))), this.getDomain, request, options);\n  pageOfListDomains = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains`,\n    urlParams: urlParams(['name', request.name], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['status', request.status])\n  }, unmarshalListDomainsResponse);\n\n  /**\n   * List domains. Retrieve domains in a specific project or in a specific\n   * Organization using the `region` parameter.\n   *\n   * @param request - The request {@link ListDomainsRequest}\n   * @returns A Promise of ListDomainsResponse\n   */\n  listDomains = (request = {}) => enrichForPagination('domains', this.pageOfListDomains, request);\n\n  /**\n   * Delete a domain. You must specify the domain you want to delete by the\n   * `region` and `domain_id`. Deleting a domain is permanent and cannot be\n   * undone.\n   *\n   * @param request - The request {@link RevokeDomainRequest}\n   * @returns A Promise of Domain\n   */\n  revokeDomain = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$3,\n    method: 'POST',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domainId', request.domainId)}/revoke`\n  }, unmarshalDomain);\n\n  /**\n   * Domain DNS check. Perform an immediate DNS check of a domain using the\n   * `region` and `domain_id` parameters.\n   *\n   * @param request - The request {@link CheckDomainRequest}\n   * @returns A Promise of Domain\n   */\n  checkDomain = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$3,\n    method: 'POST',\n    path: `/transactional-email/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domainId', request.domainId)}/check`\n  }, unmarshalDomain);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$3,\n  DOMAIN_TRANSIENT_STATUSES: DOMAIN_TRANSIENT_STATUSES,\n  EMAIL_TRANSIENT_STATUSES: EMAIL_TRANSIENT_STATUSES\n});\n\nvar index$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1alpha1: index_gen$3\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalPrivateNetwork = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PrivateNetwork' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    id: data.id,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    subnets: data.subnets,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalListPrivateNetworksResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPrivateNetworksResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    privateNetworks: unmarshalArrayOfObject(data.private_networks, unmarshalPrivateNetwork),\n    totalCount: data.total_count\n  };\n};\nconst marshalCreatePrivateNetworkRequest = (request, defaults) => ({\n  name: request.name || randomName('pn'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  subnets: request.subnets,\n  tags: request.tags\n});\nconst marshalUpdatePrivateNetworkRequest = (request, defaults) => ({\n  name: request.name,\n  subnets: request.subnets,\n  tags: request.tags\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$2 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** VPC API. */\nlet API$2 = class API extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-1', 'fr-par-2', 'fr-par-3', 'nl-ams-1', 'nl-ams-2', 'pl-waw-1', 'pl-waw-2'];\n  pageOfListPrivateNetworks = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/private-networks`,\n    urlParams: urlParams(['include_regional', request.includeRegional], ['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['private_network_ids', request.privateNetworkIds], ['project_id', request.projectId], ['tags', request.tags])\n  }, unmarshalListPrivateNetworksResponse);\n\n  /**\n   * List Private Networks. List existing Private Networks in a specified\n   * Availability Zone. By default, the Private Networks returned in the list\n   * are ordered by creation date in ascending order, though this can be\n   * modified via the order_by field.\n   *\n   * @param request - The request {@link ListPrivateNetworksRequest}\n   * @returns A Promise of ListPrivateNetworksResponse\n   */\n  listPrivateNetworks = (request = {}) => enrichForPagination('privateNetworks', this.pageOfListPrivateNetworks, request);\n\n  /**\n   * Create a Private Network. Create a new Private Network. Once created, you\n   * can attach Scaleway resources in the same Availability Zone.\n   *\n   * @param request - The request {@link CreatePrivateNetworkRequest}\n   * @returns A Promise of PrivateNetwork\n   */\n  createPrivateNetwork = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreatePrivateNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$2,\n    method: 'POST',\n    path: `/vpc/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/private-networks`\n  }, unmarshalPrivateNetwork);\n\n  /**\n   * Get a Private Network. Retrieve information about an existing Private\n   * Network, specified by its Private Network ID. Its full details are returned\n   * in the response object.\n   *\n   * @param request - The request {@link GetPrivateNetworkRequest}\n   * @returns A Promise of PrivateNetwork\n   */\n  getPrivateNetwork = request => this.client.fetch({\n    method: 'GET',\n    path: `/vpc/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}`\n  }, unmarshalPrivateNetwork);\n\n  /**\n   * Update Private Network. Update parameters (such as name or tags) of an\n   * existing Private Network, specified by its Private Network ID.\n   *\n   * @param request - The request {@link UpdatePrivateNetworkRequest}\n   * @returns A Promise of PrivateNetwork\n   */\n  updatePrivateNetwork = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdatePrivateNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$2,\n    method: 'PATCH',\n    path: `/vpc/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}`\n  }, unmarshalPrivateNetwork);\n\n  /**\n   * Delete a Private Network. Delete an existing Private Network. Note that you\n   * must first detach all resources from the network, in order to delete it.\n   *\n   * @param request - The request {@link DeletePrivateNetworkRequest}\n   */\n  deletePrivateNetwork = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/vpc/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/private-networks/${validatePathParam('privateNetworkId', request.privateNetworkId)}`\n  });\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$2\n});\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$2\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link GatewayNetworkStatus}. */\nconst GATEWAY_NETWORK_TRANSIENT_STATUSES = ['attaching', 'configuring', 'detaching'];\n\n/** Lists transient statutes of the enum {@link GatewayStatus}. */\nconst GATEWAY_TRANSIENT_STATUSES = ['allocating', 'configuring', 'stopping', 'deleting'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalDHCP = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DHCP' failed as data isn't a dictionary.`);\n  }\n  return {\n    address: data.address,\n    createdAt: unmarshalDate(data.created_at),\n    dnsLocalName: data.dns_local_name,\n    dnsSearch: data.dns_search,\n    dnsServersOverride: data.dns_servers_override,\n    enableDynamic: data.enable_dynamic,\n    id: data.id,\n    organizationId: data.organization_id,\n    poolHigh: data.pool_high,\n    poolLow: data.pool_low,\n    projectId: data.project_id,\n    pushDefaultRoute: data.push_default_route,\n    pushDnsServer: data.push_dns_server,\n    rebindTimer: data.rebind_timer,\n    renewTimer: data.renew_timer,\n    subnet: data.subnet,\n    updatedAt: unmarshalDate(data.updated_at),\n    validLifetime: data.valid_lifetime,\n    zone: data.zone\n  };\n};\nconst unmarshalGatewayNetwork = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GatewayNetwork' failed as data isn't a dictionary.`);\n  }\n  return {\n    address: data.address,\n    createdAt: unmarshalDate(data.created_at),\n    dhcp: data.dhcp ? unmarshalDHCP(data.dhcp) : undefined,\n    enableDhcp: data.enable_dhcp,\n    enableMasquerade: data.enable_masquerade,\n    gatewayId: data.gateway_id,\n    id: data.id,\n    macAddress: data.mac_address,\n    privateNetworkId: data.private_network_id,\n    status: data.status,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalGatewayType = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'GatewayType' failed as data isn't a dictionary.`);\n  }\n  return {\n    bandwidth: data.bandwidth,\n    name: data.name,\n    zone: data.zone\n  };\n};\nconst unmarshalIP = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'IP' failed as data isn't a dictionary.`);\n  }\n  return {\n    address: data.address,\n    createdAt: unmarshalDate(data.created_at),\n    gatewayId: data.gateway_id,\n    id: data.id,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    reverse: data.reverse,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalDHCPEntry = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DHCPEntry' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    gatewayNetworkId: data.gateway_network_id,\n    hostname: data.hostname,\n    id: data.id,\n    ipAddress: data.ip_address,\n    macAddress: data.mac_address,\n    type: data.type,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalGateway = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Gateway' failed as data isn't a dictionary.`);\n  }\n  return {\n    bastionEnabled: data.bastion_enabled,\n    bastionPort: data.bastion_port,\n    canUpgradeTo: data.can_upgrade_to,\n    createdAt: unmarshalDate(data.created_at),\n    gatewayNetworks: unmarshalArrayOfObject(data.gateway_networks, unmarshalGatewayNetwork),\n    id: data.id,\n    ip: data.ip ? unmarshalIP(data.ip) : undefined,\n    name: data.name,\n    organizationId: data.organization_id,\n    projectId: data.project_id,\n    smtpEnabled: data.smtp_enabled,\n    status: data.status,\n    tags: data.tags,\n    type: data.type ? unmarshalGatewayType(data.type) : undefined,\n    updatedAt: unmarshalDate(data.updated_at),\n    upstreamDnsServers: data.upstream_dns_servers,\n    version: data.version,\n    zone: data.zone\n  };\n};\nconst unmarshalPATRule = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'PATRule' failed as data isn't a dictionary.`);\n  }\n  return {\n    createdAt: unmarshalDate(data.created_at),\n    gatewayId: data.gateway_id,\n    id: data.id,\n    privateIp: data.private_ip,\n    privatePort: data.private_port,\n    protocol: data.protocol,\n    publicPort: data.public_port,\n    updatedAt: unmarshalDate(data.updated_at),\n    zone: data.zone\n  };\n};\nconst unmarshalListDHCPEntriesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDHCPEntriesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    dhcpEntries: unmarshalArrayOfObject(data.dhcp_entries, unmarshalDHCPEntry),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListDHCPsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListDHCPsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    dhcps: unmarshalArrayOfObject(data.dhcps, unmarshalDHCP),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListGatewayNetworksResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListGatewayNetworksResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    gatewayNetworks: unmarshalArrayOfObject(data.gateway_networks, unmarshalGatewayNetwork),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListGatewayTypesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListGatewayTypesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    types: unmarshalArrayOfObject(data.types, unmarshalGatewayType)\n  };\n};\nconst unmarshalListGatewaysResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListGatewaysResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    gateways: unmarshalArrayOfObject(data.gateways, unmarshalGateway),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListIPsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListIPsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    ips: unmarshalArrayOfObject(data.ips, unmarshalIP),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListPATRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListPATRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    patRules: unmarshalArrayOfObject(data.pat_rules, unmarshalPATRule),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalSetDHCPEntriesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetDHCPEntriesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    dhcpEntries: unmarshalArrayOfObject(data.dhcp_entries, unmarshalDHCPEntry)\n  };\n};\nconst unmarshalSetPATRulesResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'SetPATRulesResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    patRules: unmarshalArrayOfObject(data.pat_rules, unmarshalPATRule)\n  };\n};\nconst marshalCreateDHCPRequest = (request, defaults) => ({\n  address: request.address,\n  dns_local_name: request.dnsLocalName,\n  dns_search: request.dnsSearch,\n  dns_servers_override: request.dnsServersOverride,\n  enable_dynamic: request.enableDynamic,\n  pool_high: request.poolHigh,\n  pool_low: request.poolLow,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  push_default_route: request.pushDefaultRoute,\n  push_dns_server: request.pushDnsServer,\n  rebind_timer: request.rebindTimer,\n  renew_timer: request.renewTimer,\n  subnet: request.subnet,\n  valid_lifetime: request.validLifetime\n});\nconst marshalSetDHCPEntriesRequestEntry = (request, defaults) => ({\n  ip_address: request.ipAddress,\n  mac_address: request.macAddress\n});\nconst marshalSetPATRulesRequestRule = (request, defaults) => ({\n  private_ip: request.privateIp,\n  private_port: request.privatePort,\n  protocol: request.protocol,\n  public_port: request.publicPort\n});\nconst marshalCreateDHCPEntryRequest = (request, defaults) => ({\n  gateway_network_id: request.gatewayNetworkId,\n  ip_address: request.ipAddress,\n  mac_address: request.macAddress\n});\nconst marshalCreateGatewayNetworkRequest = (request, defaults) => ({\n  enable_dhcp: request.enableDhcp,\n  enable_masquerade: request.enableMasquerade,\n  gateway_id: request.gatewayId,\n  private_network_id: request.privateNetworkId,\n  ...resolveOneOf([{\n    param: 'dhcp_id',\n    value: request.dhcpId\n  }, {\n    param: 'dhcp',\n    value: request.dhcp ? marshalCreateDHCPRequest(request.dhcp, defaults) : undefined\n  }, {\n    param: 'address',\n    value: request.address\n  }])\n});\nconst marshalCreateGatewayRequest = (request, defaults) => ({\n  bastion_port: request.bastionPort,\n  enable_bastion: request.enableBastion,\n  enable_smtp: request.enableSmtp,\n  ip_id: request.ipId,\n  name: request.name || randomName('gw'),\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  tags: request.tags,\n  type: request.type,\n  upstream_dns_servers: request.upstreamDnsServers\n});\nconst marshalCreateIPRequest = (request, defaults) => ({\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  tags: request.tags\n});\nconst marshalCreatePATRuleRequest = (request, defaults) => ({\n  gateway_id: request.gatewayId,\n  private_ip: request.privateIp,\n  private_port: request.privatePort,\n  protocol: request.protocol ?? 'unknown',\n  public_port: request.publicPort\n});\nconst marshalSetDHCPEntriesRequest = (request, defaults) => ({\n  dhcp_entries: request.dhcpEntries ? request.dhcpEntries.map(elt => marshalSetDHCPEntriesRequestEntry(elt)) : undefined,\n  gateway_network_id: request.gatewayNetworkId\n});\nconst marshalSetPATRulesRequest = (request, defaults) => ({\n  gateway_id: request.gatewayId,\n  pat_rules: request.patRules.map(elt => marshalSetPATRulesRequestRule(elt))\n});\nconst marshalUpdateDHCPEntryRequest = (request, defaults) => ({\n  ip_address: request.ipAddress\n});\nconst marshalUpdateDHCPRequest = (request, defaults) => ({\n  address: request.address,\n  dns_local_name: request.dnsLocalName,\n  dns_search: request.dnsSearch,\n  dns_servers_override: request.dnsServersOverride,\n  enable_dynamic: request.enableDynamic,\n  pool_high: request.poolHigh,\n  pool_low: request.poolLow,\n  push_default_route: request.pushDefaultRoute,\n  push_dns_server: request.pushDnsServer,\n  rebind_timer: request.rebindTimer,\n  renew_timer: request.renewTimer,\n  subnet: request.subnet,\n  valid_lifetime: request.validLifetime\n});\nconst marshalUpdateGatewayNetworkRequest = (request, defaults) => ({\n  enable_dhcp: request.enableDhcp,\n  enable_masquerade: request.enableMasquerade,\n  ...resolveOneOf([{\n    param: 'dhcp_id',\n    value: request.dhcpId\n  }, {\n    param: 'address',\n    value: request.address\n  }])\n});\nconst marshalUpdateGatewayRequest = (request, defaults) => ({\n  bastion_port: request.bastionPort,\n  enable_bastion: request.enableBastion,\n  enable_smtp: request.enableSmtp,\n  name: request.name,\n  tags: request.tags,\n  upstream_dns_servers: request.upstreamDnsServers\n});\nconst marshalUpdateIPRequest = (request, defaults) => ({\n  gateway_id: request.gatewayId,\n  reverse: request.reverse,\n  tags: request.tags\n});\nconst marshalUpdatePATRuleRequest = (request, defaults) => ({\n  private_ip: request.privateIp,\n  private_port: request.privatePort,\n  protocol: request.protocol ?? 'unknown',\n  public_port: request.publicPort\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders$1 = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Public Gateways API. */\nlet API$1 = class API extends API$q {\n  /** Lists the available zones of the API. */\n  static LOCALITIES = ['fr-par-1', 'fr-par-2', 'nl-ams-1', 'nl-ams-2', 'pl-waw-1', 'pl-waw-2'];\n  pageOfListGateways = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateways`,\n    urlParams: urlParams(['name', request.name], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['private_network_id', request.privateNetworkId], ['project_id', request.projectId], ['status', request.status ?? 'unknown'], ['tags', request.tags], ['type', request.type])\n  }, unmarshalListGatewaysResponse);\n\n  /**\n   * List Public Gateways. List Public Gateways in a given Scaleway Organization\n   * or Project. By default, results are displayed in ascending order of\n   * creation date.\n   *\n   * @param request - The request {@link ListGatewaysRequest}\n   * @returns A Promise of ListGatewaysResponse\n   */\n  listGateways = (request = {}) => enrichForPagination('gateways', this.pageOfListGateways, request);\n\n  /**\n   * Get a Public Gateway. Get details of a Public Gateway, specified by its\n   * gateway ID. The response object contains full details of the gateway,\n   * including its **name**, **type**, **status** and more.\n   *\n   * @param request - The request {@link GetGatewayRequest}\n   * @returns A Promise of Gateway\n   */\n  getGateway = request => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateways/${validatePathParam('gatewayId', request.gatewayId)}`\n  }, unmarshalGateway);\n\n  /**\n   * Waits for {@link Gateway} to be in a final state.\n   *\n   * @param request - The request {@link GetGatewayRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Gateway\n   */\n  waitForGateway = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!GATEWAY_TRANSIENT_STATUSES.includes(res.status))), this.getGateway, request, options);\n\n  /**\n   * Create a Public Gateway. Create a new Public Gateway in the specified\n   * Scaleway Project, defining its **name**, **type** and other configuration\n   * details such as whether to enable SSH bastion.\n   *\n   * @param request - The request {@link CreateGatewayRequest}\n   * @returns A Promise of Gateway\n   */\n  createGateway = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateGatewayRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateways`\n  }, unmarshalGateway);\n\n  /**\n   * Update a Public Gateway. Update the parameters of an existing Public\n   * Gateway, for example, its **name**, **tags**, **SSH bastion\n   * configuration**, and **DNS servers**.\n   *\n   * @param request - The request {@link UpdateGatewayRequest}\n   * @returns A Promise of Gateway\n   */\n  updateGateway = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateGatewayRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PATCH',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateways/${validatePathParam('gatewayId', request.gatewayId)}`\n  }, unmarshalGateway);\n\n  /**\n   * Delete a Public Gateway. Delete an existing Public Gateway, specified by\n   * its gateway ID. This action is irreversible.\n   *\n   * @param request - The request {@link DeleteGatewayRequest}\n   */\n  deleteGateway = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateways/${validatePathParam('gatewayId', request.gatewayId)}`,\n    urlParams: urlParams(['cleanup_dhcp', request.cleanupDhcp])\n  });\n\n  /**\n   * Upgrade a Public Gateway to the latest version. Upgrade a given Public\n   * Gateway to the newest software version. This applies the latest bugfixes\n   * and features to your Public Gateway, but its service will be interrupted\n   * during the update.\n   *\n   * @param request - The request {@link UpgradeGatewayRequest}\n   * @returns A Promise of Gateway\n   */\n  upgradeGateway = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateways/${validatePathParam('gatewayId', request.gatewayId)}/upgrade`\n  }, unmarshalGateway);\n  pageOfListGatewayNetworks = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateway-networks`,\n    urlParams: urlParams(['dhcp_id', request.dhcpId], ['enable_masquerade', request.enableMasquerade], ['gateway_id', request.gatewayId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['private_network_id', request.privateNetworkId], ['status', request.status ?? 'unknown'])\n  }, unmarshalListGatewayNetworksResponse);\n\n  /**\n   * List Public Gateway connections to Private Networks. List the connections\n   * between Public Gateways and Private Networks (a connection = a\n   * GatewayNetwork). You can choose to filter by `gateway-id` to list all\n   * Private Networks attached to the specified Public Gateway, or by\n   * `private_network_id` to list all Public Gateways attached to the specified\n   * Private Network. Other query parameters are also available. The result is\n   * an array of GatewayNetwork objects, each giving details of the connection\n   * between a given Public Gateway and a given Private Network.\n   *\n   * @param request - The request {@link ListGatewayNetworksRequest}\n   * @returns A Promise of ListGatewayNetworksResponse\n   */\n  listGatewayNetworks = (request = {}) => enrichForPagination('gatewayNetworks', this.pageOfListGatewayNetworks, request);\n\n  /**\n   * Get a Public Gateway connection to a Private Network. Get details of a\n   * given connection between a Public Gateway and a Private Network (this\n   * connection = a GatewayNetwork), specified by its `gateway_network_id`. The\n   * response object contains details of the connection including the IDs of the\n   * Public Gateway and Private Network, the dates the connection was\n   * created/updated and its configuration settings.\n   *\n   * @param request - The request {@link GetGatewayNetworkRequest}\n   * @returns A Promise of GatewayNetwork\n   */\n  getGatewayNetwork = request => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateway-networks/${validatePathParam('gatewayNetworkId', request.gatewayNetworkId)}`\n  }, unmarshalGatewayNetwork);\n\n  /**\n   * Waits for {@link GatewayNetwork} to be in a final state.\n   *\n   * @param request - The request {@link GetGatewayNetworkRequest}\n   * @param options - The waiting options\n   * @returns A Promise of GatewayNetwork\n   */\n  waitForGatewayNetwork = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!GATEWAY_NETWORK_TRANSIENT_STATUSES.includes(res.status))), this.getGatewayNetwork, request, options);\n\n  /**\n   * Attach a Public Gateway to a Private Network. Attach a specific Public\n   * Gateway to a specific Private Network (create a GatewayNetwork). You can\n   * configure parameters for the connection including DHCP settings, whether to\n   * enable masquerade (dynamic NAT), and more.\n   *\n   * @param request - The request {@link CreateGatewayNetworkRequest}\n   * @returns A Promise of GatewayNetwork\n   */\n  createGatewayNetwork = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateGatewayNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateway-networks`\n  }, unmarshalGatewayNetwork);\n\n  /**\n   * Update a Public Gateway's connection to a Private Network. Update the\n   * configuration parameters of a connection between a given Public Gateway and\n   * Private Network (the connection = a GatewayNetwork). Updatable parameters\n   * include DHCP settings and whether to enable traffic masquerade (dynamic\n   * NAT).\n   *\n   * @param request - The request {@link UpdateGatewayNetworkRequest}\n   * @returns A Promise of GatewayNetwork\n   */\n  updateGatewayNetwork = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateGatewayNetworkRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PATCH',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateway-networks/${validatePathParam('gatewayNetworkId', request.gatewayNetworkId)}`\n  }, unmarshalGatewayNetwork);\n\n  /**\n   * Detach a Public Gateway from a Private Network. Detach a given Public\n   * Gateway from a given Private Network, i.e. delete a GatewayNetwork\n   * specified by a gateway_network_id.\n   *\n   * @param request - The request {@link DeleteGatewayNetworkRequest}\n   */\n  deleteGatewayNetwork = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateway-networks/${validatePathParam('gatewayNetworkId', request.gatewayNetworkId)}`,\n    urlParams: urlParams(['cleanup_dhcp', request.cleanupDhcp])\n  });\n  pageOfListDHCPs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcps`,\n    urlParams: urlParams(['address', request.address], ['has_address', request.hasAddress], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId])\n  }, unmarshalListDHCPsResponse);\n\n  /**\n   * List DHCP configurations. List DHCP configurations, optionally filtering by\n   * Organization, Project, Public Gateway IP address or more. The response is\n   * an array of DHCP configuration objects, each identified by a DHCP ID and\n   * containing configuration settings for the assignment of IP addresses to\n   * devices on a Private Network attached to a Public Gateway. Note that the\n   * response does not contain the IDs of any Private Network / Public Gateway\n   * the configuration is attached to. Use the `List Public Gateway connections\n   * to Private Networks` method for that purpose, filtering on DHCP ID.\n   *\n   * @param request - The request {@link ListDHCPsRequest}\n   * @returns A Promise of ListDHCPsResponse\n   */\n  listDHCPs = (request = {}) => enrichForPagination('dhcps', this.pageOfListDHCPs, request);\n\n  /**\n   * Get a DHCP configuration. Get a DHCP configuration object, identified by\n   * its DHCP ID. The response object contains configuration settings for the\n   * assignment of IP addresses to devices on a Private Network attached to a\n   * Public Gateway. Note that the response does not contain the IDs of any\n   * Private Network / Public Gateway the configuration is attached to. Use the\n   * `List Public Gateway connections to Private Networks` method for that\n   * purpose, filtering on DHCP ID.\n   *\n   * @param request - The request {@link GetDHCPRequest}\n   * @returns A Promise of DHCP\n   */\n  getDHCP = request => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcps/${validatePathParam('dhcpId', request.dhcpId)}`\n  }, unmarshalDHCP);\n\n  /**\n   * Create a DHCP configuration. Create a new DHCP configuration object,\n   * containing settings for the assignment of IP addresses to devices on a\n   * Private Network attached to a Public Gateway. The response object includes\n   * the ID of the DHCP configuration object. You can use this ID as part of a\n   * call to `Create a Public Gateway connection to a Private Network` or\n   * `Update a Public Gateway connection to a Private Network` to directly apply\n   * this DHCP configuration.\n   *\n   * @param request - The request {@link CreateDHCPRequest}\n   * @returns A Promise of DHCP\n   */\n  createDHCP = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDHCPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcps`\n  }, unmarshalDHCP);\n\n  /**\n   * Update a DHCP configuration. Update a DHCP configuration object, identified\n   * by its DHCP ID.\n   *\n   * @param request - The request {@link UpdateDHCPRequest}\n   * @returns A Promise of DHCP\n   */\n  updateDHCP = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateDHCPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PATCH',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcps/${validatePathParam('dhcpId', request.dhcpId)}`\n  }, unmarshalDHCP);\n\n  /**\n   * Delete a DHCP configuration. Delete a DHCP configuration object, identified\n   * by its DHCP ID. Note that you cannot delete a DHCP configuration object\n   * that is currently being used by a Gateway Network.\n   *\n   * @param request - The request {@link DeleteDHCPRequest}\n   */\n  deleteDHCP = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcps/${validatePathParam('dhcpId', request.dhcpId)}`\n  });\n  pageOfListDHCPEntries = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcp-entries`,\n    urlParams: urlParams(['gateway_network_id', request.gatewayNetworkId], ['hostname', request.hostname], ['ip_address', request.ipAddress], ['mac_address', request.macAddress], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['type', request.type ?? 'unknown'])\n  }, unmarshalListDHCPEntriesResponse);\n\n  /**\n   * List DHCP entries. List DHCP entries, whether dynamically assigned and/or\n   * statically reserved. DHCP entries can be filtered by the Gateway Network\n   * they are on, their MAC address, IP address, type or hostname.\n   *\n   * @param request - The request {@link ListDHCPEntriesRequest}\n   * @returns A Promise of ListDHCPEntriesResponse\n   */\n  listDHCPEntries = (request = {}) => enrichForPagination('dhcpEntries', this.pageOfListDHCPEntries, request);\n\n  /**\n   * Get a DHCP entry. Get a DHCP entry, specified by its DHCP entry ID.\n   *\n   * @param request - The request {@link GetDHCPEntryRequest}\n   * @returns A Promise of DHCPEntry\n   */\n  getDHCPEntry = request => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcp-entries/${validatePathParam('dhcpEntryId', request.dhcpEntryId)}`\n  }, unmarshalDHCPEntry);\n\n  /**\n   * Create a DHCP entry. Create a static DHCP reservation, specifying the\n   * Gateway Network for the reservation, the MAC address of the target device\n   * and the IP address to assign this device. The response is a DHCP entry\n   * object, confirming the ID and configuration details of the static DHCP\n   * reservation.\n   *\n   * @param request - The request {@link CreateDHCPEntryRequest}\n   * @returns A Promise of DHCPEntry\n   */\n  createDHCPEntry = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateDHCPEntryRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcp-entries`\n  }, unmarshalDHCPEntry);\n\n  /**\n   * Update a DHCP entry. Update the IP address for a DHCP entry, specified by\n   * its DHCP entry ID. You can update an existing DHCP entry of any type\n   * (`reservation` (static), `lease` (dynamic) or `unknown`), but in manually\n   * updating the IP address the entry will necessarily be of type `reservation`\n   * after the update.\n   *\n   * @param request - The request {@link UpdateDHCPEntryRequest}\n   * @returns A Promise of DHCPEntry\n   */\n  updateDHCPEntry = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateDHCPEntryRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PATCH',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcp-entries/${validatePathParam('dhcpEntryId', request.dhcpEntryId)}`\n  }, unmarshalDHCPEntry);\n\n  /**\n   * Set all DHCP reservations on a Gateway Network. Set the list of DHCP\n   * reservations attached to a Gateway Network. Reservations are identified by\n   * their MAC address, and will sync the current DHCP entry list to the given\n   * list, creating, updating or deleting DHCP entries accordingly.\n   *\n   * @param request - The request {@link SetDHCPEntriesRequest}\n   * @returns A Promise of SetDHCPEntriesResponse\n   */\n  setDHCPEntries = request => this.client.fetch({\n    body: JSON.stringify(marshalSetDHCPEntriesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PUT',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcp-entries`\n  }, unmarshalSetDHCPEntriesResponse);\n\n  /**\n   * Delete a DHCP entry. Delete a static DHCP reservation, identified by its\n   * DHCP entry ID. Note that you cannot delete DHCP entries of type `lease`,\n   * these are deleted automatically when their time-to-live expires.\n   *\n   * @param request - The request {@link DeleteDHCPEntryRequest}\n   */\n  deleteDHCPEntry = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/dhcp-entries/${validatePathParam('dhcpEntryId', request.dhcpEntryId)}`\n  });\n  pageOfListPATRules = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/pat-rules`,\n    urlParams: urlParams(['gateway_id', request.gatewayId], ['order_by', request.orderBy ?? 'created_at_asc'], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['private_ip', request.privateIp], ['protocol', request.protocol ?? 'unknown'])\n  }, unmarshalListPATRulesResponse);\n\n  /**\n   * List PAT rules. List PAT rules. You can filter by gateway ID to list all\n   * PAT rules for a particular gateway, or filter for PAT rules targeting a\n   * specific IP address or using a specific protocol.\n   *\n   * @param request - The request {@link ListPATRulesRequest}\n   * @returns A Promise of ListPATRulesResponse\n   */\n  listPATRules = (request = {}) => enrichForPagination('patRules', this.pageOfListPATRules, request);\n\n  /**\n   * Get a PAT rule. Get a PAT rule, specified by its PAT rule ID. The response\n   * object gives full details of the PAT rule, including the Public Gateway it\n   * belongs to and the configuration settings in terms of public / private\n   * ports, private IP and protocol.\n   *\n   * @param request - The request {@link GetPATRuleRequest}\n   * @returns A Promise of PATRule\n   */\n  getPATRule = request => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/pat-rules/${validatePathParam('patRuleId', request.patRuleId)}`\n  }, unmarshalPATRule);\n\n  /**\n   * Create a PAT rule. Create a new PAT rule on a specified Public Gateway,\n   * defining the protocol to use, public port to listen on, and private port /\n   * IP address to map to.\n   *\n   * @param request - The request {@link CreatePATRuleRequest}\n   * @returns A Promise of PATRule\n   */\n  createPATRule = request => this.client.fetch({\n    body: JSON.stringify(marshalCreatePATRuleRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/pat-rules`\n  }, unmarshalPATRule);\n\n  /**\n   * Update a PAT rule. Update a PAT rule, specified by its PAT rule ID.\n   * Configuration settings including private/public port, private IP address\n   * and protocol can all be updated.\n   *\n   * @param request - The request {@link UpdatePATRuleRequest}\n   * @returns A Promise of PATRule\n   */\n  updatePATRule = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdatePATRuleRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PATCH',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/pat-rules/${validatePathParam('patRuleId', request.patRuleId)}`\n  }, unmarshalPATRule);\n\n  /**\n   * Set all PAT rules. Set a definitive list of PAT rules attached to a Public\n   * Gateway. Each rule is identified by its public port and protocol. This will\n   * sync the current PAT rule list on the gateway with the new list, creating,\n   * updating or deleting PAT rules accordingly.\n   *\n   * @param request - The request {@link SetPATRulesRequest}\n   * @returns A Promise of SetPATRulesResponse\n   */\n  setPATRules = request => this.client.fetch({\n    body: JSON.stringify(marshalSetPATRulesRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PUT',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/pat-rules`\n  }, unmarshalSetPATRulesResponse);\n\n  /**\n   * Delete a PAT rule. Delete a PAT rule, identified by its PAT rule ID. This\n   * action is irreversible.\n   *\n   * @param request - The request {@link DeletePATRuleRequest}\n   */\n  deletePATRule = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/pat-rules/${validatePathParam('patRuleId', request.patRuleId)}`\n  });\n\n  /**\n   * List Public Gateway types. List the different Public Gateway commercial\n   * offer types available at Scaleway. The response is an array of objects\n   * describing the name and technical details of each available gateway type.\n   *\n   * @param request - The request {@link ListGatewayTypesRequest}\n   * @returns A Promise of ListGatewayTypesResponse\n   */\n  listGatewayTypes = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateway-types`\n  }, unmarshalListGatewayTypesResponse);\n  pageOfListIPs = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips`,\n    urlParams: urlParams(['is_free', request.isFree], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['reverse', request.reverse], ['tags', request.tags])\n  }, unmarshalListIPsResponse);\n\n  /**\n   * List IPs. List Public Gateway flexible IP addresses. A number of filter\n   * options are available for limiting results in the response.\n   *\n   * @param request - The request {@link ListIPsRequest}\n   * @returns A Promise of ListIPsResponse\n   */\n  listIPs = (request = {}) => enrichForPagination('ips', this.pageOfListIPs, request);\n\n  /**\n   * Get an IP. Get details of a Public Gateway flexible IP address, identified\n   * by its IP ID. The response object contains information including which (if\n   * any) Public Gateway using this IP address, the reverse and various other\n   * metadata.\n   *\n   * @param request - The request {@link GetIPRequest}\n   * @returns A Promise of IP\n   */\n  getIP = request => this.client.fetch({\n    method: 'GET',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ipId', request.ipId)}`\n  }, unmarshalIP);\n\n  /**\n   * Reserve an IP. Create (reserve) a new flexible IP address that can be used\n   * for a Public Gateway in a specified Scaleway Project.\n   *\n   * @param request - The request {@link CreateIPRequest}\n   * @returns A Promise of IP\n   */\n  createIP = (request = {}) => this.client.fetch({\n    body: JSON.stringify(marshalCreateIPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips`\n  }, unmarshalIP);\n\n  /**\n   * Update an IP. Update details of an existing flexible IP address, including\n   * its tags, reverse and the Public Gateway it is assigned to.\n   *\n   * @param request - The request {@link UpdateIPRequest}\n   * @returns A Promise of IP\n   */\n  updateIP = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateIPRequest(request, this.client.settings)),\n    headers: jsonContentHeaders$1,\n    method: 'PATCH',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ipId', request.ipId)}`\n  }, unmarshalIP);\n\n  /**\n   * Delete an IP. Delete a flexible IP address from your account. This action\n   * is irreversible.\n   *\n   * @param request - The request {@link DeleteIPRequest}\n   */\n  deleteIP = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/ips/${validatePathParam('ipId', request.ipId)}`\n  });\n\n  /**\n   * Refresh a Public Gateway's SSH keys. Refresh the SSH keys of a given Public\n   * Gateway, specified by its gateway ID. This adds any new SSH keys in the\n   * gateway's Scaleway Project to the gateway itself.\n   *\n   * @param request - The request {@link RefreshSSHKeysRequest}\n   * @returns A Promise of Gateway\n   */\n  refreshSSHKeys = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders$1,\n    method: 'POST',\n    path: `/vpc-gw/v1/zones/${validatePathParam('zone', request.zone ?? this.client.settings.defaultZone)}/gateways/${validatePathParam('gatewayId', request.gatewayId)}/refresh-ssh-keys`\n  }, unmarshalGateway);\n};\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API$1,\n  GATEWAY_NETWORK_TRANSIENT_STATUSES: GATEWAY_NETWORK_TRANSIENT_STATUSES,\n  GATEWAY_TRANSIENT_STATUSES: GATEWAY_TRANSIENT_STATUSES\n});\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: index_gen$1\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\n/** Lists transient statutes of the enum {@link HostingStatus}. */\nconst HOSTING_TRANSIENT_STATUSES = ['delivering', 'deleting'];\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst unmarshalHostingCpanelUrls = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HostingCpanelUrls' failed as data isn't a dictionary.`);\n  }\n  return {\n    dashboard: data.dashboard,\n    webmail: data.webmail\n  };\n};\nconst unmarshalHostingOption = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'HostingOption' failed as data isn't a dictionary.`);\n  }\n  return {\n    id: data.id,\n    name: data.name\n  };\n};\nconst unmarshalOfferProduct = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'OfferProduct' failed as data isn't a dictionary.`);\n  }\n  return {\n    databasesQuota: data.databases_quota,\n    emailAccountsQuota: data.email_accounts_quota,\n    emailStorageQuota: data.email_storage_quota,\n    hostingStorageQuota: data.hosting_storage_quota,\n    name: data.name,\n    option: data.option,\n    ram: data.ram,\n    supportIncluded: data.support_included,\n    vCpu: data.v_cpu\n  };\n};\nconst unmarshalDnsRecord = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DnsRecord' failed as data isn't a dictionary.`);\n  }\n  return {\n    name: data.name,\n    priority: data.priority,\n    status: data.status,\n    ttl: data.ttl,\n    type: data.type,\n    value: data.value\n  };\n};\nconst unmarshalHosting = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Hosting' failed as data isn't a dictionary.`);\n  }\n  return {\n    cpanelUrls: data.cpanel_urls ? unmarshalHostingCpanelUrls(data.cpanel_urls) : undefined,\n    createdAt: unmarshalDate(data.created_at),\n    dnsStatus: data.dns_status,\n    domain: data.domain,\n    id: data.id,\n    offerId: data.offer_id,\n    offerName: data.offer_name,\n    options: unmarshalArrayOfObject(data.options, unmarshalHostingOption),\n    organizationId: data.organization_id,\n    platformHostname: data.platform_hostname,\n    platformNumber: data.platform_number,\n    projectId: data.project_id,\n    region: data.region,\n    status: data.status,\n    tags: data.tags,\n    updatedAt: unmarshalDate(data.updated_at),\n    username: data.username\n  };\n};\nconst unmarshalNameserver = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Nameserver' failed as data isn't a dictionary.`);\n  }\n  return {\n    hostname: data.hostname,\n    isDefault: data.is_default,\n    status: data.status\n  };\n};\nconst unmarshalOffer = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'Offer' failed as data isn't a dictionary.`);\n  }\n  return {\n    available: data.available,\n    billingOperationPath: data.billing_operation_path,\n    id: data.id,\n    price: data.price ? unmarshalMoney(data.price) : undefined,\n    product: data.product ? unmarshalOfferProduct(data.product) : undefined,\n    quotaWarnings: data.quota_warnings\n  };\n};\nconst unmarshalDnsRecords = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'DnsRecords' failed as data isn't a dictionary.`);\n  }\n  return {\n    nameServers: unmarshalArrayOfObject(data.name_servers, unmarshalNameserver),\n    records: unmarshalArrayOfObject(data.records, unmarshalDnsRecord),\n    status: data.status\n  };\n};\nconst unmarshalListHostingsResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListHostingsResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    hostings: unmarshalArrayOfObject(data.hostings, unmarshalHosting),\n    totalCount: data.total_count\n  };\n};\nconst unmarshalListOffersResponse = data => {\n  if (!isJSONObject(data)) {\n    throw new TypeError(`Unmarshalling the type 'ListOffersResponse' failed as data isn't a dictionary.`);\n  }\n  return {\n    offers: unmarshalArrayOfObject(data.offers, unmarshalOffer)\n  };\n};\nconst marshalCreateHostingRequest = (request, defaults) => ({\n  domain: request.domain,\n  email: request.email,\n  offer_id: request.offerId,\n  option_ids: request.optionIds,\n  project_id: request.projectId ?? defaults.defaultProjectId,\n  tags: request.tags\n});\nconst marshalUpdateHostingRequest = (request, defaults) => ({\n  email: request.email,\n  offer_id: request.offerId,\n  option_ids: request.optionIds,\n  tags: request.tags\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\nconst jsonContentHeaders = {\n  'Content-Type': 'application/json; charset=utf-8'\n};\n\n/** Web Hosting API. */\nclass API extends API$q {\n  /** Lists the available regions of the API. */\n  static LOCALITIES = ['fr-par'];\n\n  /**\n   * Order a Web Hosting plan. Order a Web Hosting plan, specifying the offer\n   * type required via the `offer_id` parameter.\n   *\n   * @param request - The request {@link CreateHostingRequest}\n   * @returns A Promise of Hosting\n   */\n  createHosting = request => this.client.fetch({\n    body: JSON.stringify(marshalCreateHostingRequest(request, this.client.settings)),\n    headers: jsonContentHeaders,\n    method: 'POST',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hostings`\n  }, unmarshalHosting);\n  pageOfListHostings = (request = {}) => this.client.fetch({\n    method: 'GET',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hostings`,\n    urlParams: urlParams(['domain', request.domain], ['order_by', request.orderBy ?? 'created_at_asc'], ['organization_id', request.organizationId], ['page', request.page], ['page_size', request.pageSize ?? this.client.settings.defaultPageSize], ['project_id', request.projectId], ['statuses', request.statuses], ['tags', request.tags])\n  }, unmarshalListHostingsResponse);\n\n  /**\n   * List all Web Hosting plans. List all of your existing Web Hosting plans.\n   * Various filters are available to limit the results, including filtering by\n   * domain, status, tag and Project ID.\n   *\n   * @param request - The request {@link ListHostingsRequest}\n   * @returns A Promise of ListHostingsResponse\n   */\n  listHostings = (request = {}) => enrichForPagination('hostings', this.pageOfListHostings, request);\n\n  /**\n   * Get a Web Hosting plan. Get the details of one of your existing Web Hosting\n   * plans, specified by its `hosting_id`.\n   *\n   * @param request - The request {@link GetHostingRequest}\n   * @returns A Promise of Hosting\n   */\n  getHosting = request => this.client.fetch({\n    method: 'GET',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hostings/${validatePathParam('hostingId', request.hostingId)}`\n  }, unmarshalHosting);\n\n  /**\n   * Waits for {@link Hosting} to be in a final state.\n   *\n   * @param request - The request {@link GetHostingRequest}\n   * @param options - The waiting options\n   * @returns A Promise of Hosting\n   */\n  waitForHosting = (request, options) => waitForResource(options?.stop ?? (res => Promise.resolve(!HOSTING_TRANSIENT_STATUSES.includes(res.status))), this.getHosting, request, options);\n\n  /**\n   * Update a Web Hosting plan. Update the details of one of your existing Web\n   * Hosting plans, specified by its `hosting_id`. You can update parameters\n   * including the contact email address, tags, options and offer.\n   *\n   * @param request - The request {@link UpdateHostingRequest}\n   * @returns A Promise of Hosting\n   */\n  updateHosting = request => this.client.fetch({\n    body: JSON.stringify(marshalUpdateHostingRequest(request, this.client.settings)),\n    headers: jsonContentHeaders,\n    method: 'PATCH',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hostings/${validatePathParam('hostingId', request.hostingId)}`\n  }, unmarshalHosting);\n\n  /**\n   * Delete a Web Hosting plan. Delete a Web Hosting plan, specified by its\n   * `hosting_id`. Note that deletion is not immediate: it will take place at\n   * the end of the calendar month, after which time your Web Hosting plan and\n   * all its data (files and emails) will be irreversibly lost.\n   *\n   * @param request - The request {@link DeleteHostingRequest}\n   * @returns A Promise of Hosting\n   */\n  deleteHosting = request => this.client.fetch({\n    method: 'DELETE',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hostings/${validatePathParam('hostingId', request.hostingId)}`\n  }, unmarshalHosting);\n\n  /**\n   * Restore a Web Hosting plan. When you [delete a Web Hosting\n   * plan](#path-hostings-delete-a-hosting), definitive deletion does not take\n   * place until the end of the calendar month. In the time between initiating\n   * the deletion, and definitive deletion at the end of the month, you can\n   * choose to **restore** the Web Hosting plan, using this endpoint and\n   * specifying its `hosting_id`.\n   *\n   * @param request - The request {@link RestoreHostingRequest}\n   * @returns A Promise of Hosting\n   */\n  restoreHosting = request => this.client.fetch({\n    body: '{}',\n    headers: jsonContentHeaders,\n    method: 'POST',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/hostings/${validatePathParam('hostingId', request.hostingId)}/restore`\n  }, unmarshalHosting);\n\n  /**\n   * Get DNS records. Get the set of DNS records of a specified domain\n   * associated with a Web Hosting plan.\n   *\n   * @param request - The request {@link GetDomainDnsRecordsRequest}\n   * @returns A Promise of DnsRecords\n   */\n  getDomainDnsRecords = request => this.client.fetch({\n    method: 'GET',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/domains/${validatePathParam('domain', request.domain)}/dns-records`\n  }, unmarshalDnsRecords);\n\n  /**\n   * List all offers. List the different Web Hosting offers, and their options,\n   * available to order from Scaleway.\n   *\n   * @param request - The request {@link ListOffersRequest}\n   * @returns A Promise of ListOffersResponse\n   */\n  listOffers = request => this.client.fetch({\n    method: 'GET',\n    path: `/webhosting/v1alpha1/regions/${validatePathParam('region', request.region ?? this.client.settings.defaultRegion)}/offers`,\n    urlParams: urlParams(['hosting_id', request.hostingId], ['only_options', request.onlyOptions], ['order_by', request.orderBy ?? 'price_asc'], ['without_options', request.withoutOptions])\n  }, unmarshalListOffersResponse);\n}\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nconst ListHostingsRequest = {\n  page: {\n    greaterThan: 0\n  },\n  pageSize: {\n    greaterThan: 0,\n    lessThanOrEqual: 100\n  }\n};\n\nvar validationRules_gen = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ListHostingsRequest: ListHostingsRequest\n});\n\n// This file was automatically generated. DO NOT EDIT.\n// If you have any remark or suggestion do not hesitate to open an issue.\n\nvar index_gen = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  API: API,\n  HOSTING_TRANSIENT_STATUSES: HOSTING_TRANSIENT_STATUSES,\n  ValidationRules: validationRules_gen\n});\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1alpha1: index_gen\n});\n\nexports.API = API$q;\nexports.Account = index$s;\nexports.AppleSilicon = index$r;\nexports.BareMetal = index$p;\nexports.Billing = index$o;\nexports.Cockpit = index$n;\nexports.Container = index$m;\nexports.Domain = index$l;\nexports.Errors = index$t;\nexports.FlexibleIP = index$k;\nexports.Function = index$j;\nexports.IAM = index$i;\nexports.IOT = index$f;\nexports.Instance = index$g;\nexports.K8S = index$d;\nexports.LB = index$b;\nexports.MNQ = index$9;\nexports.Marketplace = index$a;\nexports.RDB = index$8;\nexports.Redis = index$7;\nexports.Registry = index$6;\nexports.Secret = index$5;\nexports.Test = index$4;\nexports.TransactionalEmail = index$3;\nexports.VPC = index$2;\nexports.VPCGW = index$1;\nexports.Webhosting = index;\nexports.addAsyncHeaderInterceptor = addAsyncHeaderInterceptor;\nexports.authenticateWithSessionToken = authenticateWithSessionToken;\nexports.createAdvancedClient = createAdvancedClient;\nexports.createClient = createClient;\nexports.enableConsoleLogger = enableConsoleLogger;\nexports.enrichForPagination = enrichForPagination;\nexports.isJSONObject = isJSONObject;\nexports.marshalMoney = marshalMoney;\nexports.marshalScwFile = marshalScwFile;\nexports.marshalTimeSeries = marshalTimeSeries;\nexports.resolveOneOf = resolveOneOf;\nexports.setLogger = setLogger;\nexports.unmarshalArrayOfObject = unmarshalArrayOfObject;\nexports.unmarshalDate = unmarshalDate;\nexports.unmarshalMapOfObject = unmarshalMapOfObject;\nexports.unmarshalMoney = unmarshalMoney;\nexports.unmarshalScwFile = unmarshalScwFile;\nexports.unmarshalServiceInfo = unmarshalServiceInfo;\nexports.unmarshalTimeSeries = unmarshalTimeSeries;\nexports.unmarshalTimeSeriesPoint = unmarshalTimeSeriesPoint;\nexports.urlParams = urlParams;\nexports.validatePathParam = validatePathParam;\nexports.waitForResource = waitForResource;\nexports.withAdditionalInterceptors = withAdditionalInterceptors;\nexports.withDefaultPageSize = withDefaultPageSize;\nexports.withHTTPClient = withHTTPClient;\nexports.withProfile = withProfile;\nexports.withUserAgent = withUserAgent;\nexports.withUserAgentSuffix = withUserAgentSuffix;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(9283);\n",""],"names":[],"sourceRoot":""}